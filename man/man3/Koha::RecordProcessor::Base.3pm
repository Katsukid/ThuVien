.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Koha::RecordProcessor::Base 3pm"
.TH Koha::RecordProcessor::Base 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::RecordProcessor::Base \- Base class for RecordProcessor filters
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use base qw(Koha::RecordProcessor::Base);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Base class for record normalizer filters. RecordProcessors must
provide the following methods:
.PP
\&\fBfilter ($record)\fR \- apply the filter and return the result. \f(CW$record\fR
may be either a scalar or an arrayref, and the return result will be
the same type.
.PP
The following variables must be defined in each filter:
  our \f(CW$NAME\fR ='Filter';
  our \f(CW$VERSION\fR = '1.0';
.PP
These methods may be overriden:
.PP
\&\fBinitialize (%params)\fR \- initialize the filter
.PP
\&\fBdestroy ()\fR \- destroy the filter
.PP
These methods should not be overridden unless you are very sure of what
you are doing:
.PP
\&\fBnew ()\fR \- create a new filter object
.PP
Note that the RecordProcessor will not clone the record that is
passed in. If you do not want to change the original MARC::Record
object (or whatever type of object you are passing in), you must
clone it \fIprior\fR to passing it off to the RecordProcessor.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&    my $filter = Koha::RecordProcessor::Base\->new;
.Ve
.PP
Create a new filter;
.SS "initialize"
.IX Subsection "initialize"
.Vb 1
\&    $filter\->initalize(%params);
.Ve
.PP
Initialize a filter using the specified parameters.
.SS "destroy"
.IX Subsection "destroy"
.Vb 1
\&    $filter\->destroy();
.Ve
.PP
Destroy the filter.
.SS "filter"
.IX Subsection "filter"
.Vb 2
\&    my $newrecord = $filter\->filter($record);
\&    my $newrecords = $filter\->filter(\e@records);
.Ve
.PP
Filter the specified record(s) and return the result.
