.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "C4::Biblio 3pm"
.TH C4::Biblio 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::Biblio \- cataloging management functions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Biblio.pm contains functions for managing storage and editing of bibliographic data within Koha. Most of the functions in this module are used for cataloging records: adding, editing, or removing biblios, biblioitems, or items. Koha's stores bibliographic information in three places:
.IP "1. in the biblio,biblioitems,items, etc tables, which are limited to a one-to-one mapping to underlying \s-1MARC\s0 data" 4
.IX Item "1. in the biblio,biblioitems,items, etc tables, which are limited to a one-to-one mapping to underlying MARC data"
.PD 0
.IP "2. as raw \s-1MARC\s0 in the Zebra index and storage engine" 4
.IX Item "2. as raw MARC in the Zebra index and storage engine"
.IP "3. as \s-1MARC XML\s0 in biblio_metadata.metadata" 4
.IX Item "3. as MARC XML in biblio_metadata.metadata"
.PD
.PP
In the 3.0 version of Koha, the authoritative record-level information is in biblio_metadata.metadata
.PP
Because the data isn't completely normalized there's a chance for information to get out of sync. The design choice to go with a un-normalized schema was driven by performance and stability concerns. However, if this occur, it can be considered as a bug : The \s-1API\s0 is (or should be) complete & the only entry point for all biblio/items managements.
.IP "1. Compared with MySQL, Zebra is slow to update an index for small data changes \*(-- especially for proc-intensive operations like circulation" 4
.IX Item "1. Compared with MySQL, Zebra is slow to update an index for small data changes especially for proc-intensive operations like circulation"
.PD 0
.IP "2. Zebra's index has been known to crash and a backup of the data is necessary to rebuild it in such cases" 4
.IX Item "2. Zebra's index has been known to crash and a backup of the data is necessary to rebuild it in such cases"
.PD
.PP
Because of this design choice, the process of managing storage and editing is a bit convoluted. Historically, Biblio.pm's grown to an unmanagable size and as a result we have several types of functions currently:
.IP "1. Add*/Mod*/Del*/ \- high-level external functions suitable for being called from external scripts to manage the collection" 4
.IX Item "1. Add*/Mod*/Del*/ - high-level external functions suitable for being called from external scripts to manage the collection"
.PD 0
.IP "2. _koha_* \- low-level internal functions for managing the koha tables" 4
.IX Item "2. _koha_* - low-level internal functions for managing the koha tables"
.IP "3. Marc management function : as the \s-1MARC\s0 record is stored in biblio_metadata.metadata, some subs dedicated to it's management are in this package. They should be used only internally by Biblio.pm, the only official entry points being AddBiblio, AddItem, ModBiblio, ModItem." 4
.IX Item "3. Marc management function : as the MARC record is stored in biblio_metadata.metadata, some subs dedicated to it's management are in this package. They should be used only internally by Biblio.pm, the only official entry points being AddBiblio, AddItem, ModBiblio, ModItem."
.IP "4. Zebra functions used to update the Zebra index" 4
.IX Item "4. Zebra functions used to update the Zebra index"
.IP "5. internal helper functions such as char_decode, checkitems, etc. Some of these probably belong in Koha.pm" 4
.IX Item "5. internal helper functions such as char_decode, checkitems, etc. Some of these probably belong in Koha.pm"
.PD
.PP
The \s-1MARC\s0 record (in biblio_metadata.metadata) contains the complete marc record, including items. It also contains the biblionumber. That is the reason why it is not stored directly by AddBiblio, with all other fields . To save a biblio, we need to :
.IP "1. save datas in biblio and biblioitems table, that gives us a biblionumber and a biblioitemnumber" 4
.IX Item "1. save datas in biblio and biblioitems table, that gives us a biblionumber and a biblioitemnumber"
.PD 0
.IP "2. add the biblionumber and biblioitemnumber into the \s-1MARC\s0 records" 4
.IX Item "2. add the biblionumber and biblioitemnumber into the MARC records"
.IP "3. save the marc record" 4
.IX Item "3. save the marc record"
.PD
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
.SS "AddBiblio"
.IX Subsection "AddBiblio"
.Vb 1
\&  ($biblionumber,$biblioitemnumber) = AddBiblio($record,$frameworkcode);
.Ve
.PP
Exported function (core \s-1API\s0) for adding a new biblio to koha.
.PP
The first argument is a \f(CW\*(C`MARC::Record\*(C'\fR object containing the
bib to add, while the second argument is the desired \s-1MARC\s0
framework code.
.PP
The \f(CW$options\fR argument is a hashref with additional parameters:
.IP "\fBdefer_marc_save\fR: used when ModBiblioMarc is handled by the caller" 4
.IX Item "defer_marc_save: used when ModBiblioMarc is handled by the caller"
.PD 0
.IP "\fBskip_record_index\fR: used when the indexing schedulling will be handled by the caller" 4
.IX Item "skip_record_index: used when the indexing schedulling will be handled by the caller"
.PD
.SS "ModBiblio"
.IX Subsection "ModBiblio"
.Vb 1
\&  ModBiblio($record, $biblionumber, $frameworkcode, $options);
.Ve
.PP
Replace an existing bib record identified by \f(CW$biblionumber\fR
with one supplied by the MARC::Record object \f(CW$record\fR.  The embedded
item, biblioitem, and biblionumber fields from the previous
version of the bib record replace any such fields of those tags that
are present in \f(CW$record\fR.  Consequently, \fBModBiblio()\fR is not
to be used to try to modify item records.
.PP
\&\f(CW$frameworkcode\fR specifies the \s-1MARC\s0 framework to use
when storing the modified bib record; among other things,
this controls how \s-1MARC\s0 fields get mapped to display columns
in the \f(CW\*(C`biblio\*(C'\fR and \f(CW\*(C`biblioitems\*(C'\fR tables, as well as
which fields are used to store embedded item, biblioitem,
and biblionumber data for indexing.
.PP
The \f(CW$options\fR argument is a hashref with additional parameters:
.ie n .IP """overlay_context""" 4
.el .IP "\f(CWoverlay_context\fR" 4
.IX Item "overlay_context"
This parameter is forwarded to \*(L"ApplyMarcOverlayRules\*(R" where it is used for
selecting the current rule set if MARCOverlayRules is enabled.
See \*(L"ApplyMarcOverlayRules\*(R" for more details.
.ie n .IP """disable_autolink""" 4
.el .IP "\f(CWdisable_autolink\fR" 4
.IX Item "disable_autolink"
Unless \f(CW\*(C`disable_autolink\*(C'\fR is passed ModBiblio will relink record headings
to authorities based on settings in the system preferences. This flag allows
us to not relink records when the authority linker is saving modifications.
.ie n .IP """skip_holds_queue""" 4
.el .IP "\f(CWskip_holds_queue\fR" 4
.IX Item "skip_holds_queue"
Unless \f(CW\*(C`skip_holds_queue\*(C'\fR is passed, ModBiblio will trigger the BatchUpdateBiblioHoldsQueue
task to rebuild the holds queue for the biblio if \fIRealTimeHoldsQueue\fR is enabled.
.PP
Returns 1 on success 0 on failure
.SS "_strip_item_fields"
.IX Subsection "_strip_item_fields"
.Vb 1
\&  _strip_item_fields($record, $frameworkcode)
.Ve
.PP
Utility routine to remove item tags from a
\&\s-1MARC\s0 bib.
.SS "DelBiblio"
.IX Subsection "DelBiblio"
.Vb 1
\&  my $error = &DelBiblio($biblionumber, $params);
.Ve
.PP
Exported function (core \s-1API\s0) for deleting a biblio in koha.
Deletes biblio record from Zebra and Koha tables (biblio & biblioitems)
Also backs it up to deleted* tables.
Checks to make sure that the biblio has no items attached.
return:
\&\f(CW$error\fR : undef unless an error occurs
.PP
\&\fI\f(CI$params\fI\fR is a hashref containing extra parameters. Valid keys are:
.IP "\fBskip_holds_queue\fR: used when the holds queue update will be handled by the caller" 4
.IX Item "skip_holds_queue: used when the holds queue update will be handled by the caller"
.PD 0
.IP "\fBskip_record_index\fR: used when the indexing schedulling will be handled by the caller" 4
.IX Item "skip_record_index: used when the indexing schedulling will be handled by the caller"
.PD
.SS "BiblioAutoLink"
.IX Subsection "BiblioAutoLink"
.Vb 1
\&  my $headings_linked = BiblioAutoLink($record, $frameworkcode)
.Ve
.PP
Automatically links headings in a bib record to authorities.
.PP
Returns the number of headings changed
.SS "LinkBibHeadingsToAuthorities"
.IX Subsection "LinkBibHeadingsToAuthorities"
.Vb 1
\&  my $num_headings_changed, %results = LinkBibHeadingsToAuthorities($linker, $marc, $frameworkcode, [$allowrelink, $tagtolink,  $verbose]);
.Ve
.PP
Links bib headings to authority records by checking
each authority-controlled field in the \f(CW\*(C`MARC::Record\*(C'\fR
object \f(CW$marc\fR, looking for a matching authority record,
and setting the linking subfield \f(CW$9\fR to the \s-1ID\s0 of that
authority record.
.PP
If \f(CW$allowrelink\fR is false, existing authids will never be
replaced, regardless of the values of LinkerKeepStale and
LinkerRelink.
.PP
Returns the number of heading links changed in the
\&\s-1MARC\s0 record.
.SS "_check_valid_auth_link"
.IX Subsection "_check_valid_auth_link"
.Vb 3
\&    if ( _check_valid_auth_link($authid, $field) ) {
\&        ...
\&    }
.Ve
.PP
Check whether the specified heading-auth link is valid without reference
to Zebra. Ideally this code would be in C4::Heading, but that won't be
possible until we have de-cycled C4::AuthoritiesMarc, so this is the
safest place.
.SS "GetBiblioData"
.IX Subsection "GetBiblioData"
.Vb 1
\&  $data = &GetBiblioData($biblionumber);
.Ve
.PP
Returns information about the book with the given biblionumber.
\&\f(CW&GetBiblioData\fR returns a reference-to-hash. The keys are the fields in
the \f(CW\*(C`biblio\*(C'\fR and \f(CW\*(C`biblioitems\*(C'\fR tables in the
Koha database.
.PP
In addition, \f(CW\*(C`$data\->{subject}\*(C'\fR is the list of the book's
subjects, separated by \f(CW" , "\fR (space, comma, space).
If there are multiple biblioitems with the given biblionumber, only
the first one is considered.
.SS "GetISBDView"
.IX Subsection "GetISBDView"
.Vb 5
\&  $isbd = &GetISBDView({
\&      \*(Aqrecord\*(Aq    => $marc_record,
\&      \*(Aqtemplate\*(Aq  => $interface, # opac/intranet
\&      \*(Aqframework\*(Aq => $framework,
\&  });
.Ve
.PP
Return the \s-1ISBD\s0 view which can be included in opac and intranet
.SH "FUNCTIONS FOR HANDLING MARC MANAGEMENT"
.IX Header "FUNCTIONS FOR HANDLING MARC MANAGEMENT"
.SS "IsMarcStructureInternal"
.IX Subsection "IsMarcStructureInternal"
.Vb 8
\&    my $tagslib = C4::Biblio::GetMarcStructure();
\&    for my $tag ( sort keys %$tagslib ) {
\&        next unless $tag;
\&        for my $subfield ( sort keys %{ $tagslib\->{$tag} } ) {
\&            next if IsMarcStructureInternal($tagslib\->{$tag}{$subfield});
\&        }
\&        # Process subfield
\&    }
.Ve
.PP
GetMarcStructure creates keys (lib, tab, mandatory, repeatable, important) for a display purpose.
These different values should not be processed as valid subfields.
.SS "GetMarcStructure"
.IX Subsection "GetMarcStructure"
.Vb 1
\&  $res = GetMarcStructure($forlibrarian, $frameworkcode, [ $params ]);
.Ve
.PP
Returns a reference to a big hash of hash, with the Marc structure for the given frameworkcode
\&\f(CW$forlibrarian\fR  :if set to 1, the \s-1MARC\s0 descriptions are the librarians ones, otherwise it's the public (\s-1OPAC\s0) ones
\&\f(CW$frameworkcode\fR : the framework code to read
\&\f(CW$params\fR allows you to pass { unsafe => 1 } for better performance.
.PP
Note: If you call GetMarcStructure with unsafe => 1, do not modify or
even autovivify its contents. It is a cached/shared data structure. Your
changes c/would be passed around in subsequent calls.
.SS "GetUsedMarcStructure"
.IX Subsection "GetUsedMarcStructure"
The same function as GetMarcStructure except it just takes field
in tab 0\-9. (used field)
.PP
.Vb 1
\&  my $results = GetUsedMarcStructure($frameworkcode);
.Ve
.PP
\&\f(CW$results\fR is a ref to an array which each case contains a ref
to a hash which each keys is the columns from marc_subfield_structure
.PP
\&\f(CW$frameworkcode\fR is the framework code.
.SS "GetMarcSubfieldStructure"
.IX Subsection "GetMarcSubfieldStructure"
.Vb 1
\&  my $structure = GetMarcSubfieldStructure($frameworkcode, [$params]);
.Ve
.PP
Returns a reference to hash representing \s-1MARC\s0 subfield structure
for framework with framework code \f(CW$frameworkcode\fR, \f(CW$params\fR is
optional and may contain additional options.
.ie n .IP "$frameworkcode" 4
.el .IP "\f(CW$frameworkcode\fR" 4
.IX Item "$frameworkcode"
The framework code.
.ie n .IP "$params" 4
.el .IP "\f(CW$params\fR" 4
.IX Item "$params"
An optional hash reference with additional options.
The following options are supported:
.RS 4
.IP "unsafe" 4
.IX Item "unsafe"
Pass { unsafe => 1 } do disable cached object cloning,
and instead get a shared reference, resulting in better
performance (but care must be taken so that retured object
is never modified).
.Sp
Note: If you call GetMarcSubfieldStructure with unsafe => 1, do not modify or
even autovivify its contents. It is a cached/shared data structure. Your
changes would be passed around in subsequent calls.
.RE
.RS 4
.RE
.SS "GetMarcFromKohaField"
.IX Subsection "GetMarcFromKohaField"
.Vb 3
\&    ( $field,$subfield ) = GetMarcFromKohaField( $kohafield );
\&    @fields = GetMarcFromKohaField( $kohafield );
\&    $field = GetMarcFromKohaField( $kohafield );
\&
\&    Returns the MARC fields & subfields mapped to $kohafield.
\&    Since the Default framework is considered as authoritative for such
\&    mappings, the former frameworkcode parameter is obsoleted.
\&
\&    In list context all mappings are returned; there can be multiple
\&    mappings. Note that in the above example you could miss a second
\&    mappings in the first call.
\&    In scalar context only the field tag of the first mapping is returned.
.Ve
.SS "GetMarcSubfieldStructureFromKohaField"
.IX Subsection "GetMarcSubfieldStructureFromKohaField"
.Vb 1
\&    my $str = GetMarcSubfieldStructureFromKohaField( $kohafield );
\&
\&    Returns marc subfield structure information for $kohafield.
\&    The Default framework is used, since it is authoritative for kohafield
\&    mappings.
\&    In list context returns a list of all hashrefs, since there may be
\&    multiple mappings. In scalar context the first hashref is returned.
.Ve
.SS "GetXmlBiblio"
.IX Subsection "GetXmlBiblio"
.Vb 1
\&  my $marcxml = GetXmlBiblio($biblionumber);
.Ve
.PP
Returns biblio_metadata.metadata/marcxml of the biblionumber passed in parameter.
The \s-1XML\s0 should only contain biblio information (item information is no longer stored in marcxml field)
.SS "GetMarcPrice"
.IX Subsection "GetMarcPrice"
return the prices in accordance with the Marc format.
.PP
returns 0 if no price found
returns undef if called without a marc record or with
an unrecognized marc format
.SS "MungeMarcPrice"
.IX Subsection "MungeMarcPrice"
Return the best guess at what the actual price is from a price field.
.SS "GetMarcQuantity"
.IX Subsection "GetMarcQuantity"
return the quantity of a book. Used in acquisition only, when importing a file an iso2709 from a bookseller
Warning : this is not really in the marc standard. In Unimarc, Electre (the most widely used bookseller) use the 969$a
.PP
returns 0 if no quantity found
returns undef if called without a marc record or with
an unrecognized marc format
.SS "GetAuthorisedValueDesc"
.IX Subsection "GetAuthorisedValueDesc"
.Vb 2
\&  my $subfieldvalue =get_authorised_value_desc(
\&    $tag, $subf[$i][0],$subf[$i][1], \*(Aq\*(Aq, $taglib, $category, $opac);
.Ve
.PP
Retrieve the complete description for a given authorised value.
.PP
Now takes \f(CW$category\fR and \f(CW$value\fR pair too.
.PP
.Vb 2
\&  my $auth_value_desc =GetAuthorisedValueDesc(
\&    \*(Aq\*(Aq,\*(Aq\*(Aq, \*(AqDVD\*(Aq ,\*(Aq\*(Aq,\*(Aq\*(Aq,\*(AqCCODE\*(Aq);
.Ve
.PP
If the optional \f(CW$opac\fR parameter is set to a true value, displays \s-1OPAC\s0 
descriptions rather than normal ones when they exist.
.SS "GetMarcControlnumber"
.IX Subsection "GetMarcControlnumber"
.Vb 1
\&  $marccontrolnumber = GetMarcControlnumber($record,$marcflavour);
.Ve
.PP
Get the control number / record Identifier from the \s-1MARC\s0 record and return it.
.SS "GetMarcISBN"
.IX Subsection "GetMarcISBN"
.Vb 1
\&  $marcisbnsarray = GetMarcISBN( $record, $marcflavour );
.Ve
.PP
Get all ISBNs from the \s-1MARC\s0 record and returns them in an array.
ISBNs stored in different fields depending on \s-1MARC\s0 flavour
.SS "GetMarcISSN"
.IX Subsection "GetMarcISSN"
.Vb 1
\&  $marcissnsarray = GetMarcISSN( $record, $marcflavour );
.Ve
.PP
Get all valid ISSNs from the \s-1MARC\s0 record and returns them in an array.
ISSNs are stored in different fields depending on \s-1MARC\s0 flavour
.SS "GetMarcSubjects"
.IX Subsection "GetMarcSubjects"
.Vb 1
\&  $marcsubjcts = GetMarcSubjects($record,$marcflavour);
.Ve
.PP
Get all subjects from the \s-1MARC\s0 record and returns them in an array.
The subjects are stored in different fields depending on \s-1MARC\s0 flavour
.SS "GetMarcUrls"
.IX Subsection "GetMarcUrls"
.Vb 1
\&  $marcurls = GetMarcUrls($record,$marcflavour);
.Ve
.PP
Returns arrayref of URLs from \s-1MARC\s0 data, suitable to pass to tmpl loop.
Assumes web resources (not uncommon in \s-1MARC21\s0 to omit resource type ind)
.SS "GetMarcSeries"
.IX Subsection "GetMarcSeries"
.Vb 1
\&  $marcseriesarray = GetMarcSeries($record,$marcflavour);
.Ve
.PP
Get all series from the \s-1MARC\s0 record and returns them in an array.
The series are stored in different fields depending on \s-1MARC\s0 flavour
.SS "UpsertMarcSubfield"
.IX Subsection "UpsertMarcSubfield"
.Vb 1
\&    my $record = C4::Biblio::UpsertMarcSubfield($MARC::Record, $fieldTag, $subfieldCode, $subfieldContent);
.Ve
.SS "UpsertMarcControlField"
.IX Subsection "UpsertMarcControlField"
.Vb 1
\&    my $record = C4::Biblio::UpsertMarcControlField($MARC::Record, $fieldTag, $content);
.Ve
.SS "GetFrameworkCode"
.IX Subsection "GetFrameworkCode"
.Vb 1
\&  $frameworkcode = GetFrameworkCode( $biblionumber )
.Ve
.SS "TransformKohaToMarc"
.IX Subsection "TransformKohaToMarc"
.Vb 1
\&    $record = TransformKohaToMarc( $hash [, $params ]  )
.Ve
.PP
This function builds a (partial) MARC::Record from a hash.
Hash entries can be from biblio, biblioitems or items.
The params hash includes the parameter no_split used in C4::Items.
.PP
This function is called in acquisition module, to create a basic catalogue
entry from user entry.
.SS "PrepHostMarcField"
.IX Subsection "PrepHostMarcField"
.Vb 1
\&    $hostfield = PrepHostMarcField ( $hostbiblionumber,$hostitemnumber,$marcflavour )
.Ve
.PP
This function returns a host field populated with data from the host record, the field can then be added to an analytical record
.SS "TransformHtmlToXml"
.IX Subsection "TransformHtmlToXml"
.Vb 2
\&  $xml = TransformHtmlToXml( $tags, $subfields, $values, $indicator, 
\&                             $ind_tag, $auth_type )
.Ve
.PP
\&\f(CW$auth_type\fR contains :
.IP "\- nothing : rebuild a biblio. In \s-1UNIMARC\s0 the encoding is in 100$a pos 26/27" 4
.IX Item "- nothing : rebuild a biblio. In UNIMARC the encoding is in 100$a pos 26/27"
.PD 0
.IP "\- \s-1UNIMARCAUTH :\s0 rebuild an authority. In \s-1UNIMARC,\s0 the encoding is in 100$a pos 13/14" 4
.IX Item "- UNIMARCAUTH : rebuild an authority. In UNIMARC, the encoding is in 100$a pos 13/14"
.IP "\- \s-1ITEM :\s0 rebuild an item : in \s-1UNIMARC,\s0 100$a, it's in the biblio ! (otherwise, we would get 2 100 fields !)" 4
.IX Item "- ITEM : rebuild an item : in UNIMARC, 100$a, it's in the biblio ! (otherwise, we would get 2 100 fields !)"
.PD
.SS "_default_ind_to_space"
.IX Subsection "_default_ind_to_space"
Passed what should be an indicator returns a space
if its undefined or zero length
.SS "TransformHtmlToMarc"
.IX Subsection "TransformHtmlToMarc"
.Vb 10
\&    L<$record> = TransformHtmlToMarc(L<$cgi>)
\&    L<$cgi> is the CGI object which contains the values for subfields
\&    {
\&        \*(Aqtag_010_indicator1_531951\*(Aq ,
\&        \*(Aqtag_010_indicator2_531951\*(Aq ,
\&        \*(Aqtag_010_code_a_531951_145735\*(Aq ,
\&        \*(Aqtag_010_subfield_a_531951_145735\*(Aq ,
\&        \*(Aqtag_200_indicator1_873510\*(Aq ,
\&        \*(Aqtag_200_indicator2_873510\*(Aq ,
\&        \*(Aqtag_200_code_a_873510_673465\*(Aq ,
\&        \*(Aqtag_200_subfield_a_873510_673465\*(Aq ,
\&        \*(Aqtag_200_code_b_873510_704318\*(Aq ,
\&        \*(Aqtag_200_subfield_b_873510_704318\*(Aq ,
\&        \*(Aqtag_200_code_e_873510_280822\*(Aq ,
\&        \*(Aqtag_200_subfield_e_873510_280822\*(Aq ,
\&        \*(Aqtag_200_code_f_873510_110730\*(Aq ,
\&        \*(Aqtag_200_subfield_f_873510_110730\*(Aq ,
\&    }
\&    L<$record> is the MARC::Record object.
.Ve
.SS "TransformMarcToKoha"
.IX Subsection "TransformMarcToKoha"
.Vb 1
\&    $result = TransformMarcToKoha({ record => $record, limit_table => $limit })
.Ve
.PP
Extract data from a \s-1MARC\s0 bib record into a hashref representing
Koha biblio, biblioitems, and items fields.
.PP
If passed an undefined record will log the error and return an empty
hash_ref.
.SS "_disambiguate"
.IX Subsection "_disambiguate"
.Vb 1
\&  $newkey = _disambiguate($table, $field);
.Ve
.PP
This is a temporary hack to distinguish between the
following sets of columns when using TransformMarcToKoha.
.PP
.Vb 2
\&  items.cn_source & biblioitems.cn_source
\&  items.cn_sort & biblioitems.cn_sort
.Ve
.PP
Columns that are currently \s-1NOT\s0 distinguished (\s-1FIXME\s0
due to lack of time to fully test) are:
.PP
.Vb 4
\&  biblio.notes and biblioitems.notes
\&  biblionumber
\&  timestamp
\&  biblioitemnumber
.Ve
.PP
\&\s-1FIXME\s0 \- this is necessary because prefixing each column
name with the table name would require changing lots
of code and templates, and exposing more of the \s-1DB\s0
structure than is good to the \s-1UI\s0 templates, particularly
since biblio and bibloitems may well merge in a future
version.  In the future, it would also be good to 
separate \s-1DB\s0 access and \s-1UI\s0 presentation field names
more.
.SS "_adjust_pubyear"
.IX Subsection "_adjust_pubyear"
.Vb 1
\&    Helper routine for TransformMarcToKoha
.Ve
.SS "CountItemsIssued"
.IX Subsection "CountItemsIssued"
.Vb 1
\&    my $count = CountItemsIssued( $biblionumber );
.Ve
.SS "ModZebra"
.IX Subsection "ModZebra"
.Vb 1
\&    ModZebra( $record_number, $op, $server );
.Ve
.PP
\&\f(CW$record_number\fR is the authid or biblionumber we want to index
.PP
\&\f(CW$op\fR is the operation: specialUpdate or recordDelete
.PP
\&\f(CW$server\fR is authorityserver or biblioserver
.SH "INTERNAL FUNCTIONS"
.IX Header "INTERNAL FUNCTIONS"
.SS "_koha_marc_update_bib_ids"
.IX Subsection "_koha_marc_update_bib_ids"
.Vb 1
\&  _koha_marc_update_bib_ids($record, $frameworkcode, $biblionumber, $biblioitemnumber);
.Ve
.PP
Internal function to add or update biblionumber and biblioitemnumber to
the \s-1MARC XML.\s0
.SS "_koha_marc_update_biblioitem_cn_sort"
.IX Subsection "_koha_marc_update_biblioitem_cn_sort"
.Vb 1
\&  _koha_marc_update_biblioitem_cn_sort($marc, $biblioitem, $frameworkcode);
.Ve
.PP
Given a \s-1MARC\s0 bib record and the biblioitem hash, update the
subfield that contains a copy of the value of biblioitems.cn_sort.
.SS "_koha_modify_biblio"
.IX Subsection "_koha_modify_biblio"
.Vb 1
\&  my ($biblionumber,$error) == _koha_modify_biblio($dbh,$biblio,$frameworkcode);
.Ve
.PP
Internal function for updating the biblio table
.SS "_koha_modify_biblioitem_nonmarc"
.IX Subsection "_koha_modify_biblioitem_nonmarc"
.Vb 1
\&  my ($biblioitemnumber,$error) = _koha_modify_biblioitem_nonmarc( $dbh, $biblioitem );
.Ve
.SS "_koha_delete_biblio"
.IX Subsection "_koha_delete_biblio"
.Vb 1
\&  $error = _koha_delete_biblio($dbh,$biblionumber);
.Ve
.PP
Internal sub for deleting from biblio table \*(-- also saves to deletedbiblio
.PP
\&\f(CW$dbh\fR \- the database handle
.PP
\&\f(CW$biblionumber\fR \- the biblionumber of the biblio to be deleted
.SS "_koha_delete_biblioitems"
.IX Subsection "_koha_delete_biblioitems"
.Vb 1
\&  $error = _koha_delete_biblioitems($dbh,$biblioitemnumber);
.Ve
.PP
Internal sub for deleting from biblioitems table \*(-- also saves to deletedbiblioitems
.PP
\&\f(CW$dbh\fR \- the database handle
\&\f(CW$biblionumber\fR \- the biblioitemnumber of the biblioitem to be deleted
.SS "_koha_delete_biblio_metadata"
.IX Subsection "_koha_delete_biblio_metadata"
.Vb 1
\&  $error = _koha_delete_biblio_metadata($biblionumber);
.Ve
.PP
\&\f(CW$biblionumber\fR \- the biblionumber of the biblio metadata to be deleted
.SH "UNEXPORTED FUNCTIONS"
.IX Header "UNEXPORTED FUNCTIONS"
.SS "ModBiblioMarc"
.IX Subsection "ModBiblioMarc"
.Vb 1
\&  ModBiblioMarc($newrec,$biblionumber);
.Ve
.PP
Add \s-1MARC XML\s0 data for a biblio to koha
.PP
Function exported, but should \s-1NOT\s0 be used, unless you really know what you're doing
.SS "prepare_host_field"
.IX Subsection "prepare_host_field"
\&\f(CW$marcfield\fR = prepare_host_field( \f(CW$hostbiblioitem\fR, \f(CW$marcflavour\fR );
Generate the host item entry for an analytic child entry
.SS "UpdateTotalIssues"
.IX Subsection "UpdateTotalIssues"
.Vb 1
\&  UpdateTotalIssues($biblionumber, $increase, [$value])
.Ve
.PP
Update the total issue count for a particular bib record.
.ie n .IP "$biblionumber is the biblionumber of the bib to update" 4
.el .IP "\f(CW$biblionumber\fR is the biblionumber of the bib to update" 4
.IX Item "$biblionumber is the biblionumber of the bib to update"
.PD 0
.ie n .IP "$increase is the amount to increase (or decrease) the total issues count by" 4
.el .IP "\f(CW$increase\fR is the amount to increase (or decrease) the total issues count by" 4
.IX Item "$increase is the amount to increase (or decrease) the total issues count by"
.ie n .IP "$value is the absolute value that total issues count should be set to. If provided, $increase is ignored." 4
.el .IP "\f(CW$value\fR is the absolute value that total issues count should be set to. If provided, \f(CW$increase\fR is ignored." 4
.IX Item "$value is the absolute value that total issues count should be set to. If provided, $increase is ignored."
.PD
.SS "RemoveAllNsb"
.IX Subsection "RemoveAllNsb"
.Vb 1
\&    &RemoveAllNsb($record);
.Ve
.PP
Removes all nsb/nse chars from a record
.SS "ApplyMarcOverlayRules"
.IX Subsection "ApplyMarcOverlayRules"
.Vb 1
\&    my $record = ApplyMarcOverlayRules($params)
.Ve
.PP
Applies marc merge rules to a record.
.PP
\&\f(CW$params\fR is expected to be a hashref with below keys defined.
.ie n .IP """biblionumber"" biblionumber of old record" 4
.el .IP "\f(CWbiblionumber\fR biblionumber of old record" 4
.IX Item "biblionumber biblionumber of old record"
.PD 0
.ie n .IP """record"" Incoming record that will be merged with old record" 4
.el .IP "\f(CWrecord\fR Incoming record that will be merged with old record" 4
.IX Item "record Incoming record that will be merged with old record"
.ie n .IP """overlay_context"" hashref containing at least one context module and filter value on the form {module => filter, ...}." 4
.el .IP "\f(CWoverlay_context\fR hashref containing at least one context module and filter value on the form {module => filter, ...}." 4
.IX Item "overlay_context hashref containing at least one context module and filter value on the form {module => filter, ...}."
.PD
.PP
Returns:
.ie n .IP "$record" 4
.el .IP "\f(CW$record\fR" 4
.IX Item "$record"
Merged \s-1MARC\s0 record based with merge rules for \f(CW\*(C`context\*(C'\fR applied. If no old
record for \f(CW\*(C`biblionumber\*(C'\fR can be found, \f(CW\*(C`record\*(C'\fR is returned unchanged.
Default action when no matching context is found to return \f(CW\*(C`record\*(C'\fR unchanged.
If no rules are found for a certain field tag the default is to overwrite with
fields with this field tag from \f(CW\*(C`record\*(C'\fR.
.SS "_after_biblio_action_hooks"
.IX Subsection "_after_biblio_action_hooks"
Helper method that takes care of calling all plugin hooks
.SH "AUTHOR"
.IX Header "AUTHOR"
Koha Development Team <http://koha\-community.org/>
.PP
Paul \s-1POULAIN\s0 paul.poulain@free.fr
.PP
Joshua Ferraro jmf@liblime.com
