.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Koha::Z3950Responder::Session 3pm"
.TH Koha::Z3950Responder::Session 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::Z3950Responder::Session
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
An abstract class where backend-specific session modules are derived from.
Z3950Responder creates one of the child classes depending on the SearchEngine
preference.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class contains common functions for handling searching for and fetching
of records. It can optionally add item status information to the returned
records. The backend-specific abstract methods need to be implemented in a
child class.
.SS "\s-1CONSTANTS\s0"
.IX Subsection "CONSTANTS"
OIDs and diagnostic codes used in Z39.50
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "\s-1INSTANCE METHODS\s0"
.IX Subsection "INSTANCE METHODS"
\fInew\fR
.IX Subsection "new"
.PP
.Vb 4
\&    my $session = $self\->new({
\&        server => $z3950responder,
\&        peer => \*(AqPEER NAME\*(Aq
\&    });
.Ve
.PP
Instantiate a Session
.PP
\fIsearch_handler\fR
.IX Subsection "search_handler"
.PP
.Vb 1
\&    Callback that is called when a new search is performed
.Ve
.PP
Calls \f(CW\*(C`start_search\*(C'\fR for backend-specific retrieval logic
.PP
\fIfetch_handler\fR
.IX Subsection "fetch_handler"
.PP
.Vb 1
\&    Callback that is called when records are requested
.Ve
.PP
Calls \f(CW\*(C`fetch_record\*(C'\fR for backend-specific retrieval logic
.PP
\fIclose_handler\fR
.IX Subsection "close_handler"
.PP
Callback that is called when a session is terminated
.PP
\fIstart_search\fR
.IX Subsection "start_search"
.PP
.Vb 1
\&    my ($resultset, $hits) = $self\->_start_search( $args, $self\->{server}\->{num_to_prefetch} );
.Ve
.PP
A backend-specific method for starting a new search
.PP
\fIcheck_fetch\fR
.IX Subsection "check_fetch"
.PP
.Vb 1
\&    $self\->check_fetch($resultset, $args, $offset, $num_records);
.Ve
.PP
Check that the fetch request parameters are within bounds of the result set.
.PP
\fIfetch_record\fR
.IX Subsection "fetch_record"
.PP
.Vb 1
\&    my $record = $self\->_fetch_record( $resultset, $args, $offset, $server\->{num_to_prefetch} );
.Ve
.PP
A backend-specific method for fetching a record
.PP
\fIadd_item_status\fR
.IX Subsection "add_item_status"
.PP
.Vb 1
\&    $self\->add_item_status( $field );
.Ve
.PP
Add item status to the given field
.PP
\fIlog_debug\fR
.IX Subsection "log_debug"
.PP
.Vb 1
\&    $self\->log_debug(\*(AqMessage\*(Aq);
.Ve
.PP
Output a debug message
.PP
\fIlog_info\fR
.IX Subsection "log_info"
.PP
.Vb 1
\&    $self\->log_info(\*(AqMessage\*(Aq);
.Ve
.PP
Output an info message
.PP
\fIlog_error\fR
.IX Subsection "log_error"
.PP
.Vb 1
\&    $self\->log_error(\*(AqMessage\*(Aq);
.Ve
.PP
Output an error message
.PP
\fIset_error\fR
.IX Subsection "set_error"
.PP
.Vb 1
\&    $self\->set_error($args, $self\->ERR_SEARCH_FAILED, \*(AqBackend connection failed\*(Aq );
.Ve
.PP
Set and log an error code and diagnostic message to be returned to the client
