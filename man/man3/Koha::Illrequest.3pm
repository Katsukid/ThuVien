.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Koha::Illrequest 3pm"
.TH Koha::Illrequest 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::Illrequest \- Koha Illrequest Object class
.SH "(Re)Design"
.IX Header "(Re)Design"
An ILLRequest consists of two parts; the Illrequest Koha::Object, and a series
of related Illrequestattributes.
.PP
The former encapsulates the basic necessary information that any \s-1ILL\s0 requires
to be usable in Koha.  The latter is a set of additional properties used by
one of the backends.
.PP
The former subsumes the legacy \*(L"Status\*(R" object.  The latter remains
encapsulated in the \*(L"Record\*(R" object.
.PP
\&\s-1TODO:\s0
.PP
\&\- Anything invoking the \->status method; annotated with:
  + # Old use of \->status !
.SH "API"
.IX Header "API"
.SS "Backend \s-1API\s0 Response Principles"
.IX Subsection "Backend API Response Principles"
All methods should return a hashref in the following format:
.IP "\(bu" 4
error
.Sp
This should be set to 1 if an error was encountered.
.IP "\(bu" 4
status
.Sp
The status should be a string from the list of statuses detailed below.
.IP "\(bu" 4
message
.Sp
The message is a free text field that can be passed on to the end user.
.IP "\(bu" 4
value
.Sp
The value returned by the method.
.SS "Interface Status Messages"
.IX Subsection "Interface Status Messages"
.IP "\(bu" 4
branch_address_incomplete
.Sp
An interface request has determined branch address details are incomplete.
.IP "\(bu" 4
cancel_success
.Sp
The interface's cancel_request method was successful in cancelling the
Illrequest using the \s-1API.\s0
.IP "\(bu" 4
cancel_fail
.Sp
The interface's cancel_request method failed to cancel the Illrequest using
the \s-1API.\s0
.IP "\(bu" 4
unavailable
.Sp
The interface's request method returned saying that the desired item is not
available for request.
.SS "Class methods"
.IX Subsection "Class methods"
\fIinit_processors\fR
.IX Subsection "init_processors"
.PP
.Vb 1
\&    $request\->init_processors()
.Ve
.PP
Initialises an empty processors arrayref
.PP
\fIpush_processor\fR
.IX Subsection "push_processor"
.PP
.Vb 1
\&    $request\->push_processors(sub { ...something... });
.Ve
.PP
Pushes a passed processor function into our processors arrayref
.PP
\fIstatusalias\fR
.IX Subsection "statusalias"
.PP
.Vb 1
\&    my $statusalias = $request\->statusalias;
.Ve
.PP
Returns a request's status alias, as a Koha::AuthorisedValue instance
or implicit undef. This is distinct from status_alias, which only returns
the value in the status_alias column, this method returns the entire
AuthorisedValue object
.PP
\fIillrequestattributes\fR
.IX Subsection "illrequestattributes"
.PP
\fIillcomments\fR
.IX Subsection "illcomments"
.PP
\fIcomments\fR
.IX Subsection "comments"
.PP
.Vb 1
\&    my $ill_comments = $req\->comments;
.Ve
.PP
Returns a \fIKoha::Illcomments\fR resultset for the linked comments.
.PP
\fIlogs\fR
.IX Subsection "logs"
.PP
\fIpatron\fR
.IX Subsection "patron"
.PP
.Vb 1
\&    my $patron = $request\->patron;
.Ve
.PP
Returns the linked \fIKoha::Patron\fR object.
.PP
\fIlibrary\fR
.IX Subsection "library"
.PP
.Vb 1
\&    my $library = $request\->library;
.Ve
.PP
Returns the linked \fIKoha::Library\fR object.
.PP
\fIextended_attributes\fR
.IX Subsection "extended_attributes"
.PP
.Vb 1
\&    my $extended_attributes = $request\->extended_attributes;
.Ve
.PP
Returns the linked \fIKoha::Illrequestattributes\fR resultset object.
.PP
\fIstatus_alias\fR
.IX Subsection "status_alias"
.PP
.Vb 1
\&    $Illrequest\->status_alias(143);
.Ve
.PP
Overloaded getter/setter for status_alias,
that only returns authorised values from the
correct category and records the fact that the status has changed
.PP
\fIstatus\fR
.IX Subsection "status"
.PP
.Vb 1
\&    $Illrequest\->status(\*(AqCANREQ\*(Aq);
.Ve
.PP
Overloaded getter/setter for request status,
also nullifies status_alias and records the fact that the status has changed
and sends a notice if appropriate
.PP
\fIload_backend\fR
.IX Subsection "load_backend"
.PP
Require \*(L"Base.pm\*(R" from the relevant \s-1ILL\s0 backend.
.PP
\fI_backend\fR
.IX Subsection "_backend"
.PP
.Vb 2
\&    my $backend = $abstract\->_backend($new_backend);
\&    my $backend = $abstract\->_backend;
.Ve
.PP
Getter/Setter for our \s-1API\s0 object.
.PP
\fI_backend_capability\fR
.IX Subsection "_backend_capability"
.PP
.Vb 1
\&    my $backend_capability_result = $self\->_backend_capability($name, $args);
.Ve
.PP
This is a helper method to invoke optional capabilities in the backend.  If
the capability named by \f(CW$name\fR is not supported, return 0, else invoke it,
passing \f(CW$args\fR along with the invocation, and return its return value.
.PP
\&\s-1NOTE:\s0 this module suffers from a confusion in termninology:
.PP
in _backend_capability, the notion of capability refers to an optional feature
that is implemented in core, but might not be supported by a given backend.
.PP
in capabilities & custom_capability, capability refers to entries in the
status_graph (after union between backend and core).
.PP
The easiest way to fix this would be to fix the terminology in
capabilities & custom_capability and their callers.
.PP
\fI_config\fR
.IX Subsection "_config"
.PP
.Vb 2
\&    my $config = $abstract\->_config($config);
\&    my $config = $abstract\->_config;
.Ve
.PP
Getter/Setter for our config object.
.PP
\fImetadata\fR
.IX Subsection "metadata"
.PP
\fI_core_status_graph\fR
.IX Subsection "_core_status_graph"
.PP
.Vb 1
\&    my $core_status_graph = $illrequest\->_core_status_graph;
.Ve
.PP
Returns \s-1ILL\s0 module's default status graph.  A status graph defines the list of
available actions at any stage in the \s-1ILL\s0 workflow.  This is for instance used
by the perl script & template to generate the correct buttons to display to
the end user at any given point.
.PP
\fI_status_graph_union\fR
.IX Subsection "_status_graph_union"
.PP
.Vb 1
\&    my $status_graph = $illrequest\->_status_graph_union($origin, $new_graph);
.Ve
.PP
Return a new status_graph, the result of merging \f(CW$origin\fR & new_graph.  This is
operation is a union over the sets defied by the two graphs.
.PP
Each entry in \f(CW$new_graph\fR is added to \f(CW$origin\fR.  We do not provide a syntax for
\&'subtraction' of entries from \f(CW$origin\fR.
.PP
Whilst it is not intended that this works, you can override entries in \f(CW$origin\fR
with entries with the same key in \f(CW$new_graph\fR.  This can lead to problematic
behaviour when \f(CW$new_graph\fR adds an entry, which modifies a dependent entry in
\&\f(CW$origin\fR, only for the entry in \f(CW$origin\fR to be replaced later with a new entry
from \f(CW$new_graph\fR.
.PP
\&\s-1NOTE:\s0 this procedure does not \*(L"re-link\*(R" entries in \f(CW$origin\fR or \f(CW$new_graph\fR,
i.e. each of the graphs need to be correct at the outset of the operation.
.PP
\fIcapabilities\fR
.IX Subsection "capabilities"
.PP
.Vb 1
\&    my $capabilities = $illrequest\->capabilities;
.Ve
.PP
Return a hashref mapping methods to operation names supported by the queried
backend.
.PP
Example return value:
.PP
.Vb 1
\&    { create => "Create Request", confirm => "Progress Request" }
.Ve
.PP
\&\s-1NOTE:\s0 this module suffers from a confusion in termninology:
.PP
in _backend_capability, the notion of capability refers to an optional feature
that is implemented in core, but might not be supported by a given backend.
.PP
in capabilities & custom_capability, capability refers to entries in the
status_graph (after union between backend and core).
.PP
The easiest way to fix this would be to fix the terminology in
capabilities & custom_capability and their callers.
.PP
\fIcustom_capability\fR
.IX Subsection "custom_capability"
.PP
Return the result of invoking \f(CW$CANDIDATE\fR on this request's backend with
\&\f(CW$PARAMS\fR, or 0 if \f(CW$CANDIDATE\fR is an unknown method on backend.
.PP
\&\s-1NOTE:\s0 this module suffers from a confusion in termninology:
.PP
in _backend_capability, the notion of capability refers to an optional feature
that is implemented in core, but might not be supported by a given backend.
.PP
in capabilities & custom_capability, capability refers to entries in the
status_graph (after union between backend and core).
.PP
The easiest way to fix this would be to fix the terminology in
capabilities & custom_capability and their callers.
.PP
\fIavailable_backends\fR
.IX Subsection "available_backends"
.PP
Return a list of available backends.
.PP
\fIavailable_actions\fR
.IX Subsection "available_actions"
.PP
Return a list of available actions.
.PP
\fImark_completed\fR
.IX Subsection "mark_completed"
.PP
Mark a request as completed (status = \s-1COMP\s0).
.SS "backend_illview"
.IX Subsection "backend_illview"
View and manage an \s-1ILL\s0 request
.SS "backend_migrate"
.IX Subsection "backend_migrate"
Migrate a request from one backend to another.
.SS "backend_confirm"
.IX Subsection "backend_confirm"
Confirm a request. The backend handles setting of mandatory fields in the commit stage:
.IP "\(bu" 4
orderid
.IP "\(bu" 4
accessurl, cost (if available).
.PP
\fIbackend_update_status\fR
.IX Subsection "backend_update_status"
.PP
\fIbackend_cancel\fR
.IX Subsection "backend_cancel"
.PP
.Vb 1
\&    my $ILLResponse = $illRequest\->backend_cancel;
.Ve
.PP
The standard interface method allowing for request cancellation.
.PP
\fIbackend_renew\fR
.IX Subsection "backend_renew"
.PP
.Vb 1
\&    my $renew_response = $illRequest\->backend_renew;
.Ve
.PP
The standard interface method allowing for request renewal queries.
.PP
\fIbackend_create\fR
.IX Subsection "backend_create"
.PP
.Vb 1
\&    my $create_response = $abstractILL\->backend_create($params);
.Ve
.PP
Return an array of Record objects created by querying our backend with
a Search query.
.PP
In the context of the other \s-1ILL\s0 methods, this is a special method: we only
pass it \f(CW$params\fR, as it does not yet have any other data associated with it.
.PP
\fIbackend_get_update\fR
.IX Subsection "backend_get_update"
.PP
.Vb 1
\&    my $update = backend_get_update($request);
\&
\&    Given a request, returns an update in a prescribed
\&    format that can then be passed to update parsers
.Ve
.PP
\fIexpandTemplate\fR
.IX Subsection "expandTemplate"
.PP
.Vb 1
\&    my $params = $abstract\->expandTemplate($params);
.Ve
.PP
Return a version of \f(CW$PARAMS\fR augmented with our required template path.
.PP
\fIgetLimits\fR
.IX Subsection "getLimits"
.PP
.Vb 4
\&    my $limit_rules = $abstract\->getLimits( {
\&        type  => \*(Aqbrw_cat\*(Aq | \*(Aqbranch\*(Aq,
\&        value => $value
\&    } );
.Ve
.PP
Return the \s-1ILL\s0 limit rules for the supplied combination of type / value.
.PP
As the config may have no rules for this particular type / value combination,
or for the default, we must define fall-back values here.
.PP
\fIgetPrefix\fR
.IX Subsection "getPrefix"
.PP
.Vb 3
\&    my $prefix = $abstract\->getPrefix( {
\&        branch  => $branch_code
\&    } );
.Ve
.PP
Return the \s-1ILL\s0 prefix as defined by our \f(CW$params:\fR either per borrower category,
per branch or the default.
.PP
\fIget_type\fR
.IX Subsection "get_type"
.PP
.Vb 1
\&    my $type = $abstract\->get_type();
.Ve
.PP
Return a string representing the material type of this request or undef
.PP
\fIcheck_limits\fR
.IX Subsection "check_limits"
.PP
.Vb 4
\&    my $ok = $illRequests\->check_limits( {
\&        borrower   => $borrower,
\&        branchcode => \*(Aqbranchcode\*(Aq | undef,
\&    } );
.Ve
.PP
Given \f(CW$PARAMS\fR, a hashref containing a \f(CW$borrower\fR object and a \f(CW$branchcode\fR,
see whether we are still able to place ILLs.
.PP
LimitRules are derived from koha\-conf.xml:
 + default limit counts, and counting method
 + branch specific limit counts & counting method
 + borrower category specific limit counts & counting method
 + err on the side of caution: a counting fail will cause fail, even if
   the other counts passes.
.PP
\fIrequires_moderation\fR
.IX Subsection "requires_moderation"
.PP
.Vb 1
\&    my $status = $illRequest\->requires_moderation;
.Ve
.PP
Return the name of the status if moderation by staff is required; or 0
otherwise.
.PP
\fIbiblio\fR
.IX Subsection "biblio"
.PP
.Vb 1
\&    my $biblio = $request\->biblio;
.Ve
.PP
For a given request, return the biblio associated with it,
or undef if none exists
.PP
\fIcheck_out\fR
.IX Subsection "check_out"
.PP
.Vb 1
\&    my $stage_summary = $request\->check_out;
.Ve
.PP
Handle the check_out method. The first stage involves gathering the required
data from the user via a form, the second stage creates an item and tries to
issue it to the patron. If successful, it notifies the patron, then it
returns a summary of how things went
.PP
\fIgeneric_confirm\fR
.IX Subsection "generic_confirm"
.PP
.Vb 1
\&    my $stage_summary = $illRequest\->generic_confirm;
.Ve
.PP
Handle the generic_confirm extended method.  The first stage involves creating
a template email for the end user to edit in the browser.  The second stage
attempts to submit the email.
.PP
\fIsend_patron_notice\fR
.IX Subsection "send_patron_notice"
.PP
.Vb 1
\&    my $result = $request\->send_patron_notice($notice_code);
.Ve
.PP
Send a specified notice regarding this request to a patron
.PP
\fIsend_staff_notice\fR
.IX Subsection "send_staff_notice"
.PP
.Vb 1
\&    my $result = $request\->send_staff_notice($notice_code);
.Ve
.PP
Send a specified notice regarding this request to staff
.PP
\fIget_notice\fR
.IX Subsection "get_notice"
.PP
.Vb 1
\&    my $notice = $request\->get_notice($params);
.Ve
.PP
Return a compiled notice hashref for the passed notice code
and transport type
.PP
\fIattach_processors\fR
.IX Subsection "attach_processors"
.PP
Receive a Koha::Illrequest::SupplierUpdate and attach
any processors we have for it
.PP
\fIappend_to_note\fR
.IX Subsection "append_to_note"
.PP
.Vb 1
\&    append_to_note("Some text");
.Ve
.PP
Append some text to the staff note
.PP
\fIid_prefix\fR
.IX Subsection "id_prefix"
.PP
.Vb 1
\&    my $prefix = $record\->id_prefix;
.Ve
.PP
Return the prefix appropriate for the current Illrequest as derived from the
borrower and branch associated with this request's Status, and the config
file.
.PP
\fI_censor\fR
.IX Subsection "_censor"
.PP
.Vb 1
\&    my $params = $illRequest\->_censor($params);
.Ve
.PP
Return \f(CW$params\fR, modified to reflect our censorship requirements.
.PP
\fIstore\fR
.IX Subsection "store"
.PP
.Vb 1
\&    $Illrequest\->store;
.Ve
.PP
Overloaded \fIstore\fR method that, in addition to performing the 'store',
possibly records the fact that something happened
.PP
\fIrequested_partners\fR
.IX Subsection "requested_partners"
.PP
.Vb 1
\&    my $partners_string = $illRequest\->requested_partners;
.Ve
.PP
Return the string representing the email addresses of the partners to
whom a request has been sent
.PP
\fI\s-1TO_JSON\s0\fR
.IX Subsection "TO_JSON"
.PP
.Vb 1
\&    $json = $illrequest\->TO_JSON
.Ve
.PP
Overloaded \fI\s-1TO_JSON\s0\fR method that takes care of inserting calculated values
into the unblessed representation of the object.
.PP
\&\s-1TODO:\s0 This method does nothing and is not called anywhere. However, bug 74325
touches it, so keeping this for now until both this and bug 74325 are merged,
at which point we can sort it out and remove it completely
.SS "Internal methods"
.IX Subsection "Internal methods"
\fIto_api_mapping\fR
.IX Subsection "to_api_mapping"
.PP
\fIstrings_map\fR
.IX Subsection "strings_map"
.PP
.Vb 1
\&    my $strings = $self\->string_map({ [ public => 0|1 ] });
.Ve
.PP
Returns a map of column name to string representations. Extra information
is returned depending on the column characteristics as shown below.
.PP
Accepts a param hashref where the \fIpublic\fR key denotes whether we want the public
or staff client strings.
.PP
Example:
.PP
.Vb 12
\&    {
\&        status => {
\&            backend => \*(AqbackendName\*(Aq,
\&            str     => \*(AqStatus description\*(Aq,
\&            type    => \*(Aqill_status\*(Aq,
\&        },
\&        status_alias => {
\&            category => \*(AqILL_STATUS_ALIAS,
\&            str      => $value, # the AV description, depending on $params\->{public}
\&            type     => \*(Aqav\*(Aq,
\&        }
\&    }
.Ve
.PP
\fI_type\fR
.IX Subsection "_type"
.SH "AUTHOR"
.IX Header "AUTHOR"
Alex Sassmannshausen <alex.sassmannshausen@ptfs\-europe.com>
Andrew Isherwood <andrew.isherwood@ptfs\-europe.com>
