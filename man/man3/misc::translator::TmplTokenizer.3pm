.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "misc::translator::TmplTokenizer 3pm"
.TH misc::translator::TmplTokenizer 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TmplTokenizer.pm \- Simple\-minded wrapper class for TTParser
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A wrapper for the functionality found in TTParser to allow an easier transition to Template Toolkit
.PP
In addition to the basic scanning, this class will also perform
the following:
.IP "\-" 4
Emulation of c\-format strings (see below)
.IP "\-" 4
Display of warnings for certain things that affects either the
ability of this class to yield correct output, or things that
are known to cause the original template to cause trouble.
.IP "\-" 4
Automatic correction of some of the things warned about
(e.g., \s-1SGML\s0 \*(L"closed start tag\*(R" notation).
.SS "c\-format strings emulation"
.IX Subsection "c-format strings emulation"
Because English word order is not universal, a simple extraction
of translatable strings may yield some strings like \*(L"Accounts for\*(R"
or ambiguous strings like \*(L"in\*(R". This makes the resulting strings
difficult to translate, but does not affect all languages alike.
For example, Chinese (with a somewhat different word order) would
be hit harder, but French would be relatively unaffected.
.PP
To overcome this problem, the scanner can be configured to detect
patterns with <\s-1TMPL_VAR\s0> directives (as well as certain \s-1HTML\s0 tags),
and try to construct a larger pattern that will appear in the \s-1PO\s0
file as c\-format strings with \f(CW%s\fR placeholders. This additional
step allows the translator to deal with cases where word order
is different (replacing \f(CW%s\fR with \f(CW%1\fR$s, \f(CW%2\fR$s, etc.), or when certain
words will require certain inflectional suffixes in sentences.
.PP
Because this is an incompatible change, this mode must be explicitly
turned on using the \fBset_allow_cformat\fR\|(1) method call.
.SS "The flag characters"
.IX Subsection "The flag characters"
The character % is followed by zero or more of the following flags:
.IP "#" 4
The value comes from \s-1HTML\s0 <\s-1INPUT\s0> elements.
This abuse of the flag character is somewhat reasonable,
since \s-1TMPL_VAR\s0 and \s-1INPUT\s0 are both variables, but of different kinds.
.SS "The field width and precision"
.IX Subsection "The field width and precision"
An optional 0.0 can be specified for \f(CW%s\fR to specify
that the <\s-1TMPL_VAR\s0> should be suppressed.
.SS "The conversion specifier"
.IX Subsection "The conversion specifier"
.IP "p" 4
.IX Item "p"
Specifies any input field that is neither text nor hidden
(which currently mean radio buttons).
The p conversion specifier is chosen because this does not
evoke any certain sensible data type.
.IP "S" 4
.IX Item "S"
Specifies a text input field (<\s-1INPUT\s0 TYPE=TEXT>).
This use of the S conversion specifier is somewhat reasonable,
since text input fields contain values of undeterminable type,
which can be treated as strings.
.IP "s" 4
.IX Item "s"
Specifies a <\s-1TMPL_VAR\s0>.
This use of the o conversion specifier is somewhat reasonable,
since <\s-1TMPL_VAR\s0> denotes values of undeterminable type, which
can be treated as strings.
.SH "BUGS"
.IX Header "BUGS"
There is no code to save the tag name anywhere in the scanned token.
.PP
The use of <A\fIi\fR> to stand for the \fIi\fRth anchor
is not very well thought out.
Some abuse of c\-format specifies might have been more appropriate.
.SH "HISTORY"
.IX Header "HISTORY"
This tokenizer is mostly based
on Ambrose's hideous Perl script known as subst.pl.
