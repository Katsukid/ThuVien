.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "C4::Acquisition 3pm"
.TH C4::Acquisition 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::Acquisition \- Koha functions for dealing with orders and acquisitions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use C4::Acquisition;
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The functions in this module deal with acquisitions, managing book
orders, basket and parcels.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "\s-1FUNCTIONS ABOUT BASKETS\s0"
.IX Subsection "FUNCTIONS ABOUT BASKETS"
\fIGetBasket\fR
.IX Subsection "GetBasket"
.PP
.Vb 1
\&  $aqbasket = &GetBasket($basketnumber);
.Ve
.PP
get all basket informations in aqbasket for a given basket
.PP
\&\fBreturns:\fR informations for a given basket returned as a hashref.
.PP
\fINewBasket\fR
.IX Subsection "NewBasket"
.PP
.Vb 2
\&  $basket = &NewBasket( $booksellerid, $authorizedby, $basketname,
\&      $basketnote, $basketbooksellernote, $basketcontractnumber, $deliveryplace, $billingplace, $is_standing, $create_items );
.Ve
.PP
Create a new basket in aqbasket table
.ie n .IP "$booksellerid is a foreign key in the aqbasket table" 4
.el .IP "\f(CW$booksellerid\fR is a foreign key in the aqbasket table" 4
.IX Item "$booksellerid is a foreign key in the aqbasket table"
.PD 0
.ie n .IP "$authorizedby is the username of who created the basket" 4
.el .IP "\f(CW$authorizedby\fR is the username of who created the basket" 4
.IX Item "$authorizedby is the username of who created the basket"
.PD
.PP
The other parameters are optional, see ModBasketHeader for more info on them.
.PP
\fIReopenBasket\fR
.IX Subsection "ReopenBasket"
.PP
.Vb 1
\&  &ReopenBasket($basketno);
.Ve
.PP
reopen a basket
.PP
\fIGetBasketAsCSV\fR
.IX Subsection "GetBasketAsCSV"
.PP
.Vb 1
\&  &GetBasketAsCSV($basketno);
.Ve
.PP
Export a basket as \s-1CSV\s0
.PP
\&\f(CW$cgi\fR parameter is needed for column name translation
.PP
\fIGetBasketGroupAsCSV\fR
.IX Subsection "GetBasketGroupAsCSV"
.PP
.Vb 1
\&  &GetBasketGroupAsCSV($basketgroupid);
.Ve
.PP
Export a basket group as \s-1CSV\s0
.PP
\&\f(CW$cgi\fR parameter is needed for column name translation
.PP
\fICloseBasketgroup\fR
.IX Subsection "CloseBasketgroup"
.PP
.Vb 1
\&  &CloseBasketgroup($basketgroupno);
.Ve
.PP
close a basketgroup
.PP
\fIReOpenBaskergroup($basketgroupno)\fR
.IX Subsection "ReOpenBaskergroup($basketgroupno)"
.PP
.Vb 1
\&  &ReOpenBaskergroup($basketgroupno);
.Ve
.PP
reopen a basketgroup
.PP
\fIModBasket\fR
.IX Subsection "ModBasket"
.PP
.Vb 1
\&  &ModBasket($basketinfo);
.Ve
.PP
Modifies a basket, using a hashref \f(CW$basketinfo\fR for the relevant information, only \f(CW$basketinfo\fR\->{'basketno'} is required.
.ie n .IP "$basketno is the primary key of the basket in the aqbasket table." 4
.el .IP "\f(CW$basketno\fR is the primary key of the basket in the aqbasket table." 4
.IX Item "$basketno is the primary key of the basket in the aqbasket table."
.PP
\fIModBasketHeader\fR
.IX Subsection "ModBasketHeader"
.PP
.Vb 1
\&  &ModBasketHeader($basketno, $basketname, $note, $booksellernote, $contractnumber, $booksellerid);
.Ve
.PP
Modifies a basket's header.
.ie n .IP "$basketno is the ""basketno"" field in the ""aqbasket"" table;" 4
.el .IP "\f(CW$basketno\fR is the ``basketno'' field in the ``aqbasket'' table;" 4
.IX Item "$basketno is the basketno field in the aqbasket table;"
.PD 0
.ie n .IP "$basketname is the ""basketname"" field in the ""aqbasket"" table;" 4
.el .IP "\f(CW$basketname\fR is the ``basketname'' field in the ``aqbasket'' table;" 4
.IX Item "$basketname is the basketname field in the aqbasket table;"
.ie n .IP "$note is the ""note"" field in the ""aqbasket"" table;" 4
.el .IP "\f(CW$note\fR is the ``note'' field in the ``aqbasket'' table;" 4
.IX Item "$note is the note field in the aqbasket table;"
.ie n .IP "$booksellernote is the ""booksellernote"" field in the ""aqbasket"" table;" 4
.el .IP "\f(CW$booksellernote\fR is the ``booksellernote'' field in the ``aqbasket'' table;" 4
.IX Item "$booksellernote is the booksellernote field in the aqbasket table;"
.ie n .IP "$contractnumber is the ""contractnumber"" (foreign) key in the ""aqbasket"" table." 4
.el .IP "\f(CW$contractnumber\fR is the ``contractnumber'' (foreign) key in the ``aqbasket'' table." 4
.IX Item "$contractnumber is the contractnumber (foreign) key in the aqbasket table."
.ie n .IP "$booksellerid is the id (foreign) key in the ""aqbooksellers"" table for the vendor." 4
.el .IP "\f(CW$booksellerid\fR is the id (foreign) key in the ``aqbooksellers'' table for the vendor." 4
.IX Item "$booksellerid is the id (foreign) key in the aqbooksellers table for the vendor."
.ie n .IP "$deliveryplace is the ""deliveryplace"" field in the aqbasket table." 4
.el .IP "\f(CW$deliveryplace\fR is the ``deliveryplace'' field in the aqbasket table." 4
.IX Item "$deliveryplace is the deliveryplace field in the aqbasket table."
.ie n .IP "$billingplace is the ""billingplace"" field in the aqbasket table." 4
.el .IP "\f(CW$billingplace\fR is the ``billingplace'' field in the aqbasket table." 4
.IX Item "$billingplace is the billingplace field in the aqbasket table."
.ie n .IP "$is_standing is the ""is_standing"" field in the aqbasket table." 4
.el .IP "\f(CW$is_standing\fR is the ``is_standing'' field in the aqbasket table." 4
.IX Item "$is_standing is the is_standing field in the aqbasket table."
.ie n .IP "$create_items should be set to 'ordering', 'receiving' or 'cataloguing' (or undef, in which case the AcqCreateItem syspref takes precedence)." 4
.el .IP "\f(CW$create_items\fR should be set to 'ordering', 'receiving' or 'cataloguing' (or undef, in which case the AcqCreateItem syspref takes precedence)." 4
.IX Item "$create_items should be set to 'ordering', 'receiving' or 'cataloguing' (or undef, in which case the AcqCreateItem syspref takes precedence)."
.PD
.PP
\fIGetBasketsByBookseller\fR
.IX Subsection "GetBasketsByBookseller"
.PP
.Vb 1
\&  @results = &GetBasketsByBookseller($booksellerid, $extra);
.Ve
.PP
Returns a list of hashes of all the baskets that belong to bookseller 'booksellerid'.
.ie n .IP "$booksellerid is the 'id' field of the bookseller in the aqbooksellers table" 4
.el .IP "\f(CW$booksellerid\fR is the 'id' field of the bookseller in the aqbooksellers table" 4
.IX Item "$booksellerid is the 'id' field of the bookseller in the aqbooksellers table"
.PD 0
.ie n .IP "$extra is the extra sql parameters, can be" 4
.el .IP "\f(CW$extra\fR is the extra sql parameters, can be" 4
.IX Item "$extra is the extra sql parameters, can be"
.PD
.Vb 4
\& $extra\->{groupby}: group baskets by column
\&    ex. $extra\->{groupby} = aqbasket.basketgroupid
\& $extra\->{orderby}: order baskets by column
\& $extra\->{limit}: limit number of results (can be helpful for pagination)
.Ve
.PP
\fIGetBasketsInfosByBookseller\fR
.IX Subsection "GetBasketsInfosByBookseller"
.PP
.Vb 1
\&    my $baskets = GetBasketsInfosByBookseller($supplierid, $allbaskets);
.Ve
.PP
The optional second parameter allbaskets is a boolean allowing you to
select all baskets from the supplier; by default only active baskets (open or 
closed but still something to receive) are returned.
.PP
Returns in a arrayref of hashref all about booksellers baskets, plus:
    total_biblios: Number of distinct biblios in basket
    total_items: Number of items in basket
    expected_items: Number of non-received items in basket
.PP
\fIGetBasketUsers\fR
.IX Subsection "GetBasketUsers"
.PP
.Vb 1
\&    $basketusers_ids = &GetBasketUsers($basketno);
.Ve
.PP
Returns a list of all borrowernumbers that are in basket users list
.PP
\fIModBasketUsers\fR
.IX Subsection "ModBasketUsers"
.PP
.Vb 2
\&    my @basketusers_ids = (1, 2, 3);
\&    &ModBasketUsers($basketno, @basketusers_ids);
.Ve
.PP
Delete all users from basket users list, and add users in \f(CW@basketusers_ids\fR
to this users list.
.PP
\fICanUserManageBasket\fR
.IX Subsection "CanUserManageBasket"
.PP
.Vb 2
\&    my $bool = CanUserManageBasket($borrower, $basket[, $userflags]);
\&    my $bool = CanUserManageBasket($borrowernumber, $basketno[, $userflags]);
.Ve
.PP
Check if a borrower can manage a basket, according to system preference
AcqViewBaskets, user permissions and basket properties (creator, users list,
branch).
.PP
First parameter can be either a borrowernumber or a hashref as returned by
Koha::Patron\->unblessed
.PP
Second parameter can be either a basketno or a hashref as returned by
C4::Acquisition::GetBasket.
.PP
The third parameter is optional. If given, it should be a hashref as returned
by C4::Auth::getuserflags. If not, getuserflags is called.
.PP
If user is authorised to manage basket, returns 1.
Otherwise returns 0.
.PP
\fIGetBasketsByBasketgroup\fR
.IX Subsection "GetBasketsByBasketgroup"
.PP
.Vb 1
\&  $baskets = &GetBasketsByBasketgroup($basketgroupid);
.Ve
.PP
Returns a reference to all baskets that belong to basketgroup \f(CW$basketgroupid\fR.
.PP
\fINewBasketgroup\fR
.IX Subsection "NewBasketgroup"
.PP
.Vb 1
\&  $basketgroupid = NewBasketgroup(\e%hashref);
.Ve
.PP
Adds a basketgroup to the aqbasketgroups table, and add the initial baskets to it.
.PP
\&\f(CW$hashref\fR\->{'booksellerid'} is the 'id' field of the bookseller in the aqbooksellers table,
.PP
\&\f(CW$hashref\fR\->{'name'} is the 'name' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'basketlist'} is a list reference of the 'id's of the baskets that belong to this group,
.PP
\&\f(CW$hashref\fR\->{'billingplace'} is the 'billingplace' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'deliveryplace'} is the 'deliveryplace' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'freedeliveryplace'} is the 'freedeliveryplace' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'deliverycomment'} is the 'deliverycomment' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'closed'} is the 'closed' field of the aqbasketgroups table, it is false if 0, true otherwise.
.PP
\fIModBasketgroup\fR
.IX Subsection "ModBasketgroup"
.PP
.Vb 1
\&  ModBasketgroup(\e%hashref);
.Ve
.PP
Modifies a basketgroup in the aqbasketgroups table, and add the baskets to it.
.PP
\&\f(CW$hashref\fR\->{'id'} is the 'id' field of the basketgroup in the aqbasketgroup table, this parameter is mandatory,
.PP
\&\f(CW$hashref\fR\->{'name'} is the 'name' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'basketlist'} is a list reference of the 'id's of the baskets that belong to this group,
.PP
\&\f(CW$hashref\fR\->{'billingplace'} is the 'billingplace' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'deliveryplace'} is the 'deliveryplace' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'freedeliveryplace'} is the 'freedeliveryplace' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'deliverycomment'} is the 'deliverycomment' field of the basketgroup in the aqbasketgroups table,
.PP
\&\f(CW$hashref\fR\->{'closed'} is the 'closed' field of the aqbasketgroups table, it is false if 0, true otherwise.
.PP
\fIDelBasketgroup\fR
.IX Subsection "DelBasketgroup"
.PP
.Vb 1
\&  DelBasketgroup($basketgroupid);
.Ve
.PP
Deletes a basketgroup in the aqbasketgroups table, and removes the reference to it from the baskets,
.ie n .IP "$basketgroupid is the 'id' field of the basket in the aqbasketgroup table" 4
.el .IP "\f(CW$basketgroupid\fR is the 'id' field of the basket in the aqbasketgroup table" 4
.IX Item "$basketgroupid is the 'id' field of the basket in the aqbasketgroup table"
.SS "\s-1FUNCTIONS ABOUT ORDERS\s0"
.IX Subsection "FUNCTIONS ABOUT ORDERS"
\fIGetBasketgroup\fR
.IX Subsection "GetBasketgroup"
.PP
.Vb 1
\&  $basketgroup = &GetBasketgroup($basketgroupid);
.Ve
.PP
Returns a reference to the hash containing all information about the basketgroup.
.PP
\fIGetBasketgroups\fR
.IX Subsection "GetBasketgroups"
.PP
.Vb 1
\&  $basketgroups = &GetBasketgroups($booksellerid);
.Ve
.PP
Returns a reference to the array of all the basketgroups of bookseller \f(CW$booksellerid\fR.
.SS "\s-1FUNCTIONS ABOUT ORDERS\s0"
.IX Subsection "FUNCTIONS ABOUT ORDERS"
\fIGetOrders\fR
.IX Subsection "GetOrders"
.PP
.Vb 1
\&  @orders = &GetOrders( $basketno, { orderby => \*(Aqbiblio.title\*(Aq, cancelled => 0|1 } );
.Ve
.PP
Looks up the pending (non-cancelled) orders with the given basket
number.
.PP
If cancelled is set, only cancelled orders will be returned.
.PP
\fIGetOrdersByBiblionumber\fR
.IX Subsection "GetOrdersByBiblionumber"
.PP
.Vb 1
\&  @orders = &GetOrdersByBiblionumber($biblionumber);
.Ve
.PP
Looks up the orders with linked to a specific \f(CW$biblionumber\fR, including
cancelled orders and received orders.
.PP
return :
\&\f(CW@orders\fR is an array of references-to-hash, whose keys are the
fields from the aqorders, biblio, and biblioitems tables in the Koha database.
.PP
\fIGetOrder\fR
.IX Subsection "GetOrder"
.PP
.Vb 1
\&  $order = &GetOrder($ordernumber);
.Ve
.PP
Looks up an order by order number.
.PP
Returns a reference-to-hash describing the order. The keys of
\&\f(CW$order\fR are fields from the biblio, biblioitems, aqorders tables of the Koha database.
.PP
\fIModOrder\fR
.IX Subsection "ModOrder"
.PP
.Vb 1
\&  &ModOrder(\e%hashref);
.Ve
.PP
Modifies an existing order. Updates the order with order number
\&\f(CW$hashref\fR\->{'ordernumber'} and biblionumber \f(CW$hashref\fR\->{'biblionumber'}. All 
other keys of the hash update the fields with the same name in the aqorders 
table of the Koha database.
.PP
\fIModItemOrder\fR
.IX Subsection "ModItemOrder"
.PP
.Vb 1
\&    ModItemOrder($itemnumber, $ordernumber);
.Ve
.PP
Modifies the ordernumber of an item in aqorders_items.
.PP
\fIModReceiveOrder\fR
.IX Subsection "ModReceiveOrder"
.PP
.Vb 12
\&    my ( $date_received, $new_ordernumber ) = ModReceiveOrder(
\&        {
\&            biblionumber         => $biblionumber,
\&            order                => $order,
\&            quantityreceived     => $quantityreceived,
\&            user                 => $user,
\&            invoice              => $invoice,
\&            budget_id            => $budget_id,
\&            datereceived         => $datereceived,
\&            received_itemnumbers => \e@received_itemnumbers,
\&        }
\&    );
.Ve
.PP
Updates an order, to reflect the fact that it was received, at least
in part.
.PP
If a partial order is received, splits the order into two.
.PP
Updates the order with biblionumber \f(CW$biblionumber\fR and ordernumber
\&\f(CW\*(C`$order\-\*(C'\fR{ordernumber}>.
.PP
\fICancelReceipt\fR
.IX Subsection "CancelReceipt"
.PP
.Vb 1
\&    my $parent_ordernumber = CancelReceipt($ordernumber);
\&
\&    Cancel an order line receipt and update the parent order line, as if no
\&    receipt was made.
\&    If items are created at receipt (AcqCreateItem = receiving) then delete
\&    these items.
.Ve
.PP
\fISearchOrders\fR
.IX Subsection "SearchOrders"
.PP
\&\f(CW@results\fR = &SearchOrders({
    ordernumber => \f(CW$ordernumber\fR,
    search => \f(CW$search\fR,
    ean => \f(CW$ean\fR,
    booksellerid => \f(CW$booksellerid\fR,
    basketno => \f(CW$basketno\fR,
    basketname => \f(CW$basketname\fR,
    basketgroupname => \f(CW$basketgroupname\fR,
    owner => \f(CW$owner\fR,
    pending => \f(CW$pending\fR
    ordered => \f(CW$ordered\fR
    biblionumber => \f(CW$biblionumber\fR,
    budget_id => \f(CW$budget_id\fR
});
.PP
Searches for orders filtered by criteria.
.PP
\&\f(CW$ordernumber\fR Finds matching orders or transferred orders by ordernumber.
\&\f(CW$search\fR Finds orders matching %$search% in title, author, or isbn.
\&\f(CW$owner\fR Finds order for the logged in user.
\&\f(CW$pending\fR Finds pending orders. Ignores completed and cancelled orders.
\&\f(CW$ordered\fR Finds orders to receive only (status 'ordered' or 'partial').
.PP
\&\f(CW@results\fR is an array of references-to-hash with the keys are fields
from aqorders, biblio, biblioitems and aqbasket tables.
.PP
\fITransferOrder\fR
.IX Subsection "TransferOrder"
.PP
.Vb 1
\&    my $newordernumber = TransferOrder($ordernumber, $basketno);
.Ve
.PP
Transfer an order line to a basket.
Mark \f(CW$ordernumber\fR as cancelled with an internal note 'Cancelled and transferred
to \s-1BOOKSELLER\s0 on \s-1DATE\s0' and create new order with internal note
\&'Transferred from \s-1BOOKSELLER\s0 on \s-1DATE\s0'.
Move all attached items to the new order.
Received orders cannot be transferred.
Return the ordernumber of created order.
.PP
\fIget_rounding_sql\fR
.IX Subsection "get_rounding_sql"
.PP
.Vb 1
\&    $rounding_sql = get_rounding_sql($column_name);
.Ve
.PP
returns the correct \s-1SQL\s0 routine based on OrderPriceRounding system preference.
.PP
\fIget_rounded_price\fR
.IX Subsection "get_rounded_price"
.PP
.Vb 1
\&    $rounded_price = get_rounded_price( $price );
.Ve
.PP
returns a price rounded as specified in OrderPriceRounding system preference.
.SS "\s-1FUNCTIONS ABOUT PARCELS\s0"
.IX Subsection "FUNCTIONS ABOUT PARCELS"
\fIGetParcels\fR
.IX Subsection "GetParcels"
.PP
.Vb 1
\&  $results = &GetParcels($bookseller, $order, $code, $datefrom, $dateto);
.Ve
.PP
get a lists of parcels.
.PP
* Input arg :
.ie n .IP "$bookseller is the bookseller this function has to get parcels." 4
.el .IP "\f(CW$bookseller\fR is the bookseller this function has to get parcels." 4
.IX Item "$bookseller is the bookseller this function has to get parcels."
.PD 0
.ie n .IP "$order To know on what criteria the results list has to be ordered." 4
.el .IP "\f(CW$order\fR To know on what criteria the results list has to be ordered." 4
.IX Item "$order To know on what criteria the results list has to be ordered."
.ie n .IP "$code is the booksellerinvoicenumber." 4
.el .IP "\f(CW$code\fR is the booksellerinvoicenumber." 4
.IX Item "$code is the booksellerinvoicenumber."
.ie n .IP "$datefrom & $dateto to know on what date this function has to filter its search." 4
.el .IP "\f(CW$datefrom\fR & \f(CW$dateto\fR to know on what date this function has to filter its search." 4
.IX Item "$datefrom & $dateto to know on what date this function has to filter its search."
.PD
.PP
* return:
a pointer on a hash list containing parcel informations as such :
.IP "Creation date" 4
.IX Item "Creation date"
.PD 0
.IP "Last operation" 4
.IX Item "Last operation"
.IP "Number of biblio" 4
.IX Item "Number of biblio"
.IP "Number of items" 4
.IX Item "Number of items"
.PD
.PP
\fIGetHistory\fR
.IX Subsection "GetHistory"
.PP
.Vb 1
\&  \e@order_loop = GetHistory( %params );
.Ve
.PP
Retreives some acquisition history information
.PP
params:  
  title
  author
  name
  isbn
  ean
  from_placed_on
  to_placed_on
  basket                  \- search both basket name and number
  booksellerinvoicenumber 
  basketgroupname
  budget
  orderstatus (note that orderstatus '' will retrieve orders
               of any status except cancelled)
  is_standing
  managing_library
  biblionumber
  get_canceled_order (if set to a true value, cancelled orders will
                      be included)
.PP
returns:
    \f(CW$order_loop\fR is a list of hashrefs that each look like this:
            {
                'author'           => 'Twain, Mark',
                'basketno'         => '1',
                'biblionumber'     => '215',
                'count'            => 1,
                'creationdate'     => '\s-1dd/mm/yyyy\s0',
                'datereceived'     => undef,
                'ecost'            => '1.00',
                'id'               => '1',
                'invoicenumber'    => undef,
                'name'             => '',
                'ordernumber'      => '1',
                'quantity'         => 1,
                'quantityreceived' => undef,
                'title'            => 'The Adventures of Huckleberry Finn',
                'managing_library' => '\s-1CPL\s0'
                'is_standing'      => '1'
            }
.SS "GetRecentAcqui"
.IX Subsection "GetRecentAcqui"
.Vb 1
\&  $results = GetRecentAcqui($days);
.Ve
.PP
\&\f(CW$results\fR is a ref to a table which contains hashref
.PP
\fIAddClaim\fR
.IX Subsection "AddClaim"
.PP
.Vb 1
\&  &AddClaim($ordernumber);
.Ve
.PP
Add a claim for an order
.PP
\fIGetInvoices\fR
.IX Subsection "GetInvoices"
.PP
.Vb 10
\&    my @invoices = GetInvoices(
\&        invoicenumber => $invoicenumber,
\&        supplierid => $supplierid,
\&        suppliername => $suppliername,
\&        shipmentdatefrom => $shipmentdatefrom, # ISO format
\&        shipmentdateto => $shipmentdateto, # ISO format
\&        billingdatefrom => $billingdatefrom, # ISO format
\&        billingdateto => $billingdateto, # ISO format
\&        isbneanissn => $isbn_or_ean_or_issn,
\&        title => $title,
\&        author => $author,
\&        publisher => $publisher,
\&        publicationyear => $publicationyear,
\&        branchcode => $branchcode,
\&        order_by => $order_by
\&    );
.Ve
.PP
Return a list of invoices that match all given criteria.
.PP
\&\f(CW$order_by\fR is \*(L"column_name (asc|desc)\*(R", where column_name is any of
\&'invoicenumber', 'booksellerid', 'shipmentdate', 'billingdate', 'closedate',
\&'shipmentcost', 'shipmentcost_budgetid'.
.PP
asc is the default if omitted
.PP
\fIGetInvoice\fR
.IX Subsection "GetInvoice"
.PP
.Vb 1
\&    my $invoice = GetInvoice($invoiceid);
.Ve
.PP
Get informations about invoice with given \f(CW$invoiceid\fR
.PP
Return a hash filled with aqinvoices.* fields
.PP
\fIGetInvoiceDetails\fR
.IX Subsection "GetInvoiceDetails"
.PP
.Vb 1
\&    my $invoice = GetInvoiceDetails($invoiceid)
.Ve
.PP
Return informations about an invoice + the list of related order lines
.PP
Orders informations are in \f(CW$invoice\fR\->{orders} (array ref)
.PP
\fIAddInvoice\fR
.IX Subsection "AddInvoice"
.PP
.Vb 9
\&    my $invoiceid = AddInvoice(
\&        invoicenumber => $invoicenumber,
\&        booksellerid => $booksellerid,
\&        shipmentdate => $shipmentdate,
\&        billingdate => $billingdate,
\&        closedate => $closedate,
\&        shipmentcost => $shipmentcost,
\&        shipmentcost_budgetid => $shipmentcost_budgetid
\&    );
.Ve
.PP
Create a new invoice and return its id or undef if it fails.
.PP
\fIModInvoice\fR
.IX Subsection "ModInvoice"
.PP
.Vb 10
\&    ModInvoice(
\&        invoiceid => $invoiceid,    # Mandatory
\&        invoicenumber => $invoicenumber,
\&        booksellerid => $booksellerid,
\&        shipmentdate => $shipmentdate,
\&        billingdate => $billingdate,
\&        closedate => $closedate,
\&        shipmentcost => $shipmentcost,
\&        shipmentcost_budgetid => $shipmentcost_budgetid
\&    );
.Ve
.PP
Modify an invoice, invoiceid is mandatory.
.PP
Return undef if it fails.
.PP
\fICloseInvoice\fR
.IX Subsection "CloseInvoice"
.PP
.Vb 1
\&    CloseInvoice($invoiceid);
.Ve
.PP
Close an invoice.
.PP
Equivalent to ModInvoice(invoiceid => \f(CW$invoiceid\fR, closedate => undef);
.PP
\fIReopenInvoice\fR
.IX Subsection "ReopenInvoice"
.PP
.Vb 1
\&    ReopenInvoice($invoiceid);
.Ve
.PP
Reopen an invoice
.PP
Equivalent to ModInvoice(invoiceid => \f(CW$invoiceid\fR, closedate => \f(CW$closedate\fR );
.PP
\fIDelInvoice\fR
.IX Subsection "DelInvoice"
.PP
.Vb 1
\&    DelInvoice($invoiceid);
.Ve
.PP
Delete an invoice if there are no items attached to it.
.PP
\fIMergeInvoices\fR
.IX Subsection "MergeInvoices"
.PP
.Vb 1
\&    MergeInvoices($invoiceid, \e@sourceids);
.Ve
.PP
Merge the invoices identified by the IDs in \e@sourceids into
the invoice identified by \f(CW$invoiceid\fR.
.PP
\fIGetBiblioCountByBasketno\fR
.IX Subsection "GetBiblioCountByBasketno"
.PP
\&\f(CW$biblio_count\fR = &GetBiblioCountByBasketno($basketno);
.PP
Looks up the biblio's count that has basketno value \f(CW$basketno\fR
.PP
Returns a quantity
.PP
\fIGetOrderUsers\fR
.IX Subsection "GetOrderUsers"
.PP
.Vb 1
\&    $order_users_ids = &GetOrderUsers($ordernumber);
.Ve
.PP
Returns a list of all borrowernumbers that are in order users list
.PP
\fIModOrderUsers\fR
.IX Subsection "ModOrderUsers"
.PP
.Vb 2
\&    my @order_users_ids = (1, 2, 3);
\&    &ModOrderUsers($ordernumber, @basketusers_ids);
.Ve
.PP
Delete all users from order users list, and add users in \f(CW@order_users_ids\fR
to this users list.
.PP
\fIFillWithDefaultValues\fR
.IX Subsection "FillWithDefaultValues"
.PP
FillWithDefaultValues( \f(CW$marc_record\fR, \f(CW$params\fR );
.PP
This will update the record with default value defined in the \s-1ACQ\s0 framework.
For all existing fields, if a default value exists and there are no subfield, it will be created.
If the field does not exist, it will be created too.
.PP
If the parameter only_mandatory => 1 is passed via \f(CW$params\fR, only the mandatory
defaults are being applied to the record.
.SH "AUTHOR"
.IX Header "AUTHOR"
Koha Development Team <http://koha\-community.org/>
