.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Koha::SearchEngine::Elasticsearch::QueryBuilder 3pm"
.TH Koha::SearchEngine::Elasticsearch::QueryBuilder 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::SearchEngine::Elasticsearch::QueryBuilder \- constructs elasticsearch
query objects from user\-supplied queries
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This provides the functions that take a user-supplied search query, and
provides something that can be given to elasticsearch to get answers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    use Koha::SearchEngine::Elasticsearch::QueryBuilder;
\&    $builder = Koha::SearchEngine::Elasticsearch\->new({ index => $index });
\&    my $simple_query = $builder\->build_query("hello");
\&    # This is currently undocumented because the original code is undocumented
\&    my $adv_query = $builder\->build_advanced_query($indexes, $operands, $operators);
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "get_index_field_convert"
.IX Subsection "get_index_field_convert"
.Vb 1
\&    my @index_params = Koha::SearchEngine::Elasticsearch::QueryBuilder\->get_index_field_convert();
.Ve
.PP
Converts zebra-style search index notation into elasticsearch-style.
.PP
\&\f(CW@indexes\fR is an array of index names, as presented to build_query_compat,
and it returns something that can be sent to build_query.
.PP
\&\fB\s-1TODO\s0\fR: this will pull from the elasticsearch mappings table to figure out
types.
.SS "build_query"
.IX Subsection "build_query"
.Vb 1
\&    my $simple_query = $builder\->build_query("hello", %options)
.Ve
.PP
This will build a query that can be issued to elasticsearch from the provided
string input. This expects a lucene style search form (see
<http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query\-dsl\-query\-string\-query.html#query\-string\-syntax>
for details.)
.PP
It'll make an attempt to respect the various query options.
.PP
Additional options can be provided with the \f(CW%options\fR hash.
.IP "sort" 4
.IX Item "sort"
This should be an arrayref of hashrefs, each containing a \f(CW\*(C`field\*(C'\fR and an
\&\f(CW\*(C`direction\*(C'\fR (optional, defaults to \f(CW\*(C`asc\*(C'\fR.) The results will be sorted
according to these values. Valid values for \f(CW\*(C`direction\*(C'\fR are 'asc' and 'desc'.
.SS "build_query_compat"
.IX Subsection "build_query_compat"
.Vb 7
\&    my (
\&        $error,             $query, $simple_query, $query_cgi,
\&        $query_desc,        $limit, $limit_cgi,    $limit_desc,
\&        $stopwords_removed, $query_type
\&      )
\&      = $builder\->build_query_compat( \e@operators, \e@operands, \e@indexes,
\&        \e@limits, \e@sort_by, $scan, $lang, $params );
.Ve
.PP
This handles a search using the same api as C4::Search::buildQuery does.
.PP
A very simple query will go in with \f(CW$operands\fR set to ['query'], and
\&\f(CW$sort_by\fR set to ['pubdate_dsc']. This simple case will return with
\&\f(CW$query\fR set to something that can perform the search, \f(CW$simple_query\fR
set to just the search term, \f(CW$query_cgi\fR set to something that can
reproduce this search, and \f(CW$query_desc\fR set to something else.
.SS "build_authorities_query"
.IX Subsection "build_authorities_query"
.Vb 1
\&    my $query = $builder\->build_authorities_query(\e%search);
.Ve
.PP
This takes a nice description of an authority search and turns it into a black-box
query that can then be passed to the appropriate searcher.
.PP
The search description is a hashref that looks something like:
.PP
.Vb 10
\&    {
\&        searches => [
\&            {
\&                where    => \*(AqHeading\*(Aq,    # search the main entry
\&                operator => \*(Aqexact\*(Aq,        # require an exact match
\&                value    => \*(Aqfrogs\*(Aq,        # the search string
\&            },
\&            {
\&                where    => \*(Aq\*(Aq,             # search all entries
\&                operator => \*(Aq\*(Aq,             # default keyword, right truncation
\&                value    => \*(Aqpond\*(Aq,
\&            },
\&        ],
\&        sort => {
\&            field => \*(AqHeading\*(Aq,
\&            order => \*(Aqdesc\*(Aq,
\&        },
\&        authtypecode => \*(AqTOPIC_TERM\*(Aq,
\&    }
.Ve
.SS "build_authorities_query_compat"
.IX Subsection "build_authorities_query_compat"
.Vb 3
\&    my ($query) =
\&      $builder\->build_authorities_query_compat( \e@marclist, \e@and_or,
\&        \e@excluding, \e@operator, \e@value, $authtypecode, $orderby );
.Ve
.PP
This builds a query for searching for authorities, in the style of
C4::AuthoritiesMarc::SearchAuthorities.
.PP
Arguments:
.IP "marclist" 4
.IX Item "marclist"
An arrayref containing where the particular term should be searched for.
Options are: mainmainentry, mainentry, match, match-heading, see-from, and
thesaurus. If left blank, any field is used.
.IP "and_or" 4
.IX Item "and_or"
Totally ignored. It is never used in C4::AuthoritiesMarc::SearchAuthorities.
.IP "excluding" 4
.IX Item "excluding"
Also ignored.
.IP "operator" 4
.IX Item "operator"
What form of search to do. Options are: is (phrase, no truncation, whole field
must match), = (number exact match), exact (phrase, no truncation, whole field
must match). If left blank, then word list, right truncated, anywhere is used.
.IP "value" 4
.IX Item "value"
The actual user-provided string value to search for.
.IP "authtypecode" 4
.IX Item "authtypecode"
The authority type code to search within. If blank, then all will be searched.
.IP "orderby" 4
.IX Item "orderby"
The order to sort the results by. Options are Relevance, HeadingAsc,
HeadingDsc, AuthidAsc, AuthidDsc.
.PP
marclist, operator, and value must be the same length, and the values at
index /i/ all relate to each other.
.PP
This returns a query, which is a black box object that can be passed to the
appropriate search object.
.SS "_build_scan_query"
.IX Subsection "_build_scan_query"
.Vb 1
\&    my ($query, $query_str) = $builder\->_build_scan_query(\e@operands, \e@indexes)
.Ve
.PP
This will build an aggregation scan query that can be issued to elasticsearch from
the provided string input.
.SS "_create_regex_filter"
.IX Subsection "_create_regex_filter"
.Vb 1
\&    my $filter = $builder\->_create_regex_filter(\*(Aqterm\*(Aq)
.Ve
.PP
This will create a regex filter that can be used with an aggregation query.
.SS "_convert_sort_fields"
.IX Subsection "_convert_sort_fields"
.Vb 1
\&    my @sort_params = _convert_sort_fields(@sort_by)
.Ve
.PP
Converts the zebra-style sort index information into elasticsearch-style.
.PP
\&\f(CW@sort_by\fR is the same as presented to build_query_compat, and it returns
something that can be sent to build_query.
.SS "_convert_index_strings"
.IX Subsection "_convert_index_strings"
.Vb 1
\&    my @searches = $self\->_convert_index_strings(@searches);
.Ve
.PP
Similar to _convert_index_fields, this takes strings of the form
\&\fBfield:search term\fR and rewrites the field from zebra-style to
elasticsearch-style. Anything it doesn't understand is returned verbatim.
.SS "_convert_index_strings_freeform"
.IX Subsection "_convert_index_strings_freeform"
.Vb 1
\&    my $search = $self\->_convert_index_strings_freeform($search);
.Ve
.PP
This is similar to _convert_index_strings, however it'll search out the
things to change within the string. So it can handle strings such as
\&\f(CW\*(C`(su:foo) AND (su:bar)\*(C'\fR, converting the \f(CW\*(C`su\*(C'\fR appropriately.
.PP
If there is something of the form \*(L"su,complete\-subfield\*(R" or something, the
second part is stripped off as we can't yet handle that. Making it work
will have to wait for a real query parser.
.SS "_modify_string_by_type"
.IX Subsection "_modify_string_by_type"
.Vb 1
\&    my $str = $self\->_modify_string_by_type(%index_field);
.Ve
.PP
If you have a search term (operand) and a type (phrase, right-truncated), this
will convert the string to have the function in lucene search terms, e.g.
wrapping quotes around it.
.SS "_join_queries"
.IX Subsection "_join_queries"
.Vb 1
\&    my $query_str = $self\->_join_queries(@query_parts);
.Ve
.PP
This takes a list of query parts, that might be search terms on their own, or
booleaned together, or specifying fields, or whatever, wraps them in
parentheses, and ANDs them all together. Suitable for feeding to the \s-1ES\s0
query string query.
.PP
Note: doesn't \s-1AND\s0 them together if they specify an index that starts with \*(L"mc\*(R"
as that was a special case in the original code for dealing with multiple
choice options (you can't search for something that has an itype of A and
and itype of B otherwise.)
.SS "_make_phrases"
.IX Subsection "_make_phrases"
.Vb 1
\&    my @phrased_queries = $self\->_make_phrases(@query_parts);
.Ve
.PP
This takes the supplied queries and forces them to be phrases by wrapping
quotes around them. It understands field prefixes, e.g. 'subject:' and puts
the quotes outside of them if they're there.
.SS "_create_query_string"
.IX Subsection "_create_query_string"
.Vb 1
\&    my @query_strings = $self\->_create_query_string(@queries);
.Ve
.PP
Given a list of hashrefs, it will turn them into a lucene-style query string.
The hash should contain field, type (both for the indexes), operator, and
operand.
.SS "clean_search_term"
.IX Subsection "clean_search_term"
.Vb 1
\&    my $term = $self\->clean_search_term($term);
.Ve
.PP
This cleans a search term by removing any funny characters that may upset
\&\s-1ES\s0 and give us an error. It also calls _convert_index_strings_freeform
to ensure those parts are correct.
.SS "_query_regex_escape_process"
.IX Subsection "_query_regex_escape_process"
.Vb 1
\&    my $query = $self\->_query_regex_escape_process($query);
.Ve
.PP
Processes query in accordance with current \*(L"QueryRegexEscapeOptions\*(R" system preference setting.
.SS "_fix_limit_special_cases"
.IX Subsection "_fix_limit_special_cases"
.Vb 1
\&    my $limits = $self\->_fix_limit_special_cases($limits);
.Ve
.PP
This converts any special cases that the limit specifications have into things
that are more readily processable by the rest of the code.
.PP
The argument should be an arrayref, and it'll return an arrayref.
.SS "_sort_field"
.IX Subsection "_sort_field"
.Vb 1
\&    my $field = $self\->_sort_field($field);
.Ve
.PP
Given a field name, this works out what the actual name of the field to sort
on should be. A '_\|_sort' suffix is added for fields with a sort version, and
for text fields either '.phrase' (for sortable versions) or '.raw' is appended
to avoid sorting on a tokenized value.
.SS "_truncate_terms"
.IX Subsection "_truncate_terms"
.Vb 1
\&    my $query = $self\->_truncate_terms($query);
.Ve
.PP
Given a string query this function appends '*' wildcard  to all terms except
operands and double quoted strings.
.SS "_split_query"
.IX Subsection "_split_query"
.Vb 1
\&    my @token = $self\->_split_query($query_str);
.Ve
.PP
Given a string query this function splits it to tokens taking into account
any field prefixes and quoted strings.
.ie n .SS "_search_fields my $weighted_fields = $self\->_search_fields({ is_opac => 0, weighted_fields => 1, subfield => 'raw' });"
.el .SS "_search_fields my \f(CW$weighted_fields\fP = \f(CW$self\fP\->_search_fields({ is_opac => 0, weighted_fields => 1, subfield => 'raw' });"
.IX Subsection "_search_fields my $weighted_fields = $self->_search_fields({ is_opac => 0, weighted_fields => 1, subfield => 'raw' });"
Generate a list of searchable fields to be used for Elasticsearch queries
applied to multiple fields.
.PP
Returns an arrayref of field names for either \s-1OPAC\s0 or staff interface, with
possible weights and subfield appended to each field name depending on the
options provided.
.ie n .IP "$params" 4
.el .IP "\f(CW$params\fR" 4
.IX Item "$params"
Hashref with options. The parameter \f(CW\*(C`is_opac\*(C'\fR indicates whether the searchable
fields for \s-1OPAC\s0 or staff interface should be retrieved. If \f(CW\*(C`weighted_fields\*(C'\fR is set
fields weights will be applied on returned fields. \f(CW\*(C`subfield\*(C'\fR can be used to
provide a subfield that will be appended to fields as "\f(CW\*(C`field_name\*(C'\fR.\f(CW\*(C`subfield\*(C'\fR".
