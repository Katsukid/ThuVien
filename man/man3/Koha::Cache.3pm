.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Koha::Cache 3pm"
.TH Koha::Cache 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::Cache \- Handling caching of html and Objects for Koha
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Koha::Cache;
\&  my $cache = Koha::Cache\->new({cache_type => $cache_type, %params});
\&
\&  # see also Koha::Caches\->get_instance;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Koha caching routines. This class provides two interfaces for cache access.
The first, traditional \s-1OO\s0 interface provides the following functions:
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "new"
.IX Subsection "new"
Create a new Koha::Cache object. This is required for all cache-related functionality.
.SS "is_cache_active"
.IX Subsection "is_cache_active"
Routine that checks whether or not a default caching method is active on this
object.
.SS "set_in_cache"
.IX Subsection "set_in_cache"
.Vb 1
\&    $cache\->set_in_cache($key, $value, [$options]);
.Ve
.PP
Save a value to the specified key in the cache. A hashref of options may be
specified.
.PP
The possible options are:
.IP "expiry" 4
.IX Item "expiry"
Expiry time of this cached entry in seconds.
.IP "cache" 4
.IX Item "cache"
The cache object to use if you want to provide your own. It should be an
instance of \f(CW\*(C`Cache::*\*(C'\fR and follow the same interface as Cache::Memcache.
.SS "get_from_cache"
.IX Subsection "get_from_cache"
.Vb 1
\&    my $value = $cache\->get_from_cache($key, [ $options ]);
.Ve
.PP
Retrieve the value stored under the specified key in the cache.
.PP
The possible options are:
.IP "unsafe" 4
.IX Item "unsafe"
If set, this will avoid performing a deep copy of the item. This
means that it won't be safe if something later modifies the result of the
function. It should be used with caution, and could save processing time
in some situations where is safe to use it. Make sure you know what you are doing!
.IP "cache" 4
.IX Item "cache"
The cache object to use if you want to provide your own. It should be an
instance of \f(CW\*(C`Cache::*\*(C'\fR and follow the same interface as Cache::Memcache.
.SS "clear_from_cache"
.IX Subsection "clear_from_cache"
.Vb 1
\&    $cache\->clear_from_cache($key);
.Ve
.PP
Remove the value identified by the specified key from the default cache.
.SS "flush_all"
.IX Subsection "flush_all"
.Vb 1
\&    $cache\->flush_all();
.Ve
.PP
Clear the entire default cache.
.SH "TIED INTERFACE"
.IX Header "TIED INTERFACE"
Koha::Cache also provides a tied interface which enables users to provide a
constructor closure and (after creation) treat cached data like normal reference
variables and rely on the cache Just Working and getting updated when it
expires, etc.
.PP
.Vb 10
\&    my $cache = Koha::Cache\->new();
\&    my $data = \*(Aqwhatever\*(Aq;
\&    my $scalar = Koha::Cache\->create_scalar(
\&        {
\&            \*(Aqkey\*(Aq         => \*(Aqwhatever\*(Aq,
\&            \*(Aqtimeout\*(Aq     => 2,
\&            \*(Aqconstructor\*(Aq => sub { return $data; },
\&        }
\&    );
\&    print "$$scalar\en"; # Prints "whatever"
\&    $data = \*(Aqsomethingelse\*(Aq;
\&    print "$$scalar\en"; # Prints "whatever" because it is cached
\&    sleep 2; # Wait until the cache entry has expired
\&    print "$$scalar\en"; # Prints "somethingelse"
\&
\&    my $hash = Koha::Cache\->create_hash(
\&        {
\&            \*(Aqkey\*(Aq         => \*(Aqwhatever\*(Aq,
\&            \*(Aqtimeout\*(Aq     => 2,
\&            \*(Aqconstructor\*(Aq => sub { return $data; },
\&        }
\&    );
\&    print "$$variable\en"; # Prints "whatever"
.Ve
.PP
The gotcha with this interface, of course, is that the variable returned by
create_scalar and create_hash is a \fIreference\fR to a tied variable and not a
tied variable itself.
.PP
The tied variable is configured by means of a hashref passed in to the
create_scalar and create_hash methods. The following parameters are supported:
.IP "\fIkey\fR" 4
.IX Item "key"
Required. The key to use for identifying the variable in the cache.
.IP "\fIconstructor\fR" 4
.IX Item "constructor"
Required. A closure (or reference to a function) that will return the value that
needs to be stored in the cache.
.IP "\fIpreload\fR" 4
.IX Item "preload"
Optional. A closure (or reference to a function) that gets run to initialize
the cache when creating the tied variable.
.IP "\fIarguments\fR" 4
.IX Item "arguments"
Optional. Array reference with the arguments that should be passed to the
constructor function.
.IP "\fItimeout\fR" 4
.IX Item "timeout"
Optional. The cache timeout in seconds for the variable. Defaults to 600
(ten minutes).
.IP "\fIcache_type\fR" 4
.IX Item "cache_type"
Optional. Which type of cache to use for the variable. Defaults to whatever is
set in the environment variable \s-1CACHING_SYSTEM.\s0 If set to 'null', disables
caching for the tied variable.
.IP "\fIallowupdate\fR" 4
.IX Item "allowupdate"
Optional. Boolean flag to allow the variable to be updated directly. When this
is set and the variable is used as an l\-value, the cache will be updated
immediately with the new value. Using this is probably a bad idea on a
multi-threaded system. When \fIallowupdate\fR is not set to true, using the
tied variable as an l\-value will have no effect.
.IP "\fIdestructor\fR" 4
.IX Item "destructor"
Optional. A closure (or reference to a function) that should be called when the
tied variable is destroyed.
.IP "\fIunset\fR" 4
.IX Item "unset"
Optional. Boolean flag to tell the object to remove the variable from the cache
when it is destroyed or goes out of scope.
.IP "\fIinprocess\fR" 4
.IX Item "inprocess"
Optional. Boolean flag to tell the object not to refresh the variable from the
cache every time the value is desired, but rather only when the \fIlocal\fR copy
of the variable is older than the timeout.
.SS "create_scalar"
.IX Subsection "create_scalar"
.Vb 1
\&    my $scalar = Koha::Cache\->create_scalar(\e%params);
.Ve
.PP
Create scalar tied to the cache.
.SH "EXPORT"
.IX Header "EXPORT"
None by default.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Koha::Cache::Object
.SH "AUTHOR"
.IX Header "AUTHOR"
Chris Cormack, <chris@bigballofwax.co.nz>
Paul Poulain, <paul.poulain@biblibre.com>
Jared Camins-Esakov, <jcamins@cpbibliography.com>
