.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Koha::MetadataRecord::Authority 3pm"
.TH Koha::MetadataRecord::Authority 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::MetadataRecord::Authority \- class to encapsulate authority records in Koha
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Object-oriented class that encapsulates authority records in Koha.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Authority data.
.SS "new"
.IX Subsection "new"
.Vb 1
\&    my $auth = Koha::MetadataRecord::Authority\->new($record);
.Ve
.PP
Create a new Koha::MetadataRecord::Authority object based on the provided record.
.SS "get_from_authid"
.IX Subsection "get_from_authid"
.Vb 1
\&    my $auth = Koha::MetadataRecord::Authority\->get_from_authid($authid);
.Ve
.PP
Create the Koha::MetadataRecord::Authority object associated with the provided authid.
Note that this routine currently retrieves a \s-1MARC\s0 record because
authorities in Koha are \s-1MARC\s0 records by definition. This is an
unfortunate but unavoidable fact.
.SS "get_from_breeding"
.IX Subsection "get_from_breeding"
.Vb 1
\&    my $auth = Koha::MetadataRecord::Authority\->get_from_authid($authid);
.Ve
.PP
Create the Koha::MetadataRecord::Authority object associated with the provided authid.
.SS "get_all_authorities_iterator"
.IX Subsection "get_all_authorities_iterator"
.Vb 1
\&    my $it = Koha::MetadataRecord::Authority\->get_all_authorities_iterator(%options);
.Ve
.PP
This will provide an iterator object that will, one by one, provide the
Koha::MetadataRecord::Authority of each authority.
.PP
The iterator is a Koha::MetadataIterator object.
.PP
Possible options are:
.ie n .IP """slice""" 4
.el .IP "\f(CWslice\fR" 4
.IX Item "slice"
slice may be defined as a hash of two values: index and count. index
is the slice number to process and count is total number of slices.
With this information the iterator returns just the given slice of
records instead of all.
