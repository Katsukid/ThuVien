.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Koha::Item 3pm"
.TH Koha::Item 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::Item \- Koha Item object class
.SH "API"
.IX Header "API"
.SS "Class methods"
.IX Subsection "Class methods"
\fIstore\fR
.IX Subsection "store"
.PP
.Vb 1
\&    $item\->store;
.Ve
.PP
\&\f(CW$params\fR can take an optional 'skip_record_index' parameter.
If set, the reindexation process will not happen (index_records not called)
You should not turn it on if you do not understand what it is doing exactly.
.PP
\fIdelete\fR
.IX Subsection "delete"
.PP
\fIsafe_delete\fR
.IX Subsection "safe_delete"
.PP
\fIsafe_to_delete\fR
.IX Subsection "safe_to_delete"
.PP
returns 1 if the item is safe to delete,
.PP
\&\*(L"book_on_loan\*(R" if the item is checked out,
.PP
\&\*(L"not_same_branch\*(R" if the item is blocked by independent branches,
.PP
\&\*(L"book_reserved\*(R" if the there are holds aganst the item, or
.PP
\&\*(L"linked_analytics\*(R" if the item has linked analytic records.
.PP
\&\*(L"last_item_for_hold\*(R" if the item is the last one on a record on which a biblio-level hold is placed
.PP
\fImove_to_deleted\fR
.IX Subsection "move_to_deleted"
.PP
my \f(CW$is_moved\fR = \f(CW$item\fR\->move_to_deleted;
.PP
Move an item to the deleteditems table.
This can be done before deleting an item, to make sure the data are not completely deleted.
.PP
\fIeffective_itemtype\fR
.IX Subsection "effective_itemtype"
.PP
Returns the itemtype for the item based on whether item level itemtypes are set or not.
.PP
\fIhome_branch\fR
.IX Subsection "home_branch"
.PP
\fIholding_branch\fR
.IX Subsection "holding_branch"
.PP
\fIbiblio\fR
.IX Subsection "biblio"
.PP
my \f(CW$biblio\fR = \f(CW$item\fR\->biblio;
.PP
Return the bibliographic record of this item
.PP
\fIbiblioitem\fR
.IX Subsection "biblioitem"
.PP
my \f(CW$biblioitem\fR = \f(CW$item\fR\->biblioitem;
.PP
Return the biblioitem record of this item
.PP
\fIcheckout\fR
.IX Subsection "checkout"
.PP
my \f(CW$checkout\fR = \f(CW$item\fR\->checkout;
.PP
Return the checkout for this item
.PP
\fIitem_group\fR
.IX Subsection "item_group"
.PP
my \f(CW$item_group\fR = \f(CW$item\fR\->item_group;
.PP
Return the item group for this item
.PP
\fIreturn_claims\fR
.IX Subsection "return_claims"
.PP
.Vb 1
\&  my $return_claims = $item\->return_claims;
.Ve
.PP
Return any return_claims associated with this item
.PP
\fIreturn_claim\fR
.IX Subsection "return_claim"
.PP
.Vb 1
\&  my $return_claim = $item\->return_claim;
.Ve
.PP
Returns the most recent unresolved return_claims associated with this item
.PP
\fIholds\fR
.IX Subsection "holds"
.PP
my \f(CW$holds\fR = \f(CW$item\fR\->\fBholds()\fR;
my \f(CW$holds\fR = \f(CW$item\fR\->holds($params);
my \f(CW$holds\fR = \f(CW$item\fR\->holds({ found => 'W'});
.PP
Return holds attached to an item, optionally accept a hashref of params to pass to search
.PP
\fIrequest_transfer\fR
.IX Subsection "request_transfer"
.PP
.Vb 7
\&  my $transfer = $item\->request_transfer(
\&    {
\&        to     => $to_library,
\&        reason => $reason,
\&        [ ignore_limits => 0, enqueue => 1, replace => 1 ]
\&    }
\&  );
.Ve
.PP
Add a transfer request for this item to the given branch for the given reason.
.PP
An exception will be thrown if the BranchTransferLimits would prevent the requested
transfer, unless 'ignore_limits' is passed to override the limits.
.PP
An exception will be thrown if an active transfer (i.e pending arrival date) is found;
The caller should catch such cases and retry the transfer request as appropriate passing
an appropriate override.
.PP
Overrides
* enqueue \- Used to queue up the transfer when the existing transfer is found to be in transit.
* replace \- Used to replace the existing transfer request with your own.
.PP
\fIget_transfer\fR
.IX Subsection "get_transfer"
.PP
.Vb 1
\&  my $transfer = $item\->get_transfer;
.Ve
.PP
Return the active transfer request or undef
.PP
Note: Transfers are retrieved in a Modified \s-1FIFO\s0 (First In First Out) order
whereby the most recently sent, but not received, transfer will be returned
if it exists, otherwise the oldest unsatisfied transfer will be returned.
.PP
This allows for transfers to queue, which is the case for stock rotation and
rotating collections where a manual transfer may need to take precedence but
we still expect the item to end up at a final location eventually.
.PP
\fIget_transfers\fR
.IX Subsection "get_transfers"
.PP
.Vb 1
\&  my $transfer = $item\->get_transfers;
.Ve
.PP
Return the list of outstanding transfers (i.e requested but not yet cancelled
or received).
.PP
Note: Transfers are retrieved in a Modified \s-1FIFO\s0 (First In First Out) order
whereby the most recently sent, but not received, transfer will be returned
first if it exists, otherwise requests are in oldest to newest request order.
.PP
This allows for transfers to queue, which is the case for stock rotation and
rotating collections where a manual transfer may need to take precedence but
we still expect the item to end up at a final location eventually.
.PP
\fIlast_returned_by\fR
.IX Subsection "last_returned_by"
.PP
Gets and sets the last patron to return an item.
.PP
Accepts a patron's id (borrowernumber) and returns Koha::Patron objects
.PP
\&\f(CW$item\fR\->last_returned_by( \f(CW$borrowernumber\fR );
.PP
my \f(CW$patron\fR = \f(CW$item\fR\->\fBlast_returned_by()\fR;
.PP
\fIcan_article_request\fR
.IX Subsection "can_article_request"
.PP
my \f(CW$bool\fR = \f(CW$item\fR\->can_article_request( \f(CW$borrower\fR )
.PP
Returns true if item can be specifically requested
.PP
\&\f(CW$borrower\fR must be a Koha::Patron object
.PP
\fIhidden_in_opac\fR
.IX Subsection "hidden_in_opac"
.PP
my \f(CW$bool\fR = \f(CW$item\fR\->hidden_in_opac({ [ rules => \f(CW$rules\fR ] })
.PP
Returns true if item fields match the hidding criteria defined in \f(CW$rules\fR.
Returns false otherwise.
.PP
Takes HASHref that can have the following parameters:
    \s-1OPTIONAL PARAMETERS:\s0
    \f(CW$rules\fR : { <field> => [ value_1, ... ], ... }
.PP
Note: \f(CW$rules\fR inherits its structure from the parsed \s-1YAML\s0 from reading
the \fIOpacHiddenItems\fR system preference.
.PP
\fIcan_be_transferred\fR
.IX Subsection "can_be_transferred"
.PP
\&\f(CW$item\fR\->can_be_transferred({ to => \f(CW$to_library\fR, from => \f(CW$from_library\fR })
Checks if an item can be transferred to given library.
.PP
This feature is controlled by two system preferences:
UseBranchTransferLimits to enable / disable the feature
BranchTransferLimitsType to use either an itemnumber or ccode as an identifier
                         for setting the limitations
.PP
Takes HASHref that can have the following parameters:
    \s-1MANDATORY PARAMETERS:\s0
    \f(CW$to\fR   : Koha::Library
    \s-1OPTIONAL PARAMETERS:\s0
    \f(CW$from\fR : Koha::Library  # if not given, item holdingbranch
                           # will be used instead
.PP
Returns 1 if item can be transferred to \f(CW$to_library\fR, otherwise 0.
.PP
To find out whether at least one item of a Koha::Biblio can be transferred, please
see Koha::Biblio\->\fBcan_be_transferred()\fR instead of using this method for
multiple items of the same biblio.
.PP
\fIpickup_locations\fR
.IX Subsection "pickup_locations"
.PP
.Vb 1
\&    my $pickup_locations = $item\->pickup_locations({ patron => $patron })
.Ve
.PP
Returns possible pickup locations for this item, according to patron's home library
and if item can be transferred to each pickup location.
.PP
Throws a \fIKoha::Exceptions::MissingParameter\fR exception if the \fBmandatory\fR parameter \fIpatron\fR
is not passed.
.PP
\fIarticle_request_type\fR
.IX Subsection "article_request_type"
.PP
my \f(CW$type\fR = \f(CW$item\fR\->article_request_type( \f(CW$borrower\fR )
.PP
returns 'yes', 'no', 'bib_only', or 'item_only'
.PP
\&\f(CW$borrower\fR must be a Koha::Patron object
.PP
\fIcurrent_holds\fR
.IX Subsection "current_holds"
.PP
\fIstockrotationitem\fR
.IX Subsection "stockrotationitem"
.PP
.Vb 1
\&  my $sritem = Koha::Item\->stockrotationitem;
.Ve
.PP
Returns the stock rotation item associated with the current item.
.PP
\fIadd_to_rota\fR
.IX Subsection "add_to_rota"
.PP
.Vb 1
\&  my $item = $item\->add_to_rota($rota_id);
.Ve
.PP
Add this item to the rota identified by \f(CW$ROTA_ID\fR, which means associating it
with the first stage of that rota.  Should this item already be associated
with a rota, then we will move it to the new rota.
.PP
\fIhas_pending_hold\fR
.IX Subsection "has_pending_hold"
.PP
.Vb 1
\&  my $is_pending_hold = $item\->has_pending_hold();
.Ve
.PP
This method checks the tmp_holdsqueue to see if this item has been selected for a hold, but not filled yet and returns true or false
.PP
\fIhas_pending_recall {\fR
.IX Subsection "has_pending_recall {"
.PP
.Vb 1
\&  my $has_pending_recall
.Ve
.PP
Return if whether has pending recall of not.
.PP
\fIas_marc_field\fR
.IX Subsection "as_marc_field"
.PP
.Vb 1
\&    my $field = $item\->as_marc_field;
.Ve
.PP
This method returns a MARC::Field object representing the Koha::Item object
with the current mappings configuration.
.PP
\fIrenewal_branchcode\fR
.IX Subsection "renewal_branchcode"
.PP
Returns the branchcode to be recorded in statistics renewal of the item
.PP
\fIcover_images\fR
.IX Subsection "cover_images"
.PP
Return the cover images associated with this item.
.PP
\fIcolumns_to_str\fR
.IX Subsection "columns_to_str"
.PP
.Vb 1
\&    my $values = $items\->columns_to_str;
.Ve
.PP
Return a hashref with the string representation of the different attribute of the item.
.PP
This is meant to be used for display purpose only.
.PP
\fIadditional_attributes\fR
.IX Subsection "additional_attributes"
.PP
.Vb 3
\&    my $attributes = $item\->additional_attributes;
\&    $attributes\->{k} = \*(Aqnew k\*(Aq;
\&    $item\->update({ more_subfields => $attributes\->to_marcxml });
.Ve
.PP
Returns a Koha::Item::Attributes object that represents the non-mapped
attributes for this item.
.PP
\fI_set_found_trigger\fR
.IX Subsection "_set_found_trigger"
.PP
.Vb 1
\&    $self\->_set_found_trigger
.Ve
.PP
Finds the most recent lost item charge for this item and refunds the patron
appropriately, taking into account any payments or writeoffs already applied
against the charge.
.PP
Internal function, not exported, called only by Koha::Item\->store.
.PP
\fIpublic_read_list\fR
.IX Subsection "public_read_list"
.PP
This method returns the list of publicly readable database fields for both \s-1API\s0 and \s-1UI\s0 output purposes
.PP
\fIto_api\fR
.IX Subsection "to_api"
.PP
Overloaded to_api method to ensure item-level itypes is adhered to.
.PP
\fIto_api_mapping\fR
.IX Subsection "to_api_mapping"
.PP
This method returns the mapping for representing a Koha::Item object
on the \s-1API.\s0
.PP
\fIitemtype\fR
.IX Subsection "itemtype"
.PP
.Vb 1
\&    my $itemtype = $item\->itemtype;
\&
\&    Returns Koha object for effective itemtype
.Ve
.PP
\fIorders\fR
.IX Subsection "orders"
.PP
.Vb 1
\&  my $orders = $item\->orders();
.Ve
.PP
Returns a Koha::Acquisition::Orders object
.PP
\fItracked_links\fR
.IX Subsection "tracked_links"
.PP
.Vb 1
\&  my $tracked_links = $item\->tracked_links();
.Ve
.PP
Returns a Koha::TrackedLinks object
.PP
\fImove_to_biblio\fR
.IX Subsection "move_to_biblio"
.PP
.Vb 1
\&  $item\->move_to_biblio($to_biblio[, $params]);
.Ve
.PP
Move the item to another biblio and update any references in other tables.
.PP
The final optional parameter, \f(CW$params\fR, is expected to contain the
\&'skip_record_index' key, which is relayed down to Koha::Item\->store.
There it prevents calling index_records, which takes most of the
time in batch adds/deletes. The caller must take care of calling
index_records separately.
.PP
\&\f(CW$params:\fR
    skip_record_index => 1|0
.PP
Returns undef if the move failed or the biblionumber of the destination record otherwise
.PP
\fIbundle_items\fR
.IX Subsection "bundle_items"
.PP
.Vb 1
\&  my $bundle_items = $item\->bundle_items;
.Ve
.PP
Returns the items associated with this bundle
.PP
\fIis_bundle\fR
.IX Subsection "is_bundle"
.PP
.Vb 1
\&  my $is_bundle = $item\->is_bundle;
.Ve
.PP
Returns whether the item is a bundle or not
.PP
\fIbundle_host\fR
.IX Subsection "bundle_host"
.PP
.Vb 1
\&  my $bundle = $item\->bundle_host;
.Ve
.PP
Returns the bundle item this item is attached to
.PP
\fIin_bundle\fR
.IX Subsection "in_bundle"
.PP
.Vb 1
\&  my $in_bundle = $item\->in_bundle;
.Ve
.PP
Returns whether this item is currently in a bundle
.PP
\fIadd_to_bundle\fR
.IX Subsection "add_to_bundle"
.PP
.Vb 1
\&  my $link = $item\->add_to_bundle($bundle_item);
.Ve
.PP
Adds the bundle_item passed to this item
.PP
\fIremove_from_bundle\fR
.IX Subsection "remove_from_bundle"
.PP
Remove this item from any bundle it may have been attached to.
.SS "Internal methods"
.IX Subsection "Internal methods"
\fI_after_item_action_hooks\fR
.IX Subsection "_after_item_action_hooks"
.PP
Helper method that takes care of calling all plugin hooks
.PP
\fIrecall\fR
.IX Subsection "recall"
.PP
.Vb 1
\&    my $recall = $item\->recall;
.Ve
.PP
Return the relevant recall for this item
.PP
\fIcan_be_recalled\fR
.IX Subsection "can_be_recalled"
.PP
.Vb 1
\&    if ( $item\->can_be_recalled({ patron => $patron_object }) ) # do recall
.Ve
.PP
Does item-level checks and returns if items can be recalled by this borrower
.PP
\fIcan_be_waiting_recall\fR
.IX Subsection "can_be_waiting_recall"
.PP
.Vb 1
\&    if ( $item\->can_be_waiting_recall ) { # allocate item as waiting for recall
.Ve
.PP
Checks item type and branch of circ rules to return whether this item can be used to fill a recall.
At this point the item has already been recalled. We are now at the checkin and set waiting stage.
.PP
\fIcheck_recalls\fR
.IX Subsection "check_recalls"
.PP
.Vb 1
\&    my $recall = $item\->check_recalls;
.Ve
.PP
Get the most relevant recall for this item.
.PP
\fIis_notforloan\fR
.IX Subsection "is_notforloan"
.PP
.Vb 1
\&    my $is_notforloan = $item\->is_notforloan;
.Ve
.PP
Determine whether or not this item is \*(L"notforloan\*(R" based on
the item's notforloan status or its item type
.PP
\fIis_denied_renewal\fR
.IX Subsection "is_denied_renewal"
.PP
.Vb 1
\&    my $is_denied_renewal = $item\->is_denied_renewal;
.Ve
.PP
Determine whether or not this item can be renewed based on the
rules set in the ItemsDeniedRenewal system preference.
.PP
\fIstrings_map\fR
.IX Subsection "strings_map"
.PP
Returns a map of column name to string representations including the string,
the mapping type and the mapping category where appropriate.
.PP
Currently handles authorised value mappings, library, callnumber and itemtype
expansions.
.PP
Accepts a param hashref where the 'public' key denotes whether we want the public
or staff client strings.
.PP
\fI_type\fR
.IX Subsection "_type"
.SH "AUTHOR"
.IX Header "AUTHOR"
Kyle M Hall <kyle@bywatersolutions.com>
