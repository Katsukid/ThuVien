.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Koha::Objects 3pm"
.TH Koha::Objects 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::Objects \- Koha Object set base class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Koha::Objects;
\&    my $objects = Koha::Objects\->search({ borrowernumber => $borrowernumber});
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class must be subclassed.
.SH "API"
.IX Header "API"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fIKoha::Objects\->\f(BInew()\fI;\fR
.IX Subsection "Koha::Objects->new();"
.PP
my \f(CW$object\fR = Koha::Objects\->\fBnew()\fR;
.PP
\fIKoha::Objects\->\f(BI_new_from_dbic()\fI;\fR
.IX Subsection "Koha::Objects->_new_from_dbic();"
.PP
my \f(CW$object\fR = Koha::Objects\->_new_from_dbic( \f(CW$resultset\fR );
.PP
\fIKoha::Objects\->\f(BIfind()\fI;\fR
.IX Subsection "Koha::Objects->find();"
.PP
Similar to DBIx::Class::ResultSet\->find this method accepts:
    \e%columns_values | \f(CW@pk_values\fR, { key => \f(CW$unique_constraint\fR, \f(CW%attrs\fR }?
Strictly speaking, columns_values should only refer to columns under an
unique constraint.
.PP
It returns undef if no results were found
.PP
my \f(CW$object\fR = Koha::Objects\->find( { col1 => \f(CW$val1\fR, col2 => \f(CW$val2\fR } );
my \f(CW$object\fR = Koha::Objects\->find( \f(CW$id\fR );
my \f(CW$object\fR = Koha::Objects\->find( \f(CW$idpart1\fR, \f(CW$idpart2\fR, \f(CW$attrs\fR ); # composite \s-1PK\s0
.PP
\fIKoha::Objects\->\f(BIfind_or_create()\fI;\fR
.IX Subsection "Koha::Objects->find_or_create();"
.PP
my \f(CW$object\fR = Koha::Objects\->find_or_create( \f(CW$attrs\fR );
.PP
\fIsearch\fR
.IX Subsection "search"
.PP
.Vb 5
\&    # scalar context
\&    my $objects = Koha::Objects\->search([$params, $attributes]);
\&    while (my $object = $objects\->next) {
\&        do_stuff($object);
\&    }
.Ve
.PP
This \fBinstantiates\fR the \fIKoha::Objects\fR class, and generates a resultset
based on the query \fI\f(CI$params\fI\fR and \fI\f(CI$attributes\fI\fR that are passed (like in \s-1DBIC\s0).
.PP
\fIsearch_related\fR
.IX Subsection "search_related"
.PP
.Vb 1
\&    my $objects = Koha::Objects\->search_related( $rel_name, $cond?, \e%attrs? );
.Ve
.PP
Searches the specified relationship, optionally specifying a condition and attributes for matching records.
.PP
\fIdelete\fR
.IX Subsection "delete"
.PP
\fIupdate\fR
.IX Subsection "update"
.PP
.Vb 2
\&    my $objects = Koha::Objects\->new; # or Koha::Objects\->search
\&    $objects\->update( $fields, [ { no_triggers => 0/1 } ] );
.Ve
.PP
This method overloads the \s-1DBIC\s0 inherited one so if code-level triggers exist
(through the use of an overloaded \fIupdate\fR or \fIstore\fR method in the Koha::Object
based class) those are called in a loop on the resultset.
.PP
If \fBno_triggers\fR is passed and \fItrue\fR, then the \s-1DBIC\s0 update method is called
directly. This feature is important for performance, in cases where no code-level
triggers should be triggered. The developer will explicitly ask for this and \s-1QA\s0 should
catch wrong uses as well.
.PP
\fIfilter_by_last_update\fR
.IX Subsection "filter_by_last_update"
.PP
my \f(CW$filtered_objects\fR = \f(CW$objects\fR\->filter_by_last_update
.PP
days exclusive by default (will be inclusive if days_inclusive is passed and set)
from inclusive
to   inclusive
.PP
\fIsingle\fR
.IX Subsection "single"
.PP
my \f(CW$object\fR = Koha::Objects\->search({}, { rows => 1 })\->single
.PP
Returns one and only one object that is part of this set.
Returns undef if there are no objects found.
.PP
This is optimal as it will grab the first returned result without instantiating
a cursor.
.PP
See:
http://search.cpan.org/dist/DBIx\-Class/lib/DBIx/Class/Manual/Cookbook.pod#Retrieve_one_and_only_one_row_from_a_resultset
.PP
\fIKoha::Objects\->\f(BInext()\fI;\fR
.IX Subsection "Koha::Objects->next();"
.PP
my \f(CW$object\fR = Koha::Objects\->\fBnext()\fR;
.PP
Returns the next object that is part of this set.
Returns undef if there are no more objects to return.
.PP
\fIKoha::Objects\->last;\fR
.IX Subsection "Koha::Objects->last;"
.PP
my \f(CW$object\fR = Koha::Objects\->last;
.PP
Returns the last object that is part of this set.
Returns undef if there are no object to return.
.PP
\fIempty\fR
.IX Subsection "empty"
.PP
.Vb 1
\&    my $empty_rs = Koha::Objects\->new\->empty;
.Ve
.PP
Sets the resultset empty. This is handy for consistency on method returns
(e.g. if we know in advance we won't have results but want to keep returning
an iterator).
.PP
\fIKoha::Objects\->\f(BIreset()\fI;\fR
.IX Subsection "Koha::Objects->reset();"
.PP
Koha::Objects\->\fBreset()\fR;
.PP
resets iteration so the next call to \fBnext()\fR will start agein
with the first object in a set.
.PP
\fIKoha::Objects\->\f(BIas_list()\fI;\fR
.IX Subsection "Koha::Objects->as_list();"
.PP
Koha::Objects\->\fBas_list()\fR;
.PP
Returns an arrayref of the objects in this set.
.PP
\fIKoha::Objects\->unblessed\fR
.IX Subsection "Koha::Objects->unblessed"
.PP
Returns an unblessed representation of objects.
.PP
\fIKoha::Objects\->get_column\fR
.IX Subsection "Koha::Objects->get_column"
.PP
Return all the values of this set for a given column
.PP
\fIKoha::Objects\->\s-1TO_JSON\s0\fR
.IX Subsection "Koha::Objects->TO_JSON"
.PP
Returns an unblessed representation of objects, suitable for \s-1JSON\s0 output.
.PP
\fIKoha::Objects\->to_api\fR
.IX Subsection "Koha::Objects->to_api"
.PP
Returns a representation of the objects, suitable for \s-1API\s0 output .
.PP
\fIattributes_from_api\fR
.IX Subsection "attributes_from_api"
.PP
.Vb 1
\&    my $attributes = $objects\->attributes_from_api( $api_attributes );
.Ve
.PP
Translates attributes from the \s-1API\s0 to \s-1DBIC\s0
.PP
\fIfrom_api_mapping\fR
.IX Subsection "from_api_mapping"
.PP
.Vb 1
\&    my $mapped_attributes_hash = $objects\->from_api_mapping;
.Ve
.PP
Attributes map from the \s-1API\s0 to \s-1DBIC\s0
.PP
\fIprefetch_whitelist\fR
.IX Subsection "prefetch_whitelist"
.PP
.Vb 1
\&    my $whitelist = $object\->prefetch_whitelist()
.Ve
.PP
Returns a hash of prefetchable subs and the type it returns
.PP
\fIKoha::Objects\->_wrap\fR
.IX Subsection "Koha::Objects->_wrap"
.PP
wraps the \s-1DBIC\s0 object in a corresponding Koha object
.PP
\fIKoha::Objects\->_resultset\fR
.IX Subsection "Koha::Objects->_resultset"
.PP
Returns the internal resultset or creates it if undefined
.PP
\fIcolumns\fR
.IX Subsection "columns"
.PP
my \f(CW@columns\fR = Koha::Objects\->columns
.PP
Return the table columns
.PP
\fI\s-1AUTOLOAD\s0\fR
.IX Subsection "AUTOLOAD"
.PP
The autoload method is used call DBIx::Class method on a resultset.
.PP
Important: If you plan to use one of the DBIx::Class methods you must provide
relevant tests in t/db_dependent/Koha/Objects.t
Currently count, is_paged, pager, result_class, single and slice are covered.
.PP
\fI_type\fR
.IX Subsection "_type"
.PP
The _type method must be set for all child classes.
The value returned by it should be the \s-1DBIC\s0 resultset name.
For example, for holds, _type should return 'Reserve'.
.PP
\fIobject_class\fR
.IX Subsection "object_class"
.PP
This method must be set for all child classes.
The value returned by it should be the name of the Koha
object class that is returned by this class.
For example, for holds, object_class should return 'Koha::Hold'.
.SH "AUTHOR"
.IX Header "AUTHOR"
Kyle M Hall <kyle@bywatersolutions.com>
