.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "C4::Circulation 3pm"
.TH C4::Circulation 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::Circulation \- Koha circulation module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use C4::Circulation;
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The functions in this module deal with circulation, issues, and
returns, as well as general information about the library.
Also deals with inventory.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "barcodedecode"
.IX Subsection "barcodedecode"
.Vb 1
\&  $str = &barcodedecode($barcode, [$filter]);
.Ve
.PP
Generic filter function for barcode string.
Called on every circ if the System Pref itemBarcodeInputFilter is set.
Will do some manipulation of the barcode for systems that deliver a barcode
to circulation.pl that differs from the barcode stored for the item.
For proper functioning of this filter, calling the function on the 
correct barcode string (items.barcode) should return an unaltered barcode.
Barcode is going to be automatically trimmed of leading/trailing whitespaces.
.PP
The optional \f(CW$filter\fR argument is to allow for testing or explicit 
behavior that ignores the System Pref.  Valid values are the same as the 
System Pref options.
.SS "_decode"
.IX Subsection "_decode"
.Vb 1
\&  $str = &_decode($chunk);
.Ve
.PP
Decodes a segment of a string emitted by a CueCat barcode scanner and
returns it.
.PP
\&\s-1FIXME:\s0 Should be replaced with Barcode::Cuecat from \s-1CPAN\s0
or Javascript based decoding on the client side.
.SS "transferbook"
.IX Subsection "transferbook"
.Vb 7
\&  ($dotransfer, $messages, $iteminformation) = &transferbook({
\&                                                   from_branch => $frombranch
\&                                                   to_branch => $tobranch,
\&                                                   barcode => $barcode,
\&                                                   ignore_reserves => $ignore_reserves,
\&                                                   trigger => $trigger
\&                                                });
.Ve
.PP
Transfers an item to a new branch. If the item is currently on loan, it is automatically returned before the actual transfer.
.PP
\&\f(CW$fbr\fR is the code for the branch initiating the transfer.
\&\f(CW$tbr\fR is the code for the branch to which the item should be transferred.
.PP
\&\f(CW$barcode\fR is the barcode of the item to be transferred.
.PP
If \f(CW$ignore_reserves\fR is true, \f(CW&transferbook\fR ignores reserves.
Otherwise, if an item is reserved, the transfer fails.
.PP
\&\f(CW$trigger\fR is the enum value for what triggered the transfer.
.PP
Returns three values:
.ie n .IP "$dotransfer" 4
.el .IP "\f(CW$dotransfer\fR" 4
.IX Item "$dotransfer"
is true if the transfer was successful.
.ie n .IP "$messages" 4
.el .IP "\f(CW$messages\fR" 4
.IX Item "$messages"
is a reference-to-hash which may have any of the following keys:
.RS 4
.ie n .IP """BadBarcode""" 4
.el .IP "\f(CWBadBarcode\fR" 4
.IX Item "BadBarcode"
There is no item in the catalog with the given barcode. The value is \f(CW$barcode\fR.
.ie n .IP """DestinationEqualsHolding""" 4
.el .IP "\f(CWDestinationEqualsHolding\fR" 4
.IX Item "DestinationEqualsHolding"
The item is already at the branch to which it is being transferred. The transfer is nonetheless considered to have failed. The value should be ignored.
.ie n .IP """WasReturned""" 4
.el .IP "\f(CWWasReturned\fR" 4
.IX Item "WasReturned"
The item was on loan, and \f(CW&transferbook\fR automatically returned it before transferring it. The value is the borrower number of the patron who had the item.
.ie n .IP """ResFound""" 4
.el .IP "\f(CWResFound\fR" 4
.IX Item "ResFound"
The item was reserved. The value is a reference-to-hash whose keys are fields from the reserves table of the Koha database, and \f(CW\*(C`biblioitemnumber\*(C'\fR. It also has the key \f(CW\*(C`ResFound\*(C'\fR, whose value is either \f(CW\*(C`Waiting\*(C'\fR or \f(CW\*(C`Reserved\*(C'\fR.
.ie n .IP """WasTransferred""" 4
.el .IP "\f(CWWasTransferred\fR" 4
.IX Item "WasTransferred"
The item was eligible to be transferred. Barring problems communicating with the database, the transfer should indeed have succeeded. The value should be ignored.
.ie n .IP """RecallPlacedAtHoldingBranch""" 4
.el .IP "\f(CWRecallPlacedAtHoldingBranch\fR" 4
.IX Item "RecallPlacedAtHoldingBranch"
A recall for this item was found, and the transfer has already been completed as the item's branch matches the recall's pickup branch.
.ie n .IP """RecallFound""" 4
.el .IP "\f(CWRecallFound\fR" 4
.IX Item "RecallFound"
A recall for this item was found, and the item needs to be transferred to the recall's pickup branch.
.RE
.RS 4
.RE
.SS "CanBookBeIssued"
.IX Subsection "CanBookBeIssued"
.Vb 2
\&  ( $issuingimpossible, $needsconfirmation, [ $alerts ] ) =  CanBookBeIssued( $patron,
\&                      $barcode, $duedate, $inprocess, $ignore_reserves, $params );
.Ve
.PP
Check if a book can be issued.
.PP
\&\f(CW$issuingimpossible\fR and \f(CW$needsconfirmation\fR are hashrefs.
.PP
\&\s-1IMPORTANT:\s0 The assumption by users of this routine is that causes blocking
the issue are keyed by uppercase labels and other returned
data is keyed in lower case!
.ie n .IP "$patron is a Koha::Patron" 4
.el .IP "\f(CW$patron\fR is a Koha::Patron" 4
.IX Item "$patron is a Koha::Patron"
.PD 0
.ie n .IP "$barcode is the bar code of the book being issued." 4
.el .IP "\f(CW$barcode\fR is the bar code of the book being issued." 4
.IX Item "$barcode is the bar code of the book being issued."
.ie n .IP "$duedates is a DateTime object." 4
.el .IP "\f(CW$duedates\fR is a DateTime object." 4
.IX Item "$duedates is a DateTime object."
.ie n .IP "$inprocess boolean switch" 4
.el .IP "\f(CW$inprocess\fR boolean switch" 4
.IX Item "$inprocess boolean switch"
.ie n .IP "$ignore_reserves boolean switch" 4
.el .IP "\f(CW$ignore_reserves\fR boolean switch" 4
.IX Item "$ignore_reserves boolean switch"
.ie n .IP "$params Hashref of additional parameters" 4
.el .IP "\f(CW$params\fR Hashref of additional parameters" 4
.IX Item "$params Hashref of additional parameters"
.PD
Available keys:
    override_high_holds \- Ignore high holds
    onsite_checkout     \- Checkout is an onsite checkout that will not leave the library
.PP
Returns :
.ie n .IP "$issuingimpossible a reference to a hash. It contains reasons why issuing is impossible. Possible values are :" 4
.el .IP "\f(CW$issuingimpossible\fR a reference to a hash. It contains reasons why issuing is impossible. Possible values are :" 4
.IX Item "$issuingimpossible a reference to a hash. It contains reasons why issuing is impossible. Possible values are :"
.PP
\fI\s-1INVALID_DATE\s0\fR
.IX Subsection "INVALID_DATE"
.PP
sticky due date is invalid
.PP
\fI\s-1GNA\s0\fR
.IX Subsection "GNA"
.PP
borrower gone with no address
.PP
\fI\s-1CARD_LOST\s0\fR
.IX Subsection "CARD_LOST"
.PP
borrower declared it's card lost
.PP
\fI\s-1DEBARRED\s0\fR
.IX Subsection "DEBARRED"
.PP
borrower debarred
.PP
\fI\s-1UNKNOWN_BARCODE\s0\fR
.IX Subsection "UNKNOWN_BARCODE"
.PP
barcode unknown
.PP
\fI\s-1NOT_FOR_LOAN\s0\fR
.IX Subsection "NOT_FOR_LOAN"
.PP
item is not for loan
.PP
\fI\s-1WTHDRAWN\s0\fR
.IX Subsection "WTHDRAWN"
.PP
item withdrawn.
.PP
\fI\s-1RESTRICTED\s0\fR
.IX Subsection "RESTRICTED"
.PP
item is restricted (set by ??)
.PP
\&\f(CW$needsconfirmation\fR a reference to a hash. It contains reasons why the loan 
could be prevented, but ones that can be overriden by the operator.
.PP
Possible values are :
.PP
\fI\s-1DEBT\s0\fR
.IX Subsection "DEBT"
.PP
borrower has debts.
.PP
\fI\s-1RENEW_ISSUE\s0\fR
.IX Subsection "RENEW_ISSUE"
.PP
renewing, not issuing
.PP
\fI\s-1ISSUED_TO_ANOTHER\s0\fR
.IX Subsection "ISSUED_TO_ANOTHER"
.PP
issued to someone else.
.PP
\fI\s-1RESERVED\s0\fR
.IX Subsection "RESERVED"
.PP
reserved for someone else.
.PP
\fI\s-1TRANSFERRED\s0\fR
.IX Subsection "TRANSFERRED"
.PP
reserved and being transferred for someone else.
.PP
\fI\s-1INVALID_DATE\s0\fR
.IX Subsection "INVALID_DATE"
.PP
sticky due date is invalid or due date in the past
.PP
\fI\s-1TOO_MANY\s0\fR
.IX Subsection "TOO_MANY"
.PP
if the borrower borrows to much things
.PP
\fI\s-1RECALLED\s0\fR
.IX Subsection "RECALLED"
.PP
recalled by someone else
.SS "CanBookBeReturned"
.IX Subsection "CanBookBeReturned"
.Vb 1
\&  ($returnallowed, $message) = CanBookBeReturned($item, $branch)
.Ve
.PP
Check whether the item can be returned to the provided branch
.ie n .IP "$item is a hash of item information as returned Koha::Items\->find\->unblessed (Temporary, should be a Koha::Item instead)" 4
.el .IP "\f(CW$item\fR is a hash of item information as returned Koha::Items\->find\->unblessed (Temporary, should be a Koha::Item instead)" 4
.IX Item "$item is a hash of item information as returned Koha::Items->find->unblessed (Temporary, should be a Koha::Item instead)"
.PD 0
.ie n .IP "$branch is the branchcode where the return is taking place" 4
.el .IP "\f(CW$branch\fR is the branchcode where the return is taking place" 4
.IX Item "$branch is the branchcode where the return is taking place"
.PD
.PP
Returns:
.ie n .IP "$returnallowed is 0 or 1, corresponding to whether the return is allowed (1) or not (0)" 4
.el .IP "\f(CW$returnallowed\fR is 0 or 1, corresponding to whether the return is allowed (1) or not (0)" 4
.IX Item "$returnallowed is 0 or 1, corresponding to whether the return is allowed (1) or not (0)"
.PD 0
.ie n .IP "$message is the branchcode where the item \s-1SHOULD\s0 be returned, if the return is not allowed" 4
.el .IP "\f(CW$message\fR is the branchcode where the item \s-1SHOULD\s0 be returned, if the return is not allowed" 4
.IX Item "$message is the branchcode where the item SHOULD be returned, if the return is not allowed"
.PD
.SS "CheckHighHolds"
.IX Subsection "CheckHighHolds"
.Vb 3
\&    used when syspref decreaseLoanHighHolds is active. Returns 1 or 0 to define whether the minimum value held in
\&    decreaseLoanHighHoldsValue is exceeded, the total number of outstanding holds, the number of days the loan
\&    has been decreased to (held in syspref decreaseLoanHighHoldsValue), and the new due date
.Ve
.SS "AddIssue"
.IX Subsection "AddIssue"
.Vb 1
\&  &AddIssue($borrower, $barcode, [$datedue], [$cancelreserve], [$issuedate])
.Ve
.PP
Issue a book. Does no check, they are done in CanBookBeIssued. If we reach this sub, it means the user confirmed if needed.
.ie n .IP "$borrower is a hash with borrower informations (from Koha::Patron\->unblessed)." 4
.el .IP "\f(CW$borrower\fR is a hash with borrower informations (from Koha::Patron\->unblessed)." 4
.IX Item "$borrower is a hash with borrower informations (from Koha::Patron->unblessed)."
.PD 0
.ie n .IP "$barcode is the barcode of the item being issued." 4
.el .IP "\f(CW$barcode\fR is the barcode of the item being issued." 4
.IX Item "$barcode is the barcode of the item being issued."
.ie n .IP "$datedue is a DateTime object for the max date of return, i.e. the date due (optional). Calculated if empty." 4
.el .IP "\f(CW$datedue\fR is a DateTime object for the max date of return, i.e. the date due (optional). Calculated if empty." 4
.IX Item "$datedue is a DateTime object for the max date of return, i.e. the date due (optional). Calculated if empty."
.ie n .IP "$cancelreserve is 1 to override and cancel any pending reserves for the item (optional)." 4
.el .IP "\f(CW$cancelreserve\fR is 1 to override and cancel any pending reserves for the item (optional)." 4
.IX Item "$cancelreserve is 1 to override and cancel any pending reserves for the item (optional)."
.ie n .IP "$issuedate is a DateTime object for the date to issue the item (optional). Defaults to today." 4
.el .IP "\f(CW$issuedate\fR is a DateTime object for the date to issue the item (optional). Defaults to today." 4
.IX Item "$issuedate is a DateTime object for the date to issue the item (optional). Defaults to today."
.PD
AddIssue does the following things :
.Sp
.Vb 10
\&  \- step 01: check that there is a borrowernumber & a barcode provided
\&  \- check for RENEWAL (book issued & being issued to the same patron)
\&      \- renewal YES = Calculate Charge & renew
\&      \- renewal NO  =
\&          * BOOK ACTUALLY ISSUED ? do a return if book is actually issued (but to someone else)
\&          * RESERVE PLACED ?
\&              \- fill reserve if reserve to this patron
\&              \- cancel reserve or not, otherwise
\&          * RECALL PLACED ?
\&              \- fill recall if recall to this patron
\&              \- cancel recall or not
\&              \- revert recall\*(Aqs waiting status or not
\&          * TRANSFERT PENDING ?
\&              \- complete the transfert
\&          * ISSUE THE BOOK
.Ve
.SS "GetLoanLength"
.IX Subsection "GetLoanLength"
.Vb 1
\&  my $loanlength = &GetLoanLength($borrowertype,$itemtype,branchcode)
.Ve
.PP
Get loan length for an itemtype, a borrower type and a branch
.SS "GetHardDueDate"
.IX Subsection "GetHardDueDate"
.Vb 1
\&  my ($hardduedate,$hardduedatecompare) = &GetHardDueDate($borrowertype,$itemtype,branchcode)
.Ve
.PP
Get the Hard Due Date and it's comparison for an itemtype, a borrower type and a branch
.SS "GetBranchBorrowerCircRule"
.IX Subsection "GetBranchBorrowerCircRule"
.Vb 1
\&  my $branch_cat_rule = GetBranchBorrowerCircRule($branchcode, $categorycode);
.Ve
.PP
Retrieves circulation rule attributes that apply to the given
branch and patron category, regardless of item type.  
The return value is a hashref containing the following key:
.PP
patron_maxissueqty \- maximum number of loans that a
patron of the given category can have at the given
branch.  If the value is undef, no limit.
.PP
patron_maxonsiteissueqty \- maximum of on-site checkouts that a
patron of the given category can have at the given
branch.  If the value is undef, no limit.
.PP
This will check for different branch/category combinations in the following order:
branch and category
branch only
category only
default branch and category
.PP
If no rule has been found in the database, it will default to
the buillt in rule:
.PP
patron_maxissueqty \- undef
patron_maxonsiteissueqty \- undef
.PP
\&\f(CW$branchcode\fR and \f(CW$categorycode\fR should contain the
literal branch code and patron category code, respectively \- no
wildcards.
.SS "GetBranchItemRule"
.IX Subsection "GetBranchItemRule"
.Vb 1
\&  my $branch_item_rule = GetBranchItemRule($branchcode, $itemtype);
.Ve
.PP
Retrieves circulation rule attributes that apply to the given
branch and item type, regardless of patron category.
.PP
The return value is a hashref containing the following keys:
.PP
holdallowed => Hold policy for this branch and itemtype. Possible values:
  not_allowed:           No holds allowed.
  from_home_library:     Holds allowed only by patrons that have the same homebranch as the item.
  from_any_library:      Holds allowed from any patron.
  from_local_hold_group: Holds allowed from libraries in hold group
.PP
This searches branchitemrules in the following order:
.PP
.Vb 4
\&  * Same branchcode and itemtype
\&  * Same branchcode, itemtype \*(Aq*\*(Aq
\&  * branchcode \*(Aq*\*(Aq, same itemtype
\&  * branchcode and itemtype \*(Aq*\*(Aq
.Ve
.PP
Neither \f(CW$branchcode\fR nor \f(CW$itemtype\fR should be '*'.
.SS "AddReturn"
.IX Subsection "AddReturn"
.Vb 2
\&  ($doreturn, $messages, $iteminformation, $borrower) =
\&      &AddReturn( $barcode, $branch [,$exemptfine] [,$returndate] );
.Ve
.PP
Returns a book.
.ie n .IP "$barcode is the bar code of the book being returned." 4
.el .IP "\f(CW$barcode\fR is the bar code of the book being returned." 4
.IX Item "$barcode is the bar code of the book being returned."
.PD 0
.ie n .IP "$branch is the code of the branch where the book is being returned." 4
.el .IP "\f(CW$branch\fR is the code of the branch where the book is being returned." 4
.IX Item "$branch is the code of the branch where the book is being returned."
.ie n .IP "$exemptfine indicates that overdue charges for the item will be removed. Optional." 4
.el .IP "\f(CW$exemptfine\fR indicates that overdue charges for the item will be removed. Optional." 4
.IX Item "$exemptfine indicates that overdue charges for the item will be removed. Optional."
.ie n .IP "$return_date allows the default return date to be overridden by the given return date. Optional." 4
.el .IP "\f(CW$return_date\fR allows the default return date to be overridden by the given return date. Optional." 4
.IX Item "$return_date allows the default return date to be overridden by the given return date. Optional."
.PD
.PP
\&\f(CW&AddReturn\fR returns a list of four items:
.PP
\&\f(CW$doreturn\fR is true iff the return succeeded.
.PP
\&\f(CW$messages\fR is a reference-to-hash giving feedback on the operation.
The keys of the hash are:
.ie n .IP """BadBarcode""" 4
.el .IP "\f(CWBadBarcode\fR" 4
.IX Item "BadBarcode"
No item with this barcode exists. The value is \f(CW$barcode\fR.
.ie n .IP """NotIssued""" 4
.el .IP "\f(CWNotIssued\fR" 4
.IX Item "NotIssued"
The book is not currently on loan. The value is \f(CW$barcode\fR.
.ie n .IP """withdrawn""" 4
.el .IP "\f(CWwithdrawn\fR" 4
.IX Item "withdrawn"
This book has been withdrawn/cancelled. The value should be ignored.
.ie n .IP """Wrongbranch""" 4
.el .IP "\f(CWWrongbranch\fR" 4
.IX Item "Wrongbranch"
This book has was returned to the wrong branch.  The value is a hashref
so that \f(CW\*(C`$messages\-\*(C'\fR{Wrongbranch}\->{Wrongbranch}> and \f(CW\*(C`$messages\-\*(C'\fR{Wrongbranch}\->{Rightbranch}>
contain the branchcode of the incorrect and correct return library, respectively.
.ie n .IP """ResFound""" 4
.el .IP "\f(CWResFound\fR" 4
.IX Item "ResFound"
The item was reserved. The value is a reference-to-hash whose keys are
fields from the reserves table of the Koha database, and
\&\f(CW\*(C`biblioitemnumber\*(C'\fR. It also has the key \f(CW\*(C`ResFound\*(C'\fR, whose value is
either \f(CW\*(C`Waiting\*(C'\fR, \f(CW\*(C`Reserved\*(C'\fR, or 0.
.ie n .IP """WasReturned""" 4
.el .IP "\f(CWWasReturned\fR" 4
.IX Item "WasReturned"
Value 1 if return is successful.
.ie n .IP """NeedsTransfer""" 4
.el .IP "\f(CWNeedsTransfer\fR" 4
.IX Item "NeedsTransfer"
If AutomaticItemReturn is disabled, return branch is given as value of NeedsTransfer.
.ie n .IP """RecallFound""" 4
.el .IP "\f(CWRecallFound\fR" 4
.IX Item "RecallFound"
This item can fill a recall. The recall object is returned. If the recall pickup branch differs from
the branch this item is being returned at, \f(CW\*(C`RecallNeedsTransfer\*(C'\fR is also returned which contains this
branchcode.
.ie n .IP """TransferredRecall""" 4
.el .IP "\f(CWTransferredRecall\fR" 4
.IX Item "TransferredRecall"
This item has been transferred to this branch to fill a recall. The recall object is returned.
.PP
\&\f(CW$iteminformation\fR is a reference-to-hash, giving information about the
returned item from the issues table.
.PP
\&\f(CW$borrower\fR is a reference-to-hash, giving information about the
patron who last borrowed the book.
.SS "MarkIssueReturned"
.IX Subsection "MarkIssueReturned"
.Vb 1
\&  MarkIssueReturned($borrowernumber, $itemnumber, $returndate, $privacy, [$params] );
.Ve
.PP
Unconditionally marks an issue as being returned by
moving the \f(CW\*(C`issues\*(C'\fR row to \f(CW\*(C`old_issues\*(C'\fR and
setting \f(CW\*(C`returndate\*(C'\fR to the current date.
.PP
if \f(CW$returndate\fR is specified (in iso format), it is used as the date
of the return.
.PP
\&\f(CW$privacy\fR contains the privacy parameter. If the patron has set privacy to 2,
the old_issue is immediately anonymised
.PP
Ideally, this function would be internal to \f(CW\*(C`C4::Circulation\*(C'\fR,
not exported, but it is currently used in misc/cronjobs/longoverdue.pl
and offline_circ/process_koc.pl.
.PP
The last optional parameter allos passing skip_record_index to the item store call.
.SS "_debar_user_on_return"
.IX Subsection "_debar_user_on_return"
.Vb 1
\&    _debar_user_on_return($borrower, $item, $datedue, $returndate);
.Ve
.PP
\&\f(CW$borrower\fR borrower hashref
.PP
\&\f(CW$item\fR item hashref
.PP
\&\f(CW$datedue\fR date due DateTime object
.PP
\&\f(CW$returndate\fR DateTime object representing the return time
.PP
Internal function, called only by AddReturn that calculates and updates
 the user fine days, and debars them if necessary.
.PP
Should only be called for overdue returns
.PP
Calculation of the debarment date has been moved to a separate subroutine _calculate_new_debar_dt
to ease testing.
.SS "_FixOverduesOnReturn"
.IX Subsection "_FixOverduesOnReturn"
.Vb 1
\&   &_FixOverduesOnReturn($borrowernumber, $itemnumber, $exemptfine, $status);
.Ve
.PP
\&\f(CW$borrowernumber\fR borrowernumber
.PP
\&\f(CW$itemnumber\fR itemnumber
.PP
\&\f(CW$exemptfine\fR \s-1BOOL\s0 \*(-- remove overdue charge associated with this issue.
.PP
\&\f(CW$status\fR \s-1ENUM\s0 \*(-- reason for fix [ \s-1RETURNED, RENEWED, LOST, FORGIVEN\s0 ]
.PP
Internal function
.SS "_GetCircControlBranch"
.IX Subsection "_GetCircControlBranch"
.Vb 1
\&   my $circ_control_branch = _GetCircControlBranch($iteminfos, $borrower);
.Ve
.PP
Internal function :
.PP
Return the library code to be used to determine which circulation
policy applies to a transaction.  Looks up the CircControl and
HomeOrHoldingBranch system preferences.
.PP
\&\f(CW$iteminfos\fR is a hashref to iteminfo. Only {homebranch or holdingbranch} is used.
.PP
\&\f(CW$borrower\fR is a hashref to borrower. Only {branchcode} is used.
.SS "GetUpcomingDueIssues"
.IX Subsection "GetUpcomingDueIssues"
.Vb 1
\&  my $upcoming_dues = GetUpcomingDueIssues( { days_in_advance => 4 } );
.Ve
.SS "CanBookBeRenewed"
.IX Subsection "CanBookBeRenewed"
.Vb 1
\&  ($ok,$error,$info) = &CanBookBeRenewed($patron, $issue, $override_limit);
.Ve
.PP
Find out whether a borrowed item may be renewed.
.PP
\&\f(CW$patron\fR is the patron who currently has the issue.
.PP
\&\f(CW$issue\fR is the checkout to renew.
.PP
\&\f(CW$override_limit\fR, if supplied with a true value, causes
the limit on the number of times that the loan can be renewed
(as controlled by the item type) to be ignored. Overriding also allows
to renew sooner than \*(L"No renewal before\*(R" and to manually renew loans
that are automatically renewed.
.PP
\&\f(CW$CanBookBeRenewed\fR returns a true value if the item may be renewed. The
item must currently be on loan to the specified borrower; renewals
must be allowed for the item's type; and the borrower must not have
already renewed the loan.
    \f(CW$error\fR will contain the reason the renewal can not proceed
    \f(CW$info\fR will contain a hash of additional info
      currently 'soonest_renew_date' if error is 'too soon'
.SS "AddRenewal"
.IX Subsection "AddRenewal"
.Vb 1
\&  &AddRenewal($borrowernumber, $itemnumber, $branch, [$datedue], [$lastreneweddate], [$seen], [$automatic]);
.Ve
.PP
Renews a loan.
.PP
\&\f(CW$borrowernumber\fR is the borrower number of the patron who currently
has the item.
.PP
\&\f(CW$itemnumber\fR is the number of the item to renew.
.PP
\&\f(CW$branch\fR is the library where the renewal took place (if any).
           The library that controls the circ policies for the renewal is retrieved from the issues record.
.PP
\&\f(CW$datedue\fR can be a DateTime object used to set the due date.
.PP
\&\f(CW$lastreneweddate\fR is an optional ISO-formatted date used to set issues.lastreneweddate.  If
this parameter is not supplied, lastreneweddate is set to the current date.
.PP
\&\f(CW$skipfinecalc\fR is an optional boolean. There may be circumstances where, even if the
CalculateFinesOnReturn syspref is enabled, we don't want to calculate fines upon renew,
for example, when we're renewing as a result of a fine being paid (see RenewAccruingItemWhenPaid
syspref)
.PP
If \f(CW$datedue\fR is the empty string, \f(CW&AddRenewal\fR will calculate the due date automatically
from the book's item type.
.PP
\&\f(CW$seen\fR is a boolean flag indicating if the item was seen or not during the renewal. This
informs the incrementing of the unseen_renewals column. If this flag is not supplied, we
fallback to a true value
.PP
\&\f(CW$automatic\fR is a boolean flag indicating the renewal was triggered automatically and not by a person ( librarian or patron )
.PP
\&\f(CW$skip_record_index\fR is an optional boolean flag to indicate whether queuing the search indexing
should be skipped for this renewal.
.SS "GetSoonestRenewDate"
.IX Subsection "GetSoonestRenewDate"
.Vb 1
\&  $NoRenewalBeforeThisDate = &GetSoonestRenewDate($patron, $issue);
.Ve
.PP
Find out the soonest possible renew date of a borrowed item.
.PP
\&\f(CW$patron\fR is the patron who currently has the item on loan.
.PP
\&\f(CW$issue\fR is the the item issue.
.PP
\&\f(CW$GetSoonestRenewDate\fR returns the DateTime of the soonest possible
renew date, based on the value \*(L"No renewal before\*(R" of the applicable
issuing rule. Returns the current date if the item can already be
renewed, and returns undefined if the patron, item, or checkout
cannot be found.
.SS "GetLatestAutoRenewDate"
.IX Subsection "GetLatestAutoRenewDate"
.Vb 1
\&  $NoAutoRenewalAfterThisDate = &GetLatestAutoRenewDate($patron, $issue);
.Ve
.PP
Find out the latest possible auto renew date of a borrowed item.
.PP
\&\f(CW$patron\fR is the patron who currently has the item on loan.
.PP
\&\f(CW$issue\fR is the item issue.
.PP
\&\f(CW$GetLatestAutoRenewDate\fR returns the DateTime of the latest possible
auto renew date, based on the value \*(L"No auto renewal after\*(R" and the "No auto
renewal after (hard limit) of the applicable issuing rule.
Returns undef if there is no date specify in the circ rules or if the patron, loan,
or item cannot be found.
.SS "GetIssuingCharges"
.IX Subsection "GetIssuingCharges"
.Vb 1
\&  ($charge, $item_type) = &GetIssuingCharges($itemnumber, $borrowernumber);
.Ve
.PP
Calculate how much it would cost for a given patron to borrow a given
item, including any applicable discounts.
.PP
\&\f(CW$itemnumber\fR is the item number of item the patron wishes to borrow.
.PP
\&\f(CW$borrowernumber\fR is the patron's borrower number.
.PP
\&\f(CW&GetIssuingCharges\fR returns two values: \f(CW$charge\fR is the rental charge,
and \f(CW$item_type\fR is the code for the item's item type (e.g., \f(CW\*(C`VID\*(C'\fR
if it's a video).
.SS "AddIssuingCharge"
.IX Subsection "AddIssuingCharge"
.Vb 1
\&  &AddIssuingCharge( $checkout, $charge, $type )
.Ve
.SS "GetTransfersFromTo"
.IX Subsection "GetTransfersFromTo"
.Vb 1
\&  @results = GetTransfersFromTo($frombranch,$tobranch);
.Ve
.PP
Returns the list of pending transfers between \f(CW$from\fR and \f(CW$to\fR branch
.SS "SendCirculationAlert"
.IX Subsection "SendCirculationAlert"
Send out a \f(CW\*(C`check\-in\*(C'\fR or \f(CW\*(C`checkout\*(C'\fR alert using the messaging system.
.PP
\&\fBParameters\fR:
.IP "type" 4
.IX Item "type"
Valid values for this parameter are: \f(CW\*(C`CHECKIN\*(C'\fR and \f(CW\*(C`CHECKOUT\*(C'\fR.
.IP "item" 4
.IX Item "item"
Hashref of information about the item being checked in or out.
.IP "borrower" 4
.IX Item "borrower"
Hashref of information about the borrower of the item.
.IP "branch" 4
.IX Item "branch"
The branchcode from where the checkout or check-in took place.
.PP
\&\fBExample\fR:
.PP
.Vb 6
\&    SendCirculationAlert({
\&        type     => \*(AqCHECKOUT\*(Aq,
\&        item     => $item,
\&        borrower => $borrower,
\&        branch   => $branch,
\&    });
.Ve
.SS "updateWrongTransfer"
.IX Subsection "updateWrongTransfer"
.Vb 1
\&  $items = updateWrongTransfer($itemNumber,$borrowernumber,$waitingAtLibrary,$FromLibrary);
.Ve
.PP
This function validate the line of brachtransfer but with the wrong destination (mistake from a librarian ...), and create a new line in branchtransfer from the actual library to the original library of reservation
.SS "CalcDateDue"
.IX Subsection "CalcDateDue"
\&\f(CW$newdatedue\fR = CalcDateDue($startdate,$itemtype,$branchcode,$borrower);
.PP
this function calculates the due date given the start date and configured circulation rules,
checking against the holidays calendar as per the daysmode circulation rule.
\&\f(CW$startdate\fR   = DateTime object representing start date of loan period (assumed to be today)
\&\f(CW$itemtype\fR  = itemtype code of item in question
\&\f(CW$branch\fR  = location whose calendar to use
\&\f(CW$borrower\fR = Borrower object
\&\f(CW$isrenewal\fR = Boolean: is true if we want to calculate the date due for a renewal. Else is false.
.SS "IsBranchTransferAllowed"
.IX Subsection "IsBranchTransferAllowed"
.Vb 1
\&  $allowed = IsBranchTransferAllowed( $toBranch, $fromBranch, $code );
.Ve
.PP
Code is either an itemtype or collection doe depending on the pref BranchTransferLimitsType
.PP
Deprecated in favor of Koha::Item::Transfer::Limits\->find/search and
Koha::Item\->can_be_transferred.
.SS "CreateBranchTransferLimit"
.IX Subsection "CreateBranchTransferLimit"
.Vb 1
\&  CreateBranchTransferLimit( $toBranch, $fromBranch, $code );
.Ve
.PP
\&\f(CW$code\fR is either itemtype or collection code depending on what the pref BranchTransferLimitsType is set to.
.PP
Deprecated in favor of Koha::Item::Transfer::Limit\->new.
.SS "DeleteBranchTransferLimits"
.IX Subsection "DeleteBranchTransferLimits"
.Vb 1
\&    my $result = DeleteBranchTransferLimits($frombranch);
.Ve
.PP
Deletes all the library transfer limits for one library.  Returns the
number of limits deleted, 0e0 if no limits were deleted, or undef if
no arguments are supplied.
.PP
Deprecated in favor of Koha::Item::Transfer::Limits\->search({
    fromBranch => \f(CW$fromBranch\fR
    })\->delete.
.SS "LostItem"
.IX Subsection "LostItem"
.Vb 1
\&  LostItem( $itemnumber, $mark_lost_from, $force_mark_returned, [$params] );
.Ve
.PP
The final optional parameter, \f(CW$params\fR, expected to contain
\&'skip_record_index' key, which relayed down to Koha::Item/store,
there it prevents calling of ModZebra index_records,
which takes most of the time in batch adds/deletes: index_records better
to be called later in \f(CW\*(C`additem.pl\*(C'\fR after the whole loop.
.PP
\&\f(CW$params:\fR
    skip_record_index => 1|0
.SS "TransferSlip"
.IX Subsection "TransferSlip"
.Vb 1
\&  TransferSlip($user_branch, $itemnumber, $barcode, $to_branch)
\&
\&  Returns letter hash ( see C4::Letters::GetPreparedLetter ) or undef
.Ve
.SS "CheckIfIssuedToPatron"
.IX Subsection "CheckIfIssuedToPatron"
.Vb 1
\&  CheckIfIssuedToPatron($borrowernumber, $biblionumber)
\&
\&  Return 1 if any record item is issued to patron, otherwise return 0
.Ve
.SS "IsItemIssued"
.IX Subsection "IsItemIssued"
.Vb 1
\&  IsItemIssued( $itemnumber )
\&
\&  Return 1 if the item is on loan, otherwise return 0
.Ve
.SS "GetAgeRestriction"
.IX Subsection "GetAgeRestriction"
.Vb 2
\&  my ($ageRestriction, $daysToAgeRestriction) = GetAgeRestriction($record_restrictions, $borrower);
\&  my ($ageRestriction, $daysToAgeRestriction) = GetAgeRestriction($record_restrictions);
\&
\&  if($daysToAgeRestriction <= 0) { #Borrower is allowed to access this material, as they are older or as old as the agerestriction }
\&  if($daysToAgeRestriction > 0) { #Borrower is this many days from meeting the agerestriction }
.Ve
.PP
\&\f(CW@PARAM1\fR the koha.biblioitems.agerestriction value, like K18, \s-1PEGI 13, ...\s0
\&\f(CW@PARAM2\fR a borrower-object with koha.borrowers.dateofbirth. (\s-1OPTIONAL\s0)
\&\f(CW@RETURNS\fR The age restriction age in years and the days to fulfill the age restriction for the given borrower.
         Negative days mean the borrower has gone past the age restriction age.
.SS "GetPendingOnSiteCheckouts"
.IX Subsection "GetPendingOnSiteCheckouts"
.SS "Internal methods"
.IX Subsection "Internal methods"
.SH "AUTHOR"
.IX Header "AUTHOR"
Koha Development Team <http://koha\-community.org/>
