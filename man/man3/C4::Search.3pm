.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "C4::Search 3pm"
.TH C4::Search 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::Search \- Functions for searching the Koha catalog.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See opac/opac\-search.pl or catalogue/search.pl for example of usage
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides searching functions for Koha's bibliographic databases
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "FindDuplicate"
.IX Subsection "FindDuplicate"
($biblionumber,$biblionumber,$title) = FindDuplicate($record);
.PP
This function attempts to find duplicate records using a hard-coded, fairly simplistic algorithm
.SS "SimpleSearch"
.IX Subsection "SimpleSearch"
( \f(CW$error\fR, \f(CW$results\fR, \f(CW$total_hits\fR ) = SimpleSearch( \f(CW$query\fR, \f(CW$offset\fR, \f(CW$max_results\fR, [@servers], [%options] );
.PP
This function provides a simple search \s-1API\s0 on the bibliographic catalog
.ie n .IP """input arg:""" 2
.el .IP "\f(CWinput arg:\fR" 2
.IX Item "input arg:"
.Vb 5
\&    * $query can be a simple keyword or a complete CCL query
\&    * @servers is optional. Defaults to biblioserver as found in koha\-conf.xml
\&    * $offset \- If present, represents the number of records at the beginning to omit. Defaults to 0
\&    * $max_results \- if present, determines the maximum number of records to fetch. undef is All. defaults to undef.
\&    * %options is optional. (e.g. "skip_normalize" allows you to skip changing : to = )
.Ve
.ie n .IP """Return:""" 2
.el .IP "\f(CWReturn:\fR" 2
.IX Item "Return:"
.Vb 4
\&    Returns an array consisting of three elements
\&    * $error is undefined unless an error is detected
\&    * $results is a reference to an array of records.
\&    * $total_hits is the number of hits that would have been returned with no limit
\&
\&    If an error is returned the two other return elements are undefined. If error itself is undefined
\&    the other two elements are always defined
.Ve
.ie n .IP """usage in the script:""" 2
.el .IP "\f(CWusage in the script:\fR" 2
.IX Item "usage in the script:"
.PP
my ( \f(CW$error\fR, \f(CW$marcresults\fR, \f(CW$total_hits\fR ) = SimpleSearch($query);
.PP
if (defined \f(CW$error\fR) {
    \f(CW$template\fR\->param(query_error => \f(CW$error\fR);
    warn \*(L"error: \*(R".$error;
    output_html_with_http_headers \f(CW$input\fR, \f(CW$cookie\fR, \f(CW$template\fR\->output;
    exit;
}
.PP
my \f(CW$hits\fR = @{$marcresults};
my \f(CW@results\fR;
.PP
for my \f(CW$r\fR ( @{$marcresults} ) {
    my \f(CW$marcrecord\fR = MARC::File::USMARC::decode($r);
    my \f(CW$biblio\fR = TransformMarcToKoha({ record => \f(CW$marcrecord\fR });
.PP
.Vb 9
\&    #build the iarray of hashs for the template.
\&    push @results, {
\&        title           => $biblio\->{\*(Aqtitle\*(Aq},
\&        subtitle        => $biblio\->{\*(Aqsubtitle\*(Aq},
\&        biblionumber    => $biblio\->{\*(Aqbiblionumber\*(Aq},
\&        author          => $biblio\->{\*(Aqauthor\*(Aq},
\&        publishercode   => $biblio\->{\*(Aqpublishercode\*(Aq},
\&        publicationyear => $biblio\->{\*(Aqpublicationyear\*(Aq},
\&        };
.Ve
.PP
}
.PP
\&\f(CW$template\fR\->param(result=>\e@results);
.SS "getRecords"
.IX Subsection "getRecords"
( undef, \f(CW$results_hashref\fR, \e@facets_loop ) = getRecords (
.PP
.Vb 4
\&        $koha_query,       $simple_query, $sort_by_ref,    $servers_ref,
\&        $results_per_page, $offset,       $branches,       $itemtypes,
\&        $query_type,       $scan,         $opac
\&    );
.Ve
.PP
The all singing, all dancing, multi-server, asynchronous, scanning,
searching, record nabbing, facet-building
.PP
See verbose embedded documentation.
.SS "_get_facets_data_from_record"
.IX Subsection "_get_facets_data_from_record"
.Vb 1
\&    C4::Search::_get_facets_data_from_record( $marc_record, $facets, $facets_counter );
.Ve
.PP
Internal function that extracts facets information from a MARC::Record object
and populates \f(CW$facets_counter\fR for using in getRecords.
.PP
\&\f(CW$facets\fR is expected to be filled with C4::Koha::getFacets output (i.e. the configured
facets for Zebra).
.SS "_get_facets_from_zebra"
.IX Subsection "_get_facets_from_zebra"
.Vb 1
\&    my $facets = _get_facets_from_zebra( $result_set )
.Ve
.PP
Retrieves facets for a specified result set. It loops through the facets defined
in C4::Koha::getFacets and returns a hash with the following structure:
.PP
.Vb 5
\&   {  facet_idx => {
\&            facet_value => count
\&      },
\&      ...
\&   }
.Ve
.SS "_get_facet_from_result_set"
.IX Subsection "_get_facet_from_result_set"
.Vb 2
\&    my $facet_values =
\&        C4::Search::_get_facet_from_result_set( $facet_idx, $result_set, $sep )
.Ve
.PP
Internal function that extracts facet information for a specific index ($facet_idx) and
returns a hash containing facet values and count:
.PP
.Vb 4
\&    {
\&        $facet_value => $count ,
\&        ...
\&    }
.Ve
.PP
Warning: this function has the side effect of changing the elementSetName for the result
set. It is a helper function for the main loop, which takes care of backing it up for
restoring.
.SS "_get_facets_info"
.IX Subsection "_get_facets_info"
.Vb 1
\&    my $facets_info = C4::Search::_get_facets_info( $facets )
.Ve
.PP
Internal function that extracts facets information and properly builds
the data structure needed to render facet labels.
.SS "getIndexes"
.IX Subsection "getIndexes"
Return an array with available indexes.
.SS "buildQuery"
.IX Subsection "buildQuery"
( \f(CW$error\fR, \f(CW$query\fR,
\&\f(CW$simple_query\fR, \f(CW$query_cgi\fR,
\&\f(CW$query_desc\fR, \f(CW$limit\fR,
\&\f(CW$limit_cgi\fR, \f(CW$limit_desc\fR,
\&\f(CW$query_type\fR ) = buildQuery ( \f(CW$operators\fR, \f(CW$operands\fR, \f(CW$indexes\fR, \f(CW$limits\fR, \f(CW$sort_by\fR, \f(CW$scan\fR, \f(CW$lang\fR);
.PP
Build queries and limits in \s-1CCL, CGI,\s0 Human,
handle truncation, stemming, field weighting, fuzziness, etc.
.PP
See verbose embedded documentation.
.SS "_build_initial_query"
.IX Subsection "_build_initial_query"
.Vb 1
\&  ($query, $query_cgi, $query_desc, $previous_operand) = _build_initial_query($initial_query_params);
\&
\&  Build a section of the initial query containing indexes, operators, and operands.
.Ve
.SS "searchResults"
.IX Subsection "searchResults"
.Vb 3
\&  my @search_results = searchResults($search_context, $searchdesc, $hits, 
\&                                     $results_per_page, $offset, $scan, 
\&                                     @marcresults);
.Ve
.PP
Format results in a form suitable for passing to the template
.SS "enabled_staff_search_views"
.IX Subsection "enabled_staff_search_views"
\&\f(CW%hash\fR = \fBenabled_staff_search_views()\fR
.PP
This function returns a hash that contains three flags obtained from the system
preferences, used to determine whether a particular staff search results view
is enabled.
.ie n .IP """Output arg:""" 2
.el .IP "\f(CWOutput arg:\fR" 2
.IX Item "Output arg:"
.Vb 3
\&    * $hash{can_view_MARC} is true only if the MARC view is enabled
\&    * $hash{can_view_ISBD} is true only if the ISBD view is enabled
\&    * $hash{can_view_labeledMARC} is true only if the Labeled MARC view is enabled
.Ve
.ie n .IP """usage in the script:""" 2
.el .IP "\f(CWusage in the script:\fR" 2
.IX Item "usage in the script:"
.PP
\&\f(CW$template\fR\->param ( C4::Search::enabled_staff_search_views );
.SS "z3950_search_args"
.IX Subsection "z3950_search_args"
\&\f(CW$arrayref\fR = z3950_search_args($matchpoints)
.PP
This function returns an array reference that contains the search parameters to be
passed to the Z39.50 search script (z3950_search.pl). The array elements
are hash refs whose keys are name and value, and whose values are the
name of a search parameter, the value of that search parameter and the \s-1URL\s0 encoded
value of that parameter.
.PP
The search parameter names are lccn, isbn, issn, title, author, dewey and subject.
.PP
The search parameter values are obtained from the bibliographic record whose
data is in a hash reference in \f(CW$matchpoints\fR, as returned by \fBBiblio::GetBiblioData()\fR.
.PP
If \f(CW$matchpoints\fR is a scalar, it is assumed to be an unnamed query descriptor, e.g.
a general purpose search argument. In this case, the returned array contains only
entry: the key is 'title' and the value is derived from \f(CW$matchpoints\fR.
.PP
If a search parameter value is undefined or empty, it is not included in the returned
array.
.PP
The returned array reference may be passed directly to the template parameters.
.ie n .IP """Output arg:""" 2
.el .IP "\f(CWOutput arg:\fR" 2
.IX Item "Output arg:"
.Vb 1
\&    * $array containing hash refs as described above
.Ve
.ie n .IP """usage in the script:""" 2
.el .IP "\f(CWusage in the script:\fR" 2
.IX Item "usage in the script:"
.PP
\&\f(CW$data\fR = Biblio::GetBiblioData($bibno);
\&\f(CW$template\fR\->param ( \s-1MYLOOP\s0 => C4::Search::z3950_search_args($data) )
.PP
*OR*
.PP
\&\f(CW$template\fR\->param ( \s-1MYLOOP\s0 => C4::Search::z3950_search_args($searchscalar) )
.SS "GetDistinctValues($field);"
.IX Subsection "GetDistinctValues($field);"
\&\f(CW$field\fR is a reference to the fields array
.SS "_ZOOM_event_loop"
.IX Subsection "_ZOOM_event_loop"
.Vb 4
\&    _ZOOM_event_loop(\e@zconns, \e@results, sub {
\&        my ( $i, $size ) = @_;
\&        ....
\&    } );
.Ve
.PP
Processes a \s-1ZOOM\s0 event loop and passes control to a closure for
processing the results, and destroying the resultsets.
.SS "new_record_from_zebra"
.IX Subsection "new_record_from_zebra"
Given raw data from a searchengine result set, return a MARC::Record object
.PP
This helper function is needed to take into account all the involved
system preferences and configuration variables to properly create the
MARC::Record object.
.PP
If we are using \s-1GRS\-1,\s0 then the raw data we get from Zebra should be \s-1USMARC\s0
data. If we are using \s-1DOM,\s0 then it has to be \s-1MARCXML.\s0
.PP
If we are using elasticsearch, it'll already be a MARC::Record and this
function needs a new name.
.SH "AUTHOR"
.IX Header "AUTHOR"
Koha Development Team <http://koha\-community.org/>
