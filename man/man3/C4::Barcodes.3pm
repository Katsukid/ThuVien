.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "C4::Barcodes 3pm"
.TH C4::Barcodes 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Barcodes"
.IX Header "Barcodes"
Note that the object returned by new is actually of the type requested (or set by syspref).
For example, C4::Barcodes::annual
.PP
The specific C4::Barcodes::* modules correspond to the autoBarcode syspref values.
.PP
The default behavior here in Barcodes should be essentially a more flexible version of \*(L"incremental\*(R".
.SH "Adding New Barcode Types"
.IX Header "Adding New Barcode Types"
To add a new barcode format, a developer should:
.PP
.Vb 4
\&        create a module in C4/Barcodes/, like C4/Barcodes/my_new_format.pm;
\&        add to the $types hashref in this file; 
\&        add tests under the "t" directory; and
\&        edit autoBarcode syspref to include new type.
.Ve
.SS "Adding a new module"
.IX Subsection "Adding a new module"
Each new module that needs differing behavior must override these subs:
.PP
.Vb 4
\&        new_object
\&        initial
\&        db_max
\&        parse
.Ve
.PP
Or else the \s-1CLASS\s0 subs will be used.
.ie n .SS "$types hashref"
.el .SS "\f(CW$types\fP hashref"
.IX Subsection "$types hashref"
The hash referenced can be thought of as the constructor farm for all the C4::Barcodes types.  
Each value should be a reference to a sub that calls the module constructor.
.SH "Notes"
.IX Header "Notes"
You would think it might be easy to handle incremental barcodes, but in practice even commonly used values,
like the \s-1IBM\s0 \*(L"Boulder\*(R" format can cause problems for sprintf.  Basically, the value is too large for the 
\&\f(CW%d\fR version of an integer, and we cannot count on perl having been compiled with support for quads 
(64\-bit integers).  So we have to use floats or increment a piece of it and return the rejoined fragments.
