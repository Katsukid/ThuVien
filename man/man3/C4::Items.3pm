.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "C4::Items 3pm"
.TH C4::Items 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::Items \- item management functions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module contains an \s-1API\s0 for manipulating item 
records in Koha, and is used by cataloguing, circulation,
acquisitions, and serials management.
.PP
# \s-1FIXME\s0 This \s-1POD\s0 is not up-to-date
A Koha item record is stored in two places: the
items table and embedded in a \s-1MARC\s0 tag in the \s-1XML\s0
version of the associated bib record in \f(CW\*(C`biblioitems.marcxml\*(C'\fR.
This is done to allow the item information to be readily
indexed (e.g., by Zebra), but means that each item
modification transaction must keep the items table
and the \s-1MARC XML\s0 in sync at all times.
.PP
The items table will be considered authoritative.  In other
words, if there is ever a discrepancy between the items
table and the \s-1MARC XML,\s0 the items table should be considered
accurate.
.SH "HISTORICAL NOTE"
.IX Header "HISTORICAL NOTE"
Most of the functions in \f(CW\*(C`C4::Items\*(C'\fR were originally in
the \f(CW\*(C`C4::Biblio\*(C'\fR module.
.SH "CORE EXPORTED FUNCTIONS"
.IX Header "CORE EXPORTED FUNCTIONS"
The following functions are meant for use by users
of \f(CW\*(C`C4::Items\*(C'\fR
.SS "CartToShelf"
.IX Subsection "CartToShelf"
.Vb 1
\&  CartToShelf($itemnumber);
.Ve
.PP
Set the current shelving location of the item record
to its stored permanent shelving location.  This is
primarily used to indicate when an item whose current
location is a special processing ('\s-1PROC\s0') or shelving cart
('\s-1CART\s0') location is back in the stacks.
.SS "AddItemFromMarc"
.IX Subsection "AddItemFromMarc"
.Vb 2
\&  my ($biblionumber, $biblioitemnumber, $itemnumber) 
\&      = AddItemFromMarc($source_item_marc, $biblionumber[, $params]);
.Ve
.PP
Given a MARC::Record object containing an embedded item
record and a biblionumber, create a new item record.
.PP
The final optional parameter, \f(CW$params\fR, may contain
\&'skip_record_index' key, which relayed down to Koha::Item/store,
there it prevents calling of index_records,
which takes most of the time in batch adds/deletes: index_records
to be called later in \f(CW\*(C`additem.pl\*(C'\fR after the whole loop.
.PP
You may also optionally pass biblioitemnumber in the params hash to
boost performance of inserts by preventing a lookup in Koha::Item.
.PP
\&\f(CW$params:\fR
    skip_record_index => 1|0
    biblioitemnumber => \f(CW$biblioitemnumber\fR
.SS "AddItemBatchFromMarc"
.IX Subsection "AddItemBatchFromMarc"
.Vb 2
\&  ($itemnumber_ref, $error_ref) = AddItemBatchFromMarc($record, 
\&             $biblionumber, $biblioitemnumber, $frameworkcode);
.Ve
.PP
Efficiently create item records from a \s-1MARC\s0 biblio record with
embedded item fields.  This routine is suitable for batch jobs.
.PP
This \s-1API\s0 assumes that the bib record has already been
saved to the \f(CW\*(C`biblio\*(C'\fR and \f(CW\*(C`biblioitems\*(C'\fR tables.  It does
not expect that \f(CW\*(C`biblio_metadata.metadata\*(C'\fR is populated, but it
will do so via a call to ModBibiloMarc.
.PP
The goal of this \s-1API\s0 is to have a similar effect to using AddBiblio
and AddItems in succession, but without inefficient repeated
parsing of the \s-1MARC XML\s0 bib record.
.PP
This function returns an arrayref of new itemsnumbers and an arrayref of item
errors encountered during the processing.  Each entry in the errors
list is a hashref containing the following keys:
.IP "item_sequence" 4
.IX Item "item_sequence"
Sequence number of original item tag in the \s-1MARC\s0 record.
.IP "item_barcode" 4
.IX Item "item_barcode"
Item barcode, provide to assist in the construction of
useful error messages.
.IP "error_code" 4
.IX Item "error_code"
Code representing the error condition.  Can be 'duplicate_barcode',
\&'invalid_homebranch', or 'invalid_holdingbranch'.
.IP "error_information" 4
.IX Item "error_information"
Additional information appropriate to the error condition.
.SS "ModItemFromMarc"
.IX Subsection "ModItemFromMarc"
my \f(CW$item\fR = ModItemFromMarc($item_marc, \f(CW$biblionumber\fR, \f(CW$itemnumber\fR[, \f(CW$params\fR]);
.PP
The final optional parameter, \f(CW$params\fR, expected to contain
\&'skip_record_index' key, which relayed down to Koha::Item/store,
there it prevents calling of index_records,
which takes most of the time in batch adds/deletes: index_records better
to be called later in \f(CW\*(C`additem.pl\*(C'\fR after the whole loop.
.PP
\&\f(CW$params:\fR
    skip_record_index => 1|0
.SS "ModItemTransfer"
.IX Subsection "ModItemTransfer"
.Vb 1
\&  ModItemTransfer($itemnumber, $frombranch, $tobranch, $trigger, [$params]);
.Ve
.PP
Marks an item as being transferred from one branch to another and records the trigger.
.PP
The last optional parameter allows for passing skip_record_index through to the items store call.
.SS "ModDateLastSeen"
.IX Subsection "ModDateLastSeen"
ModDateLastSeen( \f(CW$itemnumber\fR, \f(CW$leave_item_lost\fR, \f(CW$params\fR );
.PP
Mark item as seen. Is called when an item is issued, returned or manually marked during inventory/stocktaking.
\&\f(CW$itemnumber\fR is the item number
\&\f(CW$leave_item_lost\fR determines if a lost item will be found or remain lost
.PP
The last optional parameter allows for passing skip_record_index through to the items store call.
.SS "CheckItemPreSave"
.IX Subsection "CheckItemPreSave"
.Vb 12
\&    my $item_ref = TransformMarcToKoha({ record => $marc, limit_table => \*(Aqitems\*(Aq });
\&    # do stuff
\&    my %errors = CheckItemPreSave($item_ref);
\&    if (exists $errors{\*(Aqduplicate_barcode\*(Aq}) {
\&        print "item has duplicate barcode: ", $errors{\*(Aqduplicate_barcode\*(Aq}, "\en";
\&    } elsif (exists $errors{\*(Aqinvalid_homebranch\*(Aq}) {
\&        print "item has invalid home branch: ", $errors{\*(Aqinvalid_homebranch\*(Aq}, "\en";
\&    } elsif (exists $errors{\*(Aqinvalid_holdingbranch\*(Aq}) {
\&        print "item has invalid holding branch: ", $errors{\*(Aqinvalid_holdingbranch\*(Aq}, "\en";
\&    } else {
\&        print "item is OK";
\&    }
.Ve
.PP
Given a hashref containing item fields, determine if it can be
inserted or updated in the database.  Specifically, checks for
database integrity issues, and returns a hash containing any
of the following keys, if applicable.
.IP "duplicate_barcode" 2
.IX Item "duplicate_barcode"
Barcode, if it duplicates one already found in the database.
.IP "invalid_homebranch" 2
.IX Item "invalid_homebranch"
Home branch, if not defined in branches table.
.IP "invalid_holdingbranch" 2
.IX Item "invalid_holdingbranch"
Holding branch, if not defined in branches table.
.PP
This function does \s-1NOT\s0 implement any policy-related checks,
e.g., whether current operator is allowed to save an
item that has a given branch code.
.SH "EXPORTED SPECIAL ACCESSOR FUNCTIONS"
.IX Header "EXPORTED SPECIAL ACCESSOR FUNCTIONS"
The following functions provide various ways of 
getting an item record, a set of item records, or
lists of authorized values for certain item fields.
.SS "GetItemsForInventory"
.IX Subsection "GetItemsForInventory"
($itemlist, \f(CW$iTotalRecords\fR) = GetItemsForInventory( {
  minlocation  => \f(CW$minlocation\fR,
  maxlocation  => \f(CW$maxlocation\fR,
  location     => \f(CW$location\fR,
  ignoreissued => \f(CW$ignoreissued\fR,
  datelastseen => \f(CW$datelastseen\fR,
  branchcode   => \f(CW$branchcode\fR,
  branch       => \f(CW$branch\fR,
  offset       => \f(CW$offset\fR,
  size         => \f(CW$size\fR,
  statushash   => \f(CW$statushash\fR,
  itemtypes    => \e@itemsarray,
} );
.PP
Retrieve a list of title/authors/barcode/callnumber, for biblio inventory.
.PP
The sub returns a reference to a list of hashes, each containing
itemnumber, author, title, barcode, item callnumber, and date last
seen. It is ordered by callnumber then title.
.PP
The required minlocation & maxlocation parameters are used to specify a range of item callnumbers
the datelastseen can be used to specify that you want to see items not seen since a past date only.
offset & size can be used to retrieve only a part of the whole listing (defaut behaviour)
\&\f(CW$statushash\fR requires a hashref that has the authorized values fieldname (intems.notforloan, etc...) as keys, and an arrayref of statuscodes we are searching for as values.
.PP
\&\f(CW$iTotalRecords\fR is the number of rows that would have been returned without the \f(CW$offset\fR, \f(CW$size\fR limit clause
.SS "get_hostitemnumbers_of"
.IX Subsection "get_hostitemnumbers_of"
.Vb 1
\&  my @itemnumbers_of = get_hostitemnumbers_of($biblionumber);
.Ve
.PP
Given a biblionumber, return the list of corresponding itemnumbers that are linked to it via host fields
.PP
Return a reference on a hash where key is a biblionumber and values are
references on array of itemnumbers.
.SH "LIMITED USE FUNCTIONS"
.IX Header "LIMITED USE FUNCTIONS"
The following functions, while part of the public \s-1API,\s0
are not exported.  This is generally because they are
meant to be used by only one script for a specific
purpose, and should not be used in any other context
without careful thought.
.SS "GetMarcItem"
.IX Subsection "GetMarcItem"
.Vb 1
\&  my $item_marc = GetMarcItem($biblionumber, $itemnumber);
.Ve
.PP
Returns MARC::Record of the item passed in parameter.
This function is meant for use only in \f(CW\*(C`cataloguing/additem.pl\*(C'\fR,
where it is needed to support that script's MARC-like
editor.
.SH "PRIVATE FUNCTIONS AND VARIABLES"
.IX Header "PRIVATE FUNCTIONS AND VARIABLES"
The following functions are not meant to be called
directly, but are documented in order to explain
the inner workings of \f(CW\*(C`C4::Items\*(C'\fR.
.SS "_marc_from_item_hash"
.IX Subsection "_marc_from_item_hash"
.Vb 1
\&  my $item_marc = _marc_from_item_hash($item, $frameworkcode[, $unlinked_item_subfields]);
.Ve
.PP
Given an item hash representing a complete item record,
create a \f(CW\*(C`MARC::Record\*(C'\fR object containing an embedded
tag representing that item.
.PP
The third, optional parameter \f(CW$unlinked_item_subfields\fR is
an arrayref of subfields (not mapped to \f(CW\*(C`items\*(C'\fR fields per the
framework) to be added to the \s-1MARC\s0 representation
of the item.
.SS "_repack_item_errors"
.IX Subsection "_repack_item_errors"
Add an error message hash generated by \f(CW\*(C`CheckItemPreSave\*(C'\fR
to a list of errors.
.SS "_get_unlinked_item_subfields"
.IX Subsection "_get_unlinked_item_subfields"
.Vb 1
\&  my $unlinked_item_subfields = _get_unlinked_item_subfields($original_item_marc, $frameworkcode);
.Ve
.SS "_get_unlinked_subfields_xml"
.IX Subsection "_get_unlinked_subfields_xml"
.Vb 1
\&  my $unlinked_subfields_xml = _get_unlinked_subfields_xml($unlinked_item_subfields);
.Ve
.SS "_parse_unlinked_item_subfields_from_xml"
.IX Subsection "_parse_unlinked_item_subfields_from_xml"
.Vb 1
\&  my $unlinked_item_subfields = _parse_unlinked_item_subfields_from_xml($whole_item\->{\*(Aqmore_subfields_xml\*(Aq}):
.Ve
.SS "GetAnalyticsCount"
.IX Subsection "GetAnalyticsCount"
.Vb 1
\&  $count= &GetAnalyticsCount($itemnumber)
.Ve
.PP
counts Usage of itemnumber in Analytical bibliorecords.
.SS "SearchItems"
.IX Subsection "SearchItems"
.Vb 1
\&    my ($items, $total) = SearchItems($filter, $params);
.Ve
.PP
Perform a search among items
.PP
\&\f(CW$filter\fR is a reference to a hash which can be a filter, or a combination of filters.
.PP
A filter has the following keys:
.IP "\(bu" 2
field: the name of a \s-1SQL\s0 column in table items
.IP "\(bu" 2
query: the value to search in this column
.IP "\(bu" 2
operator: comparison operator. Can be one of = != > < >= <= like 'not like' is
.PP
A combination of filters hash the following keys:
.IP "\(bu" 2
conjunction: '\s-1AND\s0' or '\s-1OR\s0'
.IP "\(bu" 2
filters: array ref of filters
.PP
\&\f(CW$params\fR is a reference to a hash that can contain the following parameters:
.IP "\(bu" 2
rows: Number of items to return. 0 returns everything (default: 0)
.IP "\(bu" 2
page: Page to return (return items from (page\-1)*rows to (page*rows)\-1)
               (default: 1)
.IP "\(bu" 2
sortby: A \s-1SQL\s0 column name in items table to sort on
.IP "\(bu" 2
sortorder: '\s-1ASC\s0' or '\s-1DESC\s0'
.SH "OTHER FUNCTIONS"
.IX Header "OTHER FUNCTIONS"
.SS "_find_value"
.IX Subsection "_find_value"
.Vb 1
\&  ($indicators, $value) = _find_value($tag, $subfield, $record,$encoding);
.Ve
.PP
Find the given \f(CW$subfield\fR in the given \f(CW$tag\fR in the given
MARC::Record \f(CW$record\fR.  If the subfield is found, returns
the (indicators, value) pair; otherwise, (undef, undef) is
returned.
.PP
\&\s-1PROPOSITION :\s0
Such a function is used in addbiblio \s-1AND\s0 additem and serial-edit and maybe could be used in Authorities.
I suggest we export it from this module.
.SS "PrepareItemrecordDisplay"
.IX Subsection "PrepareItemrecordDisplay"
.Vb 1
\&  PrepareItemrecordDisplay($bibnum,$itemumber,$defaultvalues,$frameworkcode);
.Ve
.PP
Returns a hash with all the fields for Display a given item data in a template
.PP
\&\f(CW$defaultvalues\fR should either contain a hashref of values for the new item, or be undefined.
.PP
The \f(CW$frameworkcode\fR returns the item for the given frameworkcode, \s-1ONLY\s0 if bibnum is not provided
