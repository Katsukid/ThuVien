.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "C4::Context 3pm"
.TH C4::Context 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::Context \- Maintain and manipulate the context of a Koha script
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use C4::Context;
\&
\&  use C4::Context("/path/to/koha\-conf.xml");
\&
\&  $config_value = C4::Context\->config("config_variable");
\&
\&  $koha_preference = C4::Context\->preference("preference");
\&
\&  $db_handle = C4::Context\->dbh;
\&
\&  $Zconn = C4::Context\->Zconn;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
When a Koha script runs, it makes use of a certain number of things:
configuration settings in \fI/etc/koha/koha\-conf.xml\fR, a connection to the Koha
databases, and so forth. These things make up the \fIcontext\fR in which
the script runs.
.PP
This module takes care of setting up the context for a script:
figuring out which configuration file to load, and loading it, opening
a connection to the right database, and so forth.
.PP
Most scripts will only use one context. They can simply have
.PP
.Vb 1
\&  use C4::Context;
.Ve
.PP
at the top.
.PP
Other scripts may need to use several contexts. For instance, if a
library has two databases, one for a certain collection, and the other
for everything else, it might be necessary for a script to use two
different contexts to search both databases. Such scripts should use
the \f(CW&set_context\fR and \f(CW&restore_context\fR functions, below.
.PP
By default, C4::Context reads the configuration from
\&\fI/etc/koha/koha\-conf.xml\fR. This may be overridden by setting the \f(CW$KOHA_CONF\fR
environment variable to the pathname of a configuration file to use.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 2
\&  $context = C4::Context\->new;
\&  $context = C4::Context\->new("/path/to/koha\-conf.xml");
.Ve
.PP
Allocates a new context. Initializes the context from the specified
file, which defaults to either the file given by the \f(CW$KOHA_CONF\fR
environment variable, or \fI/etc/koha/koha\-conf.xml\fR.
.PP
It saves the koha\-conf.xml values in the declared memcached server(s)
if currently available and uses those values until them expire and
re-reads them.
.PP
\&\f(CW&new\fR does not set this context as the new default context; for
that, use \f(CW&set_context\fR.
.SS "set_context"
.IX Subsection "set_context"
.Vb 4
\&  $context = new C4::Context;
\&  $context\->set_context();
\&or
\&  set_context C4::Context $context;
\&
\&  ...
\&  restore_context C4::Context;
.Ve
.PP
In some cases, it might be necessary for a script to use multiple
contexts. \f(CW&set_context\fR saves the current context on a stack, then
sets the context to \f(CW$context\fR, which will be used in future
operations. To restore the previous context, use \f(CW&restore_context\fR.
.SS "restore_context"
.IX Subsection "restore_context"
.Vb 1
\&  &restore_context;
.Ve
.PP
Restores the context set by \f(CW&set_context\fR.
.SS "config"
.IX Subsection "config"
.Vb 1
\&  $value = C4::Context\->config("config_variable");
.Ve
.PP
Returns the value of a variable specified in the configuration file
from which the current context was created.
.SS "preference"
.IX Subsection "preference"
.Vb 1
\&  $sys_preference = C4::Context\->preference(\*(Aqsome_variable\*(Aq);
.Ve
.PP
Looks up the value of the given system preference in the
systempreferences table of the Koha database, and returns it. If the
variable is not set or does not exist, undef is returned.
.PP
In case of an error, this may return 0.
.PP
Note: It is impossible to tell the difference between system
preferences which do not exist, and those whose values are set to \s-1NULL\s0
with this method.
.SS "yaml_preference"
.IX Subsection "yaml_preference"
Retrieves the required system preference value, and converts it
from \s-1YAML\s0 into a Perl data structure. It throws an exception if
the value cannot be properly decoded as \s-1YAML.\s0
.SS "enable_syspref_cache"
.IX Subsection "enable_syspref_cache"
.Vb 1
\&  C4::Context\->enable_syspref_cache();
.Ve
.PP
Enable the in-memory syspref cache used by C4::Context. This is the
default behavior.
.SS "disable_syspref_cache"
.IX Subsection "disable_syspref_cache"
.Vb 1
\&  C4::Context\->disable_syspref_cache();
.Ve
.PP
Disable the in-memory syspref cache used by C4::Context. This should be
used with Plack and other persistent environments.
.SS "clear_syspref_cache"
.IX Subsection "clear_syspref_cache"
.Vb 1
\&  C4::Context\->clear_syspref_cache();
.Ve
.PP
cleans the internal cache of sysprefs. Please call this method if
you update the systempreferences table. Otherwise, your new changes
will not be seen by this process.
.SS "set_preference"
.IX Subsection "set_preference"
.Vb 1
\&  C4::Context\->set_preference( $variable, $value, [ $explanation, $type, $options ] );
.Ve
.PP
This updates a preference's value both in the systempreferences table and in
the sysprefs cache. If the optional parameters are provided, then the query
becomes a create. It won't update the parameters (except value) for an existing
preference.
.SS "delete_preference"
.IX Subsection "delete_preference"
.Vb 1
\&    C4::Context\->delete_preference( $variable );
.Ve
.PP
This deletes a system preference from the database. Returns a true value on
success. Failure means there was an issue with the database, not that there
was no syspref of the name.
.SS "csv_delimiter"
.IX Subsection "csv_delimiter"
.Vb 1
\&    $delimiter = C4::Context\->csv_delimiter;
\&
\&    Returns preferred CSV delimiter, using system preference \*(AqCSVDelimiter\*(Aq.
\&    If this preference is missing or empty, comma will be returned.
\&    This method is needed because of special behavior for tabulation.
\&
\&    You can, optionally, pass a value parameter to this routine
\&    in the case of existing delimiter.
.Ve
.SS "default_catalog_sort_by"
.IX Subsection "default_catalog_sort_by"
.Vb 1
\&    $delimiter = C4::Context\->default_catalog_sort_by;
\&
\&    Returns default sort by for catalog search.
\&    For relevance no sort order is used.
\&
\&    For staff interface, depends on system preferences \*(AqdefaultSortField\*(Aq and \*(AqdefaultSortOrder\*(Aq.
\&    For OPAC interface, depends on system preferences \*(AqOPACdefaultSortField\*(Aq and \*(AqOPACdefaultSortOrder\*(Aq.
.Ve
.SS "Zconn"
.IX Subsection "Zconn"
.Vb 1
\&  $Zconn = C4::Context\->Zconn
.Ve
.PP
Returns a connection to the Zebra database
.PP
\&\f(CW$self\fR
.PP
\&\f(CW$server\fR one of the servers defined in the koha\-conf.xml file
.PP
\&\f(CW$async\fR whether this is a asynchronous connection
.SS "_new_Zconn"
.IX Subsection "_new_Zconn"
\&\f(CW$context\fR\->{\*(L"Zconn\*(R"} = &_new_Zconn($server,$async);
.PP
Internal function. Creates a new database connection from the data given in the current context and returns it.
.PP
\&\f(CW$server\fR one of the servers defined in the koha\-conf.xml file
.PP
\&\f(CW$async\fR whether this is a asynchronous connection
.PP
\&\f(CW$auth\fR whether this connection has rw access (1) or just r access (0 or \s-1NULL\s0)
.SS "dbh"
.IX Subsection "dbh"
.Vb 1
\&  $dbh = C4::Context\->dbh;
.Ve
.PP
Returns a database handle connected to the Koha database for the
current context. If no connection has yet been made, this method
creates one, and connects to the database.
.PP
This database handle is cached for future use: if you call
\&\f(CW\*(C`C4::Context\->dbh\*(C'\fR twice, you will get the same handle both
times. If you need a second database handle, use \f(CW&new_dbh\fR and
possibly \f(CW&set_dbh\fR.
.SS "new_dbh"
.IX Subsection "new_dbh"
.Vb 1
\&  $dbh = C4::Context\->new_dbh;
.Ve
.PP
Creates a new connection to the Koha database for the current context,
and returns the database handle (a \f(CW\*(C`DBI::db\*(C'\fR object).
.PP
The handle is not saved anywhere: this method is strictly a
convenience function; the point is that it knows which database to
connect to so that the caller doesn't have to know.
.SS "set_dbh"
.IX Subsection "set_dbh"
.Vb 4
\&  $my_dbh = C4::Connect\->new_dbh;
\&  C4::Connect\->set_dbh($my_dbh);
\&  ...
\&  C4::Connect\->restore_dbh;
.Ve
.PP
\&\f(CW&set_dbh\fR and \f(CW&restore_dbh\fR work in a manner analogous to
\&\f(CW&set_context\fR and \f(CW&restore_context\fR.
.PP
\&\f(CW&set_dbh\fR saves the current database handle on a stack, then sets
the current database handle to \f(CW$my_dbh\fR.
.PP
\&\f(CW$my_dbh\fR is assumed to be a good database handle.
.SS "restore_dbh"
.IX Subsection "restore_dbh"
.Vb 1
\&  C4::Context\->restore_dbh;
.Ve
.PP
Restores the database handle saved by an earlier call to
\&\f(CW\*(C`C4::Context\->set_dbh\*(C'\fR.
.SS "userenv"
.IX Subsection "userenv"
.Vb 1
\&  C4::Context\->userenv;
.Ve
.PP
Retrieves a hash for user environment variables.
.PP
This hash shall be cached for future use: if you call
\&\f(CW\*(C`C4::Context\->userenv\*(C'\fR twice, you will get the same hash without real \s-1DB\s0 access
.SS "set_userenv"
.IX Subsection "set_userenv"
.Vb 6
\&  C4::Context\->set_userenv($usernum, $userid, $usercnum,
\&                           $userfirstname, $usersurname,
\&                           $userbranch, $branchname, $userflags,
\&                           $emailaddress, $shibboleth
\&                           $desk_id, $desk_name,
\&                           $register_id, $register_name);
.Ve
.PP
Establish a hash of user environment variables.
.PP
set_userenv is called in Auth.pm
.SS "_new_userenv"
.IX Subsection "_new_userenv"
.Vb 1
\&  C4::Context\->_new_userenv($session);  # FIXME: This calling style is wrong for what looks like an _internal function
.Ve
.PP
Builds a hash for user environment variables.
.PP
This hash shall be cached for future use: if you call
\&\f(CW\*(C`C4::Context\->userenv\*(C'\fR twice, you will get the same hash without real \s-1DB\s0 access
.PP
_new_userenv is called in Auth.pm
.SS "_unset_userenv"
.IX Subsection "_unset_userenv"
.Vb 1
\&  C4::Context\->_unset_userenv;
.Ve
.PP
Destroys the hash for activeuser user environment variables.
.SS "get_versions"
.IX Subsection "get_versions"
.Vb 1
\&  C4::Context\->get_versions
.Ve
.PP
Gets various version info, for core Koha packages, Currently called from carp \fBhandle_errors()\fR sub, to send to browser if 'DebugLevel' syspref is set to '2'.
.SS "tz"
.IX Subsection "tz"
.Vb 1
\&  C4::Context\->tz
\&
\&  Returns a DateTime::TimeZone object for the system timezone
.Ve
.SS "IsSuperLibrarian"
.IX Subsection "IsSuperLibrarian"
.Vb 1
\&    C4::Context\->IsSuperLibrarian();
.Ve
.SS "interface"
.IX Subsection "interface"
Sets the current interface for later retrieval in any Perl module
.PP
.Vb 3
\&    C4::Context\->interface(\*(Aqopac\*(Aq);
\&    C4::Context\->interface(\*(Aqintranet\*(Aq);
\&    my $interface = C4::Context\->interface;
.Ve
.SS "only_my_library"
.IX Subsection "only_my_library"
.Vb 1
\&    my $test = C4::Context\->only_my_library;
\&
\&    Returns true if you enabled IndependentBranches and the current user
\&    does not have superlibrarian permissions.
.Ve
.PP
\fItemporary_directory\fR
.IX Subsection "temporary_directory"
.PP
Returns root directory for temporary storage
.PP
\fIset_remote_address\fR
.IX Subsection "set_remote_address"
.PP
set_remote_address should be called at the beginning of every script
that is *not* running under plack in order to the \s-1REMOTE_ADDR\s0 environment
variable to be set correctly.
.PP
\fIhttps_enabled\fR
.IX Subsection "https_enabled"
.PP
https_enabled should be called when checking if a \s-1HTTPS\s0 connection
is used.
.PP
Note that this depends on a \s-1HTTPS\s0 environmental variable being defined
by the web server. This function may not return the expected result,
if your web server or reverse proxies are not setting the correct
X\-Forwarded-Proto headers and \s-1HTTPS\s0 environmental variable.
.PP
Note too that the \s-1HTTPS\s0 value can vary from web server to web server.
We are relying on the convention of the value being \*(L"on\*(R" or \*(L"\s-1ON\*(R"\s0 here.
.PP
\fIneeds_install\fR
.IX Subsection "needs_install"
.PP
.Vb 1
\&    if ( $context\->needs_install ) { ... }
.Ve
.PP
This method returns a boolean representing the install status of the Koha instance.
.PP
\fIpsgi_env\fR
.IX Subsection "psgi_env"
.PP
psgi_env returns true if there is an environmental variable
prefixed with \*(L"psgi\*(R" or \*(L"plack\*(R". This is useful for detecting whether
this is a \s-1PSGI\s0 app or a \s-1CGI\s0 app, and implementing code as appropriate.
.PP
\fIis_internal_PSGI_request\fR
.IX Subsection "is_internal_PSGI_request"
.PP
is_internal_PSGI_request is used to detect if this request was made
from within the individual \s-1PSGI\s0 app or externally from the mounted \s-1PSGI\s0
app
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
.ie n .SS """KOHA_CONF"""
.el .SS "\f(CWKOHA_CONF\fP"
.IX Subsection "KOHA_CONF"
Specifies the configuration file to read.
.SH "AUTHORS"
.IX Header "AUTHORS"
Andrew Arensburger <arensb at ooblick dot com>
.PP
Joshua Ferraro <jmf at liblime dot com>
