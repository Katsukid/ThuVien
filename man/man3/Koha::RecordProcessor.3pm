.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Koha::RecordProcessor 3pm"
.TH Koha::RecordProcessor 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::RecordProcessor \- Dispatcher class for record normalization
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use Koha::RecordProcessor;
\&  my $normalizer = Koha::RecordProcessor(%params);
\&  $normalizer\->process($record)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Dispatcher class for record normalization. RecordProcessors must
extend Koha::RecordProcessor::Base, be in the Koha::Filter namespace,
and provide the following methods:
.PP
\&\fBfilter ($record)\fR \- apply the filter and return the result. \f(CW$record\fR
may be either a scalar or an arrayref, and the return result will be
the same type.
.PP
These methods may be overriden:
.PP
\&\fBinitialize (%params)\fR \- initialize the filter
.PP
\&\fBdestroy ()\fR \- destroy the filter
.PP
These methods should not be overridden unless you are very sure of what
you are doing:
.PP
\&\fBnew ()\fR \- create a new filter object
.PP
Note that the RecordProcessor will not clone the record that is
passed in. If you do not want to change the original MARC::Record
object (or whatever type of object you are passing in), you must
clone it \fIprior\fR to passing it off to the RecordProcessor.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&    my $normalizer = Koha::RecordProcessor\->new(%params);
.Ve
.PP
Create a new normalizer. Available parameters are:
.IP "\fBschema\fR" 8
.IX Item "schema"
Which metadata schema is in use. At the moment the only supported schema
is '\s-1MARC\s0'.
.IP "\fBfilters\fR" 8
.IX Item "filters"
What filter(s) to use. This must be an arrayref to a list of filters. Filters
can be specified either with a complete class path, or, if they are in the
Koha::Filter::${schema} namespace, as only the filter name, and
\&\*(L"Koha::Filter::${schema}\*(R" will be prepended to it before the filter is loaded.
.PP
\fIoptions\fR
.IX Subsection "options"
.PP
.Vb 1
\&    $processor\->options( $new_options );
.Ve
.PP
Overloaded accessor, that spreads the new options to the filter objects when set
.SS "bind"
.IX Subsection "bind"
.Vb 1
\&    $normalizer\->bind($record)
.Ve
.PP
Bind a normalizer to a particular record.
.SS "process"
.IX Subsection "process"
.Vb 1
\&    my $newrecord = $normalizer\->process([$record])
.Ve
.PP
Run the record(s) through the normalization pipeline. If \f(CW$record\fR is
not specified, process the record the normalizer is bound to.
Note that \f(CW$record\fR may be either a scalar or an arrayref, and the
return value will be of the same type.
.SS "AvailableFilters"
.IX Subsection "AvailableFilters"
.Vb 1
\&    my @available_filters = Koha::RecordProcessor::AvailableFilters([$schema]);
.Ve
.PP
Get a list of available filters. Optionally specify the metadata schema.
At present only \s-1MARC\s0 is supported as a schema.
