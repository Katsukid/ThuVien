.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Koha::Recall 3pm"
.TH Koha::Recall 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::Recall \- Koha Recall Object class
.SH "API"
.IX Header "API"
.SS "Class methods"
.IX Subsection "Class methods"
\fIbiblio\fR
.IX Subsection "biblio"
.PP
.Vb 1
\&    my $biblio = $recall\->biblio;
.Ve
.PP
Returns the related Koha::Biblio object for this recall.
.PP
\fIitem\fR
.IX Subsection "item"
.PP
.Vb 1
\&    my $item = $recall\->item;
.Ve
.PP
Returns the related Koha::Item object for this recall.
.PP
\fIpatron\fR
.IX Subsection "patron"
.PP
.Vb 1
\&    my $patron = $recall\->patron;
.Ve
.PP
Returns the related Koha::Patron object for this recall.
.PP
\fIlibrary\fR
.IX Subsection "library"
.PP
.Vb 1
\&    my $library = $recall\->library;
.Ve
.PP
Returns the related Koha::Library object for this recall.
.PP
\fIcheckout\fR
.IX Subsection "checkout"
.PP
.Vb 1
\&    my $checkout = $recall\->checkout;
.Ve
.PP
Returns the related Koha::Checkout object for this recall.
.PP
\fIrequested\fR
.IX Subsection "requested"
.PP
.Vb 1
\&    if ( $recall\->requested )
\&
\&    [% IF recall.requested %]
.Ve
.PP
Return true if recall status is requested.
.PP
\fIwaiting\fR
.IX Subsection "waiting"
.PP
.Vb 1
\&    if ( $recall\->waiting )
\&
\&    [% IF recall.waiting %]
.Ve
.PP
Return true if recall is awaiting pickup.
.PP
\fIoverdue\fR
.IX Subsection "overdue"
.PP
.Vb 1
\&    if ( $recall\->overdue )
\&
\&    [% IF recall.overdue %]
.Ve
.PP
Return true if recall is overdue to be returned.
.PP
\fIin_transit\fR
.IX Subsection "in_transit"
.PP
.Vb 1
\&    if ( $recall\->in_transit )
\&
\&    [% IF recall.in_transit %]
.Ve
.PP
Return true if recall is in transit.
.PP
\fIexpired\fR
.IX Subsection "expired"
.PP
.Vb 1
\&    if ( $recall\->expired )
\&
\&    [% IF recall.expired %]
.Ve
.PP
Return true if recall has expired.
.PP
\fIcancelled\fR
.IX Subsection "cancelled"
.PP
.Vb 1
\&    if ( $recall\->cancelled )
\&
\&    [% IF recall.cancelled %]
.Ve
.PP
Return true if recall has been cancelled.
.PP
\fIfulfilled\fR
.IX Subsection "fulfilled"
.PP
.Vb 1
\&    if ( $recall\->fulfilled )
\&
\&    [% IF recall.fulfilled %]
.Ve
.PP
Return true if the recall has been fulfilled.
.PP
\fIcalc_expirationdate\fR
.IX Subsection "calc_expirationdate"
.PP
.Vb 2
\&    my $expirationdate = $recall\->calc_expirationdate;
\&    $recall\->update({ expirationdate => $expirationdate });
.Ve
.PP
Calculate the expirationdate to set based on circulation rules and system preferences.
.PP
\fIstart_transfer\fR
.IX Subsection "start_transfer"
.PP
.Vb 1
\&    my ( $recall, $dotransfer, $messages ) = $recall\->start_transfer({ item => $item_object });
.Ve
.PP
Set the recall as in transit.
.PP
\fIrevert_transfer\fR
.IX Subsection "revert_transfer"
.PP
.Vb 1
\&    $recall\->revert_transfer;
.Ve
.PP
If a transfer is cancelled, revert the recall to requested.
.PP
\fIset_waiting\fR
.IX Subsection "set_waiting"
.PP
.Vb 5
\&    $recall\->set_waiting(
\&        {   expirationdate => $expirationdate,
\&            item           => $item_object
\&        }
\&    );
.Ve
.PP
Set the recall as waiting and update expiration date.
Notify the recall requester.
.PP
\fIrevert_waiting\fR
.IX Subsection "revert_waiting"
.PP
.Vb 1
\&    $recall\->revert_waiting;
.Ve
.PP
Revert recall waiting status.
.PP
\fIshould_be_overdue\fR
.IX Subsection "should_be_overdue"
.PP
.Vb 3
\&    if ( $recall\->should_be_overdue ) {
\&        $recall\->set_overdue;
\&    }
.Ve
.PP
Return true if this recall should be marked overdue
.PP
\fIset_overdue\fR
.IX Subsection "set_overdue"
.PP
.Vb 1
\&    $recall\->set_overdue;
.Ve
.PP
Set a recall as overdue when the recall has been requested and the borrower who has checked out the recalled item is late to return it. This can be done manually by the library or by cronjob. The interface is either '\s-1INTRANET\s0' or '\s-1COMMANDLINE\s0' for logging purposes.
.PP
\fIset_expired\fR
.IX Subsection "set_expired"
.PP
.Vb 1
\&    $recall\->set_expired({ interface => \*(AqINTRANET\*(Aq });
.Ve
.PP
Set a recall as expired. This may be done manually or by a cronjob, either when the borrower that placed the recall takes more than RecallsMaxPickUpDelay number of days to collect their item, or if the specified expirationdate passes. The interface is either '\s-1INTRANET\s0' or '\s-1COMMANDLINE\s0' for logging purposes.
.PP
\fIset_cancelled\fR
.IX Subsection "set_cancelled"
.PP
.Vb 1
\&    $recall\->set_cancelled;
.Ve
.PP
Set a recall as cancelled. This may be done manually, either by the borrower that placed the recall, or by the library.
.PP
\fIset_fulfilled\fR
.IX Subsection "set_fulfilled"
.PP
.Vb 1
\&    $recall\->set_fulfilled;
.Ve
.PP
Set a recall as finished. This should only be called when the item allocated to a recall is checked out to the borrower who requested the recall.
.SS "Internal methods"
.IX Subsection "Internal methods"
\fI_type\fR
.IX Subsection "_type"
