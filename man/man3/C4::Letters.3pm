.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "C4::Letters 3pm"
.TH C4::Letters 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::Letters \- Give functions for Letters management
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use C4::Letters;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 2
\&  "Letters" is the tool used in Koha to manage informations sent to the patrons and/or the library. This include some cron jobs like
\&  late issues, as well as other tasks like sending a mail to users that have subscribed to a "serial issue alert" (= being warned every time a new issue has arrived at the library)
\&
\&  Letters are managed through "alerts" sent by Koha on some events. All "alert" related functions are in this module too.
.Ve
.SS "GetLetters([$module])"
.IX Subsection "GetLetters([$module])"
.Vb 3
\&  $letters = &GetLetters($module);
\&  returns informations about letters.
\&  if needed, $module filters for letters given module
\&
\&  DEPRECATED \- You must use Koha::Notice::Templates instead
\&  The group by clause is confusing and can lead to issues
.Ve
.SS "GetLetterTemplates"
.IX Subsection "GetLetterTemplates"
.Vb 7
\&    my $letter_templates = GetLetterTemplates(
\&        {
\&            module => \*(Aqcirculation\*(Aq,
\&            code => \*(Aqmy code\*(Aq,
\&            branchcode => \*(AqCPL\*(Aq, # \*(Aq\*(Aq for default,
\&        }
\&    );
\&
\&    Return a hashref of letter templates.
.Ve
.SS "GetLettersAvailableForALibrary"
.IX Subsection "GetLettersAvailableForALibrary"
.Vb 6
\&    my $letters = GetLettersAvailableForALibrary(
\&        {
\&            branchcode => \*(AqCPL\*(Aq, # \*(Aq\*(Aq for default
\&            module => \*(Aqcirculation\*(Aq,
\&        }
\&    );
\&
\&    Return an arrayref of letters, sorted by name.
\&    If a specific letter exist for the given branchcode, it will be retrieve.
\&    Otherwise the default letter will be.
.Ve
.SS "DelLetter"
.IX Subsection "DelLetter"
.Vb 8
\&    DelLetter(
\&        {
\&            branchcode => \*(AqCPL\*(Aq,
\&            module => \*(Aqcirculation\*(Aq,
\&            code => \*(Aqmy code\*(Aq,
\&            [ mtt => \*(Aqemail\*(Aq, ]
\&        }
\&    );
\&
\&    Delete the letter. The mtt parameter is facultative.
\&    If not given, all templates mathing the other parameters will be removed.
.Ve
.SS "SendAlerts"
.IX Subsection "SendAlerts"
.Vb 1
\&    my $err = &SendAlerts($type, $externalid, $letter_code);
\&
\&    Parameters:
\&      \- $type : the type of alert
\&      \- $externalid : the id of the "object" to query
\&      \- $letter_code : the notice template to use
\&
\&    C<&SendAlerts> sends an email notice directly to a patron or a vendor.
\&
\&    Currently it supports ($type):
\&      \- claim serial issues (claimissues)
\&      \- claim acquisition orders (claimacquisition)
\&      \- send acquisition orders to the vendor (orderacquisition)
\&      \- notify patrons about newly received serial issues (issue)
\&      \- notify patrons when their account is created (members)
\&
\&    Returns undef or { error => \*(Aqmessage } on failure.
\&    Returns true on success.
.Ve
.ie n .SS "GetPreparedLetter( %params )"
.el .SS "GetPreparedLetter( \f(CW%params\fP )"
.IX Subsection "GetPreparedLetter( %params )"
.Vb 10
\&    %params hash:
\&      module => letter module, mandatory
\&      letter_code => letter code, mandatory
\&      branchcode => for letter selection, if missing default system letter taken
\&      tables => a hashref with table names as keys. Values are either:
\&        \- a scalar \- primary key value
\&        \- an arrayref \- primary key values
\&        \- a hashref \- full record
\&      substitute => custom substitution key/value pairs
\&      repeat => records to be substituted on consecutive lines:
\&        \- an arrayref \- tries to guess what needs substituting by
\&          taking remaining << >> tokensr; not recommended
\&        \- a hashref token => @tables \- replaces <token> << >> << >> </token>
\&          subtemplate for each @tables row; table is a hashref as above
\&      want_librarian => boolean,  if set to true triggers librarian details
\&        substitution from the userenv
\&    Return value:
\&      letter fields hashref (title & content useful)
.Ve
.ie n .SS "_parseletter($letter, $table, $values)"
.el .SS "_parseletter($letter, \f(CW$table\fP, \f(CW$values\fP)"
.IX Subsection "_parseletter($letter, $table, $values)"
.Vb 6
\&    parameters :
\&    \- $letter : a hash to letter fields (title & content useful)
\&    \- $table : the Koha table to parse.
\&    \- $values_in : table record hashref
\&    parse all fields from a table, and replace values in title & content with the appropriate value
\&    (not exported sub, used only internally)
.Ve
.SS "EnqueueLetter"
.IX Subsection "EnqueueLetter"
.Vb 2
\&  my $success = EnqueueLetter( { letter => $letter, 
\&        borrowernumber => \*(Aq12\*(Aq, message_transport_type => \*(Aqemail\*(Aq } )
.Ve
.PP
Places a letter in the message_queue database table, which will
eventually get processed (sent) by the process_message_queue.pl
cronjob when it calls SendQueuedMessages.
.PP
Return message_id on success
.PP
Parameters
* letter \- required; A letter hashref as returned from GetPreparedLetter
* message_transport_type \- required; One of the available mtts
* borrowernumber \- optional if 'to_address' is passed; The borrowernumber of the patron we enqueuing the notice for
* to_address \- optional if 'borrowernumber' is passed; The destination email address for the notice (defaults to patron\->notice_email_address)
* from_address \- optional; The from address for the notice, defaults to patron\->library\->from_email_address
* reply_address \- optional; The reply address for the notice, defaults to patron\->library\->reply_to
.SS "SendQueuedMessages ([$hashref])"
.IX Subsection "SendQueuedMessages ([$hashref])"
.Vb 9
\&    my $sent = SendQueuedMessages({
\&        message_id => $id,
\&        borrowernumber => $who_letter_is_for,
\&        letter_code => $letter_code, # can be scalar or arrayref
\&        type => $type, # can be scalar or arrayref
\&        limit => 50,
\&        verbose => 1,
\&        where => $where,
\&    });
.Ve
.PP
Sends 'pending' messages from the queue, based on parameters.
.PP
The (optional) message_id, borrowernumber, letter_code, type and where
parameter are used to select which pending messages will be processed. The
limit parameter determines the volume of results, i.e. sent messages.
.PP
The optional verbose parameter can be used to generate debugging output.
.PP
Returns number of messages sent.
.SS "GetRSSMessages"
.IX Subsection "GetRSSMessages"
.Vb 1
\&  my $message_list = GetRSSMessages( { limit => 10, borrowernumber => \*(Aq14\*(Aq } )
.Ve
.PP
returns a listref of all queued \s-1RSS\s0 messages for a particular person.
.SS "GetPrintMessages"
.IX Subsection "GetPrintMessages"
.Vb 1
\&  my $message_list = GetPrintMessages( { borrowernumber => $borrowernumber } )
.Ve
.PP
Returns a arrayref of all queued print messages (optionally, for a particular
person).
.SS "GetQueuedMessages ([$hashref])"
.IX Subsection "GetQueuedMessages ([$hashref])"
.Vb 1
\&  my $messages = GetQueuedMessage( { borrowernumber => \*(Aq123\*(Aq, limit => 20 } );
.Ve
.PP
Fetches a list of messages from the message queue optionally filtered by borrowernumber
and limited to specified limit.
.PP
Return is an arrayref of hashes, each has represents a message in the message queue.
.SS "GetMessageTransportTypes"
.IX Subsection "GetMessageTransportTypes"
.Vb 1
\&  my @mtt = GetMessageTransportTypes();
\&
\&  returns an arrayref of transport types
.Ve
.SS "GetMessage"
.IX Subsection "GetMessage"
.Vb 1
\&    my $message = C4::Letters::Message($message_id);
.Ve
.SS "ResendMessage"
.IX Subsection "ResendMessage"
.Vb 1
\&  Attempt to resend a message which has failed previously.
\&
\&  my $has_been_resent = C4::Letters::ResendMessage($message_id);
\&
\&  Updates the message to \*(Aqpending\*(Aq status so that
\&  it will be resent later on.
\&
\&  returns 1 on success, 0 on failure, undef if no message was found
.Ve
.SS "_add_attachements"
.IX Subsection "_add_attachements"
.Vb 1
\&  _add_attachments({ letter => $letter, attachments => $attachments });
\&
\&  named parameters:
\&  letter \- the standard letter hashref
\&  attachments \- listref of attachments. each attachment is a hashref of:
\&    type \- the mime type, like \*(Aqtext/plain\*(Aq
\&    content \- the actual attachment
\&    filename \- the name of the attachment.
\&
\&  returns your letter object, with the content updated.
\&  This routine picks the I<content> of I<letter> and generates a MIME
\&  email, attaching the passed I<attachments> using Koha::Email. The
\&  content is replaced by the string representation of the MIME object,
\&  and the content\-type is updated for later handling.
.Ve
.SS "_get_unsent_messages"
.IX Subsection "_get_unsent_messages"
.Vb 9
\&  This function\*(Aqs parameter hash reference takes the following
\&  optional named parameters:
\&   message_transport_type: method of message sending (e.g. email, sms, etc.)
\&                           Can be a single string, or an arrayref of strings
\&   borrowernumber        : who the message is to be sent
\&   letter_code           : type of message being sent (e.g. PASSWORD_RESET)
\&                           Can be a single string, or an arrayref of strings
\&   message_id            : the message_id of the message. In that case the sub will return only 1 result
\&   limit                 : maximum number of messages to send
\&
\&  This function returns an array of matching hash referenced rows from
\&  message_queue with some borrower information added.
.Ve
.PP
\fIadd_tt_filters\fR
.IX Subsection "add_tt_filters"
.PP
\&\f(CW$content\fR = add_tt_filters( \f(CW$content\fR );
.PP
Add \s-1TT\s0 filters to some specific fields if needed.
.PP
For now we only add the Remove_MARC_punctuation \s-1TT\s0 filter to biblio and biblioitem fields
.SS "get_item_content"
.IX Subsection "get_item_content"
.Vb 6
\&    my $item = Koha::Items\->find(...)\->unblessed;
\&    my @item_content_fields = qw( date_due title barcode author itemnumber );
\&    my $item_content = C4::Letters::get_item_content({
\&                             item => $item,
\&                             item_content_fields => \e@item_content_fields
\&                       });
.Ve
.PP
This function generates a tab-separated list of values for the passed item. Dates
are formatted following the current setup.
