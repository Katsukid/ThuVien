.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "C4::ShelfBrowser 3pm"
.TH C4::ShelfBrowser 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::ShelfBrowser \- functions that deal with the shelf browser feature found in
the OPAC.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use C4::ShelfBrowser;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides functions to get items nearby to another item, for use
in the shelf browser function.
.PP
\&'Nearby' is controlled by a handful of system preferences that specify what
to take into account.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "GetNearbyItems($itemnumber, [$num_each_side])"
.IX Subsection "GetNearbyItems($itemnumber, [$num_each_side])"
.Vb 1
\&  $nearby = GetNearbyItems($itemnumber, [$num_each_side]);
\&
\&  @items = @{ $nearby\->{items} };
\&
\&  foreach (@items) {
\&      # These won\*(Aqt format well like this, but here are the fields
\&          print $_\->{title};
\&          print $_\->{biblionumber};
\&          print $_\->{itemnumber};
\&          print $_\->{browser_normalized_upc};
\&          print $_\->{browser_normalized_oclc};
\&          print $_\->{browser_normalized_isbn};
\&      print $_\->{browser_normalized_ean};
\&  }
\&
\&  # This is the information required to scroll the browser to the next left
\&  # or right set. Can be derived from next/prev, but it\*(Aqs here for convenience.
\&  print $nearby\->{prev_item}{itemnumber};
\&  print $nearby\->{next_item}{itemnumber};
\&  print $nearby\->{prev_item}{biblionumber};
\&  print $nearby\->{next_item}{biblionumber};
\&
\&  # These will be undef if the values are not used to calculate the 
\&  # nearby items.
\&  print $nearby\->{starting_homebranch}\->{code};
\&  print $nearby\->{starting_homebranch}\->{description};
\&  print $nearby\->{starting_location}\->{code};
\&  print $nearby\->{starting_location}\->{description};
\&  print $nearby\->{starting_ccode}\->{code};
\&  print $nearby\->{starting_ccode}\->{description};
.Ve
.PP
This finds the items that are nearby to the supplied item, and supplies
those previous and next, along with the other useful information for displaying
the shelf browser.
.PP
It automatically applies the following user preferences to work out how to
calculate things: \f(CW\*(C`ShelfBrowserUsesLocation\*(C'\fR, \f(CW\*(C`ShelfBrowserUsesHomeBranch\*(C'\fR, 
\&\f(CW\*(C`ShelfBrowserUsesCcode\*(C'\fR.
.PP
The option \f(CW$num_each_side\fR value determines how many items will be fetched
each side of the supplied item. Note that the item itself is the first entry
in the 'next' set, and counts towards this limit (this is to keep the
behaviour consistent with the code that this is a refactor of.) Default is
3.
.PP
This will throw an exception if something went wrong.
