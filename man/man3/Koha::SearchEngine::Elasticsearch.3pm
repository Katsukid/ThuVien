.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Koha::SearchEngine::Elasticsearch 3pm"
.TH Koha::SearchEngine::Elasticsearch 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::SearchEngine::Elasticsearch \- Base module for things using elasticsearch
.SH "ACCESSORS"
.IX Header "ACCESSORS"
.IP "index" 4
.IX Item "index"
The name of the index to use, generally 'biblios' or 'authorities'.
.IP "index_name" 4
.IX Item "index_name"
The Elasticsearch index name with Koha instance prefix.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "get_elasticsearch"
.IX Subsection "get_elasticsearch"
.Vb 1
\&    my $elasticsearch_client = $self\->get_elasticsearch();
.Ve
.PP
Returns a \f(CW\*(C`Search::Elasticsearch\*(C'\fR client. The client is cached on a \f(CW\*(C`Koha::SearchEngine::ElasticSearch\*(C'\fR
instance level and will be reused if method is called multiple times.
.SS "get_elasticsearch_params"
.IX Subsection "get_elasticsearch_params"
.Vb 1
\&    my $params = $self\->get_elasticsearch_params();
.Ve
.PP
This provides a hashref that contains the parameters for connecting to the
ElasicSearch servers, in the form:
.PP
.Vb 4
\&    {
\&        \*(Aqnodes\*(Aq => [\*(Aq127.0.0.1:9200\*(Aq, \*(Aqanotherserver:9200\*(Aq],
\&        \*(Aqindex_name\*(Aq => \*(Aqkoha_instance_index\*(Aq,
\&    }
.Ve
.PP
This is configured by the following in the \f(CW\*(C`config\*(C'\fR block in koha\-conf.xml:
.PP
.Vb 5
\&    <elasticsearch>
\&        <server>127.0.0.1:9200</server>
\&        <server>anotherserver:9200</server>
\&        <index_name>koha_instance</index_name>
\&    </elasticsearch>
.Ve
.SS "get_elasticsearch_settings"
.IX Subsection "get_elasticsearch_settings"
.Vb 1
\&    my $settings = $self\->get_elasticsearch_settings();
.Ve
.PP
This provides the settings provided to Elasticsearch when an index is created.
These can do things like define tokenization methods.
.PP
A hashref containing the settings is returned.
.SS "get_elasticsearch_mappings"
.IX Subsection "get_elasticsearch_mappings"
.Vb 1
\&    my $mappings = $self\->get_elasticsearch_mappings();
.Ve
.PP
This provides the mappings that get passed to Elasticsearch when an index is
created.
.SS "raw_elasticsearch_mappings"
.IX Subsection "raw_elasticsearch_mappings"
Return elasticsearch mapping as it is in database.
marc_type: marc21|unimarc
.PP
\&\f(CW$raw_mappings\fR = raw_elasticsearch_mappings( \f(CW$marc_type\fR )
.SS "_get_elasticsearch_field_config"
.IX Subsection "_get_elasticsearch_field_config"
Get the Elasticsearch field config for the given purpose and data type.
.PP
\&\f(CW$mapping\fR = _get_elasticsearch_field_config('search', 'text');
.SS "_load_elasticsearch_mappings"
.IX Subsection "_load_elasticsearch_mappings"
Load Elasticsearch mappings in the format of mappings.yaml.
.PP
\&\f(CW$indexes\fR = \fB_load_elasticsearch_mappings()\fR;
.ie n .SS "_process_mappings($mappings, $data, $record_document, $meta)"
.el .SS "_process_mappings($mappings, \f(CW$data\fP, \f(CW$record_document\fP, \f(CW$meta\fP)"
.IX Subsection "_process_mappings($mappings, $data, $record_document, $meta)"
.Vb 1
\&    $self\->_process_mappings($mappings, $marc_field_data, $record_document, 0)
.Ve
.PP
Process all \f(CW$mappings\fR targets operating on a specific \s-1MARC\s0 field \f(CW$data\fR.
Since we group all mappings by \s-1MARC\s0 field targets \f(CW$mappings\fR will contain
all targets for \f(CW$data\fR and thus we need to fetch the \s-1MARC\s0 field only once.
\&\f(CW$mappings\fR will be applied to \f(CW$record_document\fR and new field values added.
The method has no return value.
.ie n .IP "$mappings" 4
.el .IP "\f(CW$mappings\fR" 4
.IX Item "$mappings"
Arrayref of mappings containing arrayrefs in the format
[\f(CW$target\fR, \f(CW$options\fR] where \f(CW$target\fR is the name of the target field and
\&\f(CW$options\fR is a hashref containing processing directives for this particular
mapping.
.ie n .IP "$data" 4
.el .IP "\f(CW$data\fR" 4
.IX Item "$data"
The source data from a \s-1MARC\s0 record field.
.ie n .IP "$record_document" 4
.el .IP "\f(CW$record_document\fR" 4
.IX Item "$record_document"
Hashref representing the Elasticsearch document on which mappings should be
applied.
.ie n .IP "$meta" 4
.el .IP "\f(CW$meta\fR" 4
.IX Item "$meta"
A hashref containing metadata useful for enforcing per mapping rules. For
example for providing extra context for mapping options, or treating mapping
targets differently depending on type (sort, search, facet etc). Combining
this metadata with the mapping options and metadata allows us to mutate the
data per mapping, or even replace it with other data retrieved from the
metadata context.
.Sp
Current properties are:
.Sp
\&\f(CW\*(C`altscript\*(C'\fR: A boolean value indicating whether an alternate script presentation is being
processed.
.Sp
\&\f(CW\*(C`data_source\*(C'\fR: The source of the $<data> argument. Possible values are: 'leader', 'control_field',
\&'subfield' or 'subfields_group'.
.Sp
\&\f(CW\*(C`code\*(C'\fR: The code of the subfield \f(CW$data\fR was retrieved, if \f(CW\*(C`data_source\*(C'\fR is 'subfield'.
.Sp
\&\f(CW\*(C`codes\*(C'\fR: Subfield codes of the subfields group from which \f(CW$data\fR was retrieved, if \f(CW\*(C`data_source\*(C'\fR
is 'subfields_group'.
.Sp
\&\f(CW\*(C`field\*(C'\fR: The original \f(CW\*(C`MARC::Record\*(C'\fR object.
.SS "marc_records_to_documents($marc_records)"
.IX Subsection "marc_records_to_documents($marc_records)"
.Vb 1
\&    my $record_documents = $self\->marc_records_to_documents($marc_records);
.Ve
.PP
Using mappings stored in database convert \f(CW$marc_records\fR to Elasticsearch documents.
.PP
Returns array of hash references, representing Elasticsearch documents,
acceptable as body payload in \f(CW\*(C`Search::Elasticsearch\*(C'\fR requests.
.ie n .IP "$marc_documents" 4
.el .IP "\f(CW$marc_documents\fR" 4
.IX Item "$marc_documents"
Reference to array of \f(CW\*(C`MARC::Record\*(C'\fR objects to be converted to Elasticsearch documents.
.SS "_marc_to_array($record)"
.IX Subsection "_marc_to_array($record)"
.Vb 1
\&    my @fields = _marc_to_array($record)
.Ve
.PP
Convert a MARC::Record to an array modeled after MARC-in-JSON
(see https://github.com/marc4j/marc4j/wiki/MARC\-in\-JSON\-Description)
.ie n .IP "$record" 4
.el .IP "\f(CW$record\fR" 4
.IX Item "$record"
A MARC::Record object
.SS "_array_to_marc($data)"
.IX Subsection "_array_to_marc($data)"
.Vb 1
\&    my $record = _array_to_marc($data)
.Ve
.PP
Convert an array modeled after MARC-in-JSON to a MARC::Record
.ie n .IP "$data" 4
.el .IP "\f(CW$data\fR" 4
.IX Item "$data"
An array modeled after MARC-in-JSON
(see https://github.com/marc4j/marc4j/wiki/MARC\-in\-JSON\-Description)
.ie n .SS "_field_mappings($facet, $suggestible, $sort, $search, $target_name, $target_type, $range)"
.el .SS "_field_mappings($facet, \f(CW$suggestible\fP, \f(CW$sort\fP, \f(CW$search\fP, \f(CW$target_name\fP, \f(CW$target_type\fP, \f(CW$range\fP)"
.IX Subsection "_field_mappings($facet, $suggestible, $sort, $search, $target_name, $target_type, $range)"
.Vb 1
\&    my @mappings = _field_mappings($facet, $suggestible, $sort, $search, $target_name, $target_type, $range)
.Ve
.PP
Get mappings, an internal data structure later used by
\&\*(L"_process_mappings($mappings, \f(CW$data\fR, \f(CW$record_document\fR, \f(CW$meta\fR)\*(R" to process \s-1MARC\s0 target
data for a \s-1MARC\s0 mapping.
.PP
The returned \f(CW$mappings\fR is not to to be confused with mappings provided by
\&\f(CW\*(C`_foreach_mapping\*(C'\fR, rather this sub accepts properties from a mapping as
provided by \f(CW\*(C`_foreach_mapping\*(C'\fR and expands it to this internal data structure.
In the caller context (\f(CW\*(C`_get_marc_mapping_rules\*(C'\fR) the returned \f(CW@mappings\fR
is then applied to each \s-1MARC\s0 target (leader, control field data, subfield or
joined subfields) and integrated into the mapping rules data structure used in
\&\f(CW\*(C`marc_records_to_documents\*(C'\fR to transform \s-1MARC\s0 records into Elasticsearch
documents.
.ie n .IP "$facet" 4
.el .IP "\f(CW$facet\fR" 4
.IX Item "$facet"
Boolean indicating whether to create a facet field for this mapping.
.ie n .IP "$suggestible" 4
.el .IP "\f(CW$suggestible\fR" 4
.IX Item "$suggestible"
Boolean indicating whether to create a suggestion field for this mapping.
.ie n .IP "$sort" 4
.el .IP "\f(CW$sort\fR" 4
.IX Item "$sort"
Boolean indicating whether to create a sort field for this mapping.
.ie n .IP "$search" 4
.el .IP "\f(CW$search\fR" 4
.IX Item "$search"
Boolean indicating whether to create a search field for this mapping.
.ie n .IP "$target_name" 4
.el .IP "\f(CW$target_name\fR" 4
.IX Item "$target_name"
Elasticsearch document target field name.
.ie n .IP "$target_type" 4
.el .IP "\f(CW$target_type\fR" 4
.IX Item "$target_type"
Elasticsearch document target field type.
.ie n .IP "$range" 4
.el .IP "\f(CW$range\fR" 4
.IX Item "$range"
An optional range as a string in the format \*(L"<\s-1START\s0>\-<\s-1END\s0>\*(R" or \*(L"<\s-1START\s0>\*(R",
where \*(L"<\s-1START\s0>\*(R" and \*(L"<\s-1END\s0>\*(R" are integers specifying a range that will be used
for extracting a substring from \s-1MARC\s0 data as Elasticsearch field target value.
.Sp
The first character position is \*(L"0\*(R", and the range is inclusive,
so \*(L"0\-2\*(R" means the first three characters of \s-1MARC\s0 data.
.Sp
If only \*(L"<\s-1START\s0>\*(R" is provided only one character at position \*(L"<\s-1START\s0>\*(R" will
be extracted.
.SS "_get_marc_mapping_rules"
.IX Subsection "_get_marc_mapping_rules"
.Vb 1
\&    my $mapping_rules = $self\->_get_marc_mapping_rules()
.Ve
.PP
Generates rules from mappings stored in database for \s-1MARC\s0 records to Elasticsearch \s-1JSON\s0 document conversion.
.PP
Since field retrieval is slow in \f(CW\*(C`MARC::Records\*(C'\fR (all fields are itereted through for
each call to \f(CW\*(C`MARC::Record\*(C'\fR\->field) we create an optimized structure of mapping
rules keyed by \s-1MARC\s0 field tags holding all the mapping rules for that particular tag.
.PP
We can then iterate through all \s-1MARC\s0 fields for each record and apply all relevant
rules once per fields instead of retreiving fields multiple times for each mapping rule
which is terribly slow.
.SS "_foreach_mapping"
.IX Subsection "_foreach_mapping"
.Vb 9
\&    $self\->_foreach_mapping(
\&        sub {
\&            my ( $name, $type, $facet, $suggestible, $sort, $marc_type,
\&                $marc_field )
\&              = @_;
\&            return unless $marc_type eq \*(Aqmarc21\*(Aq;
\&            print "Data comes from: " . $marc_field . "\en";
\&        }
\&    );
.Ve
.PP
This allows you to apply a function to each entry in the elasticsearch mappings
table, in order to build the mappings for whatever is needed.
.PP
In the provided function, the files are:
.ie n .IP "$name" 4
.el .IP "\f(CW$name\fR" 4
.IX Item "$name"
The field name for elasticsearch (corresponds to the 'mapping' column in the
database.
.ie n .IP "$type" 4
.el .IP "\f(CW$type\fR" 4
.IX Item "$type"
The type for this value, e.g. 'string'.
.ie n .IP "$facet" 4
.el .IP "\f(CW$facet\fR" 4
.IX Item "$facet"
True if this value should be facetised. This only really makes sense if the
field is understood by the facet processing code anyway.
.ie n .IP "$sort" 4
.el .IP "\f(CW$sort\fR" 4
.IX Item "$sort"
True if this is a field that a) needs special sort handling, and b) if it
should be sorted on. False if a) but not b). Undef if not a). This allows,
for example, author to be sorted on but not everything marked with \*(L"author\*(R"
to be included in that sort.
.ie n .IP "$marc_type" 4
.el .IP "\f(CW$marc_type\fR" 4
.IX Item "$marc_type"
A string that indicates the \s-1MARC\s0 type that this mapping is for, e.g. 'marc21',
\&'unimarc'.
.ie n .IP "$marc_field" 4
.el .IP "\f(CW$marc_field\fR" 4
.IX Item "$marc_field"
A string that describes the \s-1MARC\s0 field that contains the data to extract.
.SS "process_error"
.IX Subsection "process_error"
.Vb 1
\&    die process_error($@);
.Ve
.PP
This parses an Elasticsearch error message and produces a human-readable
result from it. This result is probably missing all the useful information
that you might want in diagnosing an issue, so the warning is also logged.
.PP
Note that currently the resulting message is not internationalised. This
will happen eventually by some method or other.
.SS "_read_configuration"
.IX Subsection "_read_configuration"
.Vb 1
\&    my $conf = _read_configuration();
.Ve
.PP
Reads the \fIconfiguration file\fR and returns a hash structure with the
configuration information. It raises an exception if mandatory entries
are missing.
.PP
The hashref structure has the following form:
.PP
.Vb 4
\&    {
\&        \*(Aqnodes\*(Aq => [\*(Aq127.0.0.1:9200\*(Aq, \*(Aqanotherserver:9200\*(Aq],
\&        \*(Aqindex_name\*(Aq => \*(Aqkoha_instance\*(Aq,
\&    }
.Ve
.PP
This is configured by the following in the \f(CW\*(C`config\*(C'\fR block in koha\-conf.xml:
.PP
.Vb 5
\&    <elasticsearch>
\&        <server>127.0.0.1:9200</server>
\&        <server>anotherserver:9200</server>
\&        <index_name>koha_instance</index_name>
\&    </elasticsearch>
.Ve
.SS "get_facetable_fields"
.IX Subsection "get_facetable_fields"
my \f(CW@facetable_fields\fR = Koha::SearchEngine::Elasticsearch\->\fBget_facetable_fields()\fR;
.PP
Returns the list of Koha::SearchFields marked to be faceted in the \s-1ES\s0 configuration
.SS "clear_search_fields_cache"
.IX Subsection "clear_search_fields_cache"
Koha::SearchEngine::Elasticsearch\->\fBclear_search_fields_cache()\fR;
.PP
Clear cached values for \s-1ES\s0 search fields
.SH "AUTHOR"
.IX Header "AUTHOR"
.ie n .IP "Chris Cormack ""<chrisc@catalyst.net.nz>""" 4
.el .IP "Chris Cormack \f(CW<chrisc@catalyst.net.nz>\fR" 4
.IX Item "Chris Cormack <chrisc@catalyst.net.nz>"
.PD 0
.ie n .IP "Robin Sheat ""<robin@catalyst.net.nz>""" 4
.el .IP "Robin Sheat \f(CW<robin@catalyst.net.nz>\fR" 4
.IX Item "Robin Sheat <robin@catalyst.net.nz>"
.ie n .IP "Jonathan Druart ""<jonathan.druart@bugs.koha\-community.org>""" 4
.el .IP "Jonathan Druart \f(CW<jonathan.druart@bugs.koha\-community.org>\fR" 4
.IX Item "Jonathan Druart <jonathan.druart@bugs.koha-community.org>"
