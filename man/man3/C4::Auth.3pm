.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "C4::Auth 3pm"
.TH C4::Auth 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::Auth \- Authenticates Koha users
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use CGI qw ( \-utf8 );
\&  use C4::Auth;
\&  use C4::Output;
\&
\&  my $query = CGI\->new;
\&
\&  my ($template, $borrowernumber, $cookie)
\&    = get_template_and_user(
\&        {
\&            template_name   => "opac\-main.tt",
\&            query           => $query,
\&      type            => "opac",
\&      authnotrequired => 0,
\&      flagsrequired   => { catalogue => \*(Aq*\*(Aq, tools => \*(Aqimport_patrons\*(Aq },
\&  }
\&    );
\&
\&  output_html_with_http_headers $query, $cookie, $template\->output;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The main function of this module is to provide
authentification. However the get_template_and_user function has
been provided so that a users login information is passed along
automatically. This gets loaded into the template.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "get_template_and_user"
.IX Subsection "get_template_and_user"
.Vb 10
\& my ($template, $borrowernumber, $cookie)
\&     = get_template_and_user(
\&       {
\&         template_name   => "opac\-main.tt",
\&         query           => $query,
\&         type            => "opac",
\&         authnotrequired => 0,
\&         flagsrequired   => { catalogue => \*(Aq*\*(Aq, tools => \*(Aqimport_patrons\*(Aq },
\&       }
\&     );
.Ve
.PP
This call passes the \f(CW\*(C`query\*(C'\fR, \f(CW\*(C`flagsrequired\*(C'\fR and \f(CW\*(C`authnotrequired\*(C'\fR
to \f(CW&checkauth\fR (in this module) to perform authentification.
See \f(CW&checkauth\fR for an explanation of these parameters.
.PP
The \f(CW\*(C`template_name\*(C'\fR is then used to find the correct template for
the page. The authenticated users details are loaded onto the
template in the logged_in_user variable (which is a Koha::Patron object). Also the
\&\f(CW\*(C`sessionID\*(C'\fR is passed to the template. This can be used in templates
if cookies are disabled. It needs to be put as and input to every
authenticated page.
.PP
More information on the \f(CW\*(C`gettemplate\*(C'\fR sub can be found in the
Output.pm module.
.SS "checkauth"
.IX Subsection "checkauth"
.Vb 1
\&  ($userid, $cookie, $sessionID) = &checkauth($query, $noauth, $flagsrequired, $type);
.Ve
.PP
Verifies that the user is authorized to run this script.  If
the user is authorized, a (userid, cookie, session-id, flags)
quadruple is returned.  If the user is not authorized but does
not have the required privilege (see \f(CW$flagsrequired\fR below), it
displays an error page and exits.  Otherwise, it displays the
login page and exits.
.PP
Note that \f(CW&checkauth\fR will return if and only if the user
is authorized, so it should be called early on, before any
unfinished operations (e.g., if you've opened a file, then
\&\f(CW&checkauth\fR won't close it for you).
.PP
\&\f(CW$query\fR is the \s-1CGI\s0 object for the script calling \f(CW&checkauth\fR.
.PP
The \f(CW$noauth\fR argument is optional. If it is set, then no
authorization is required for the script.
.PP
\&\f(CW&checkauth\fR fetches user and session information from \f(CW$query\fR and
ensures that the user is authorized to run scripts that require
authorization.
.PP
The \f(CW$flagsrequired\fR argument specifies the required privileges
the user must have if the username and password are correct.
It should be specified as a reference-to-hash; keys in the hash
should be the \*(L"flags\*(R" for the user, as specified in the Members
intranet module. Any key specified must correspond to a \*(L"flag\*(R"
in the userflags table. E.g., { circulate => 1 } would specify
that the user must have the \*(L"circulate\*(R" privilege in order to
proceed. To make sure that access control is correct, the
\&\f(CW$flagsrequired\fR parameter must be specified correctly.
.PP
Koha also has a concept of sub-permissions, also known as
granular permissions.  This makes the value of each key
in the \f(CW\*(C`flagsrequired\*(C'\fR hash take on an additional
meaning, i.e.,
.PP
.Vb 1
\& 1
.Ve
.PP
The user must have access to all subfunctions of the module
specified by the hash key.
.PP
.Vb 1
\& *
.Ve
.PP
The user must have access to at least one subfunction of the module
specified by the hash key.
.PP
.Vb 1
\& specific permission, e.g., \*(Aqexport_catalog\*(Aq
.Ve
.PP
The user must have access to the specific subfunction list, which
must correspond to a row in the permissions table.
.PP
The \f(CW$type\fR argument specifies whether the template should be
retrieved from the opac or intranet directory tree.  \*(L"opac\*(R" is
assumed if it is not specified; however, if \f(CW$type\fR is specified,
\&\*(L"intranet\*(R" is assumed if it is not \*(L"opac\*(R".
.PP
If \f(CW$query\fR does not have a valid session \s-1ID\s0 associated with it
(i.e., the user has not logged in) or if the session has expired,
\&\f(CW&checkauth\fR presents the user with a login page (from the point of
view of the original script, \f(CW&checkauth\fR does not return). Once the
user has authenticated, \f(CW&checkauth\fR restarts the original script
(this time, \f(CW&checkauth\fR returns).
.PP
The login page is provided using a HTML::Template, which is set in the
systempreferences table or at the top of this file. The variable \f(CW$type\fR
selects which template to use, either the opac or the intranet
authentification template.
.PP
\&\f(CW&checkauth\fR returns a user \s-1ID,\s0 a cookie, and a session \s-1ID.\s0 The
cookie should be sent back to the browser; it verifies that the user
has authenticated.
.SS "check_api_auth"
.IX Subsection "check_api_auth"
.Vb 1
\&  ($status, $cookie, $sessionId) = check_api_auth($query, $userflags);
.Ve
.PP
Given a \s-1CGI\s0 query containing the parameters 'userid' and 'password' and/or a session
cookie, determine if the user has the privileges specified by \f(CW$userflags\fR.
.PP
\&\f(CW\*(C`check_api_auth\*(C'\fR is is meant for authenticating users of web services, and
consequently will always return and will not attempt to redirect the user
agent.
.PP
If a valid session cookie is already present, check_api_auth will return a status
of \*(L"ok\*(R", the cookie, and the Koha session \s-1ID.\s0
.PP
If no session cookie is present, check_api_auth will check the 'userid' and 'password
parameters and create a session cookie and Koha session if the supplied credentials
are \s-1OK.\s0
.PP
Possible return values in \f(CW$status\fR are:
.ie n .IP """ok"" \*(-- user authenticated; $cookie and $sessionid have valid values." 4
.el .IP "``ok'' \*(-- user authenticated; \f(CW$cookie\fR and \f(CW$sessionid\fR have valid values." 4
.IX Item "ok user authenticated; $cookie and $sessionid have valid values."
.PD 0
.ie n .IP """failed"" \*(-- credentials are not correct; $cookie and $sessionid are undef" 4
.el .IP "``failed'' \*(-- credentials are not correct; \f(CW$cookie\fR and \f(CW$sessionid\fR are undef" 4
.IX Item "failed credentials are not correct; $cookie and $sessionid are undef"
.ie n .IP """maintenance"" \*(-- \s-1DB\s0 is in maintenance mode; no login possible at the moment" 4
.el .IP "``maintenance'' \*(-- \s-1DB\s0 is in maintenance mode; no login possible at the moment" 4
.IX Item "maintenance DB is in maintenance mode; no login possible at the moment"
.IP """expired \*(-- session cookie has expired; \s-1API\s0 user should resubmit userid and password" 4
.IX Item """expired session cookie has expired; API user should resubmit userid and password"
.ie n .IP """restricted"" \*(-- The \s-1IP\s0 has changed (if SessionRestrictionByIP)" 4
.el .IP "``restricted'' \*(-- The \s-1IP\s0 has changed (if SessionRestrictionByIP)" 4
.IX Item "restricted The IP has changed (if SessionRestrictionByIP)"
.IP """additional-auth-needed \*(-- User is in an authentication process that is not finished" 4
.IX Item """additional-auth-needed User is in an authentication process that is not finished"
.PD
.SS "check_cookie_auth"
.IX Subsection "check_cookie_auth"
.Vb 1
\&  ($status, $sessionId) = check_cookie_auth($cookie, $userflags);
.Ve
.PP
Given a \s-1CGISESSID\s0 cookie set during a previous login to Koha, determine
if the user has the privileges specified by \f(CW$userflags\fR. \f(CW$userflags\fR
is passed unaltered into \f(CW\*(C`haspermission\*(C'\fR and as such accepts all options
avaiable to that routine with the one caveat that \f(CW\*(C`check_api_auth\*(C'\fR will
also allow 'undef' to be passed and in such a case the permissions check
will be skipped altogether.
.PP
\&\f(CW\*(C`check_cookie_auth\*(C'\fR is meant for authenticating special services
such as tools/upload\-file.pl that are invoked by other pages that
have been authenticated in the usual way.
.PP
Possible return values in \f(CW$status\fR are:
.ie n .IP """ok"" \*(-- user authenticated; $sessionID have valid values." 4
.el .IP "``ok'' \*(-- user authenticated; \f(CW$sessionID\fR have valid values." 4
.IX Item "ok user authenticated; $sessionID have valid values."
.PD 0
.ie n .IP """anon"" \*(-- user not authenticated but valid for anonymous session." 4
.el .IP "``anon'' \*(-- user not authenticated but valid for anonymous session." 4
.IX Item "anon user not authenticated but valid for anonymous session."
.ie n .IP """failed"" \*(-- credentials are not correct; $sessionid are undef" 4
.el .IP "``failed'' \*(-- credentials are not correct; \f(CW$sessionid\fR are undef" 4
.IX Item "failed credentials are not correct; $sessionid are undef"
.ie n .IP """maintenance"" \*(-- \s-1DB\s0 is in maintenance mode; no login possible at the moment" 4
.el .IP "``maintenance'' \*(-- \s-1DB\s0 is in maintenance mode; no login possible at the moment" 4
.IX Item "maintenance DB is in maintenance mode; no login possible at the moment"
.IP """expired \*(-- session cookie has expired; \s-1API\s0 user should resubmit userid and password" 4
.IX Item """expired session cookie has expired; API user should resubmit userid and password"
.ie n .IP """restricted"" \*(-- The \s-1IP\s0 has changed (if SessionRestrictionByIP)" 4
.el .IP "``restricted'' \*(-- The \s-1IP\s0 has changed (if SessionRestrictionByIP)" 4
.IX Item "restricted The IP has changed (if SessionRestrictionByIP)"
.PD
.SS "get_session"
.IX Subsection "get_session"
.Vb 2
\&  use CGI::Session;
\&  my $session = get_session($sessionID);
.Ve
.PP
Given a session \s-1ID,\s0 retrieve the CGI::Session object used to store
the session's state.  The session object can be used to store
data that needs to be accessed by different scripts during a
user's session.
.PP
If the \f(CW$sessionID\fR parameter is an empty string, a new session
will be created.
.SS "create_basic_session"
.IX Subsection "create_basic_session"
my \f(CW$session\fR = create_basic_session({ patron => \f(CW$patron\fR, interface => \f(CW$interface\fR });
.PP
Creates a session and adds all basic parameters for a session to work
.SS "getuserflags"
.IX Subsection "getuserflags"
.Vb 1
\&    my $authflags = getuserflags($flags, $userid, [$dbh]);
.Ve
.PP
Translates integer flags into permissions strings hash.
.PP
\&\f(CW$flags\fR is the integer userflags value ( borrowers.userflags )
\&\f(CW$userid\fR is the members.userid, used for building subpermissions
\&\f(CW$authflags\fR is a hashref of permissions
.SS "get_user_subpermissions"
.IX Subsection "get_user_subpermissions"
.Vb 1
\&  $user_perm_hashref = get_user_subpermissions($userid);
.Ve
.PP
Given the userid (note, not the borrowernumber) of a staff user,
return a hashref of hashrefs of the specific subpermissions
accorded to the user.  An example return is
.PP
.Vb 6
\& {
\&    tools => {
\&        export_catalog => 1,
\&        import_patrons => 1,
\&    }
\& }
.Ve
.PP
The top-level hash-key is a module or function code from
userflags.flag, while the second-level key is a code
from permissions.
.PP
The results of this function do not give a complete picture
of the functions that a staff user can access; it is also
necessary to check borrowers.flags.
.SS "get_all_subpermissions"
.IX Subsection "get_all_subpermissions"
.Vb 1
\&  my $perm_hashref = get_all_subpermissions();
.Ve
.PP
Returns a hashref of hashrefs defining all specific
permissions currently defined.  The return value
has the same structure as that of \f(CW\*(C`get_user_subpermissions\*(C'\fR,
except that the innermost hash value is the description
of the subpermission.
.SS "get_cataloguing_page_permissions"
.IX Subsection "get_cataloguing_page_permissions"
.Vb 1
\&    my $required_permissions = get_cataloguing_page_permissions();
.Ve
.PP
Returns the required permissions to access the main cataloguing page. Useful for building
the global \fIcan_see_cataloguing_module\fR template variable, and also for reusing in
\&\fIcataloging\-home.pl\fR.
.SS "haspermission"
.IX Subsection "haspermission"
.Vb 6
\&  $flagsrequired = \*(Aq*\*(Aq;                                 # Any permission at all
\&  $flagsrequired = \*(Aqa_flag\*(Aq;                            # a_flag must be satisfied (all subpermissions)
\&  $flagsrequired = [ \*(Aqa_flag\*(Aq, \*(Aqb_flag\*(Aq ];              # a_flag OR b_flag must be satisfied
\&  $flagsrequired = { \*(Aqa_flag => 1, \*(Aqb_flag\*(Aq => 1 };     # a_flag AND b_flag must be satisfied
\&  $flagsrequired = { \*(Aqa_flag\*(Aq => \*(Aqsub_a\*(Aq };             # sub_a of a_flag must be satisfied
\&  $flagsrequired = { \*(Aqa_flag\*(Aq => [ \*(Aqsub_a, \*(Aqsub_b\*(Aq ] }; # sub_a OR sub_b of a_flag must be satisfied
\&
\&  $flags = ($userid, $flagsrequired);
.Ve
.PP
\&\f(CW$userid\fR the userid of the member
\&\f(CW$flags\fR is a query structure similar to that used by SQL::Abstract that
denotes the combination of flags required. It is a required parameter.
.PP
The main logic of this method is that things in arrays are \s-1OR\s0'ed, and things
in hashes are \s-1AND\s0'ed. The `*` character can be used, at any depth, to denote `ANY`
.PP
Returns member's flags or 0 if a permission is not met.
.SS "in_iprange"
.IX Subsection "in_iprange"
.Vb 1
\&  $flags = ($iprange);
.Ve
.PP
\&\f(CW$iprange\fR A space separated string describing an \s-1IP\s0 range. Can include single IPs or ranges
.PP
Returns 1 if the remote address is in the provided iprange, or 0 otherwise.
.SS "track_login_daily"
.IX Subsection "track_login_daily"
.Vb 1
\&    track_login_daily( $userid );
.Ve
.PP
Wraps the call to \f(CW$patron\fR\->track_login, the method used to update borrowers.lastseen. We only call track_login once a day.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1\fBCGI\s0\fR\|(3)
.PP
\&\fBC4::Output\fR\|(3)
.PP
\&\fBCrypt::Eksblowfish::Bcrypt\fR\|(3)
.PP
\&\fBDigest::MD5\fR\|(3)
