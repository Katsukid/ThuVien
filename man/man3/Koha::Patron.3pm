.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Koha::Patron 3pm"
.TH Koha::Patron 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::Patron \- Koha Patron Object class
.SH "API"
.IX Header "API"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fInew\fR
.IX Subsection "new"
.PP
\fIfixup_cardnumber\fR
.IX Subsection "fixup_cardnumber"
.PP
Autogenerate next cardnumber from highest value found in database
.PP
\fItrim_whitespace\fR
.IX Subsection "trim_whitespace"
.PP
trim whitespace from data which has some non-whitespace in it.
Could be moved to Koha::Object if need to be reused
.PP
\fIplain_text_password\fR
.IX Subsection "plain_text_password"
.PP
\&\f(CW$patron\fR\->plain_text_password( \f(CW$password\fR );
.PP
stores a copy of the unencrypted password in the object
for use in code before encrypting for db
.PP
\fIstore\fR
.IX Subsection "store"
.PP
Patron specific store method to cleanup record
and do other necessary things before saving
to db
.PP
\fIdelete\fR
.IX Subsection "delete"
.PP
\&\f(CW$patron\fR\->delete
.PP
Delete patron's holds, lists and finally the patron.
.PP
Lists owned by the borrower are deleted or ownership is transferred depending on the
ListOwnershipUponPatronDeletion pref, but entries from the borrower to other lists are kept.
.PP
\fIcategory\fR
.IX Subsection "category"
.PP
my \f(CW$patron_category\fR = \f(CW$patron\fR\->category
.PP
Return the patron category for this patron
.PP
\fIimage\fR
.IX Subsection "image"
.PP
\fIlibrary\fR
.IX Subsection "library"
.PP
Returns a Koha::Library object representing the patron's home library.
.PP
\fIsms_provider\fR
.IX Subsection "sms_provider"
.PP
Returns a Koha::SMS::Provider object representing the patron's \s-1SMS\s0 provider.
.PP
\fIguarantor_relationships\fR
.IX Subsection "guarantor_relationships"
.PP
Returns Koha::Patron::Relationships object for this patron's guarantors
.PP
Returns the set of relationships for the patrons that are guarantors for this patron.
.PP
Note that a guarantor should exist as a patron in Koha; it was not possible
to add them without a guarantor_id in the interface for some time. Bug 30472
restricts it on db level.
.PP
\fIguarantee_relationships\fR
.IX Subsection "guarantee_relationships"
.PP
Returns Koha::Patron::Relationships object for this patron's guarantors
.PP
Returns the set of relationships for the patrons that are guarantees for this patron.
.PP
The method returns Koha::Patron::Relationship objects for the sake
of consistency with the guantors method.
A guarantee by definition must exist as a patron in Koha.
.PP
\fIrelationships_debt\fR
.IX Subsection "relationships_debt"
.PP
Returns the amount owed by the patron's guarantors *and* the other guarantees of those guarantors
.PP
\fIhousebound_profile\fR
.IX Subsection "housebound_profile"
.PP
Returns the HouseboundProfile associated with this patron.
.PP
\fIhousebound_role\fR
.IX Subsection "housebound_role"
.PP
Returns the HouseboundRole associated with this patron.
.PP
\fIsiblings\fR
.IX Subsection "siblings"
.PP
Returns the siblings of this patron.
.PP
\fImerge_with\fR
.IX Subsection "merge_with"
.PP
.Vb 2
\&    my $patron = Koha::Patrons\->find($id);
\&    $patron\->merge_with( \e@patron_ids );
\&
\&    This subroutine merges a list of patrons into the patron record. This is accomplished by finding
\&    all related patron ids for the patrons to be merged in other tables and changing the ids to be that
\&    of the keeper patron.
.Ve
.PP
\fIwants_check_for_previous_checkout\fR
.IX Subsection "wants_check_for_previous_checkout"
.PP
.Vb 1
\&    $wants_check = $patron\->wants_check_for_previous_checkout;
.Ve
.PP
Return 1 if Koha needs to perform PrevIssue checking, else 0.
.PP
\fIdo_check_for_previous_checkout\fR
.IX Subsection "do_check_for_previous_checkout"
.PP
.Vb 1
\&    $do_check = $patron\->do_check_for_previous_checkout($item);
.Ve
.PP
Return 1 if the bib associated with \f(CW$ITEM\fR has previously been checked out to
\&\f(CW$PATRON\fR, 0 otherwise.
.PP
\fIis_debarred\fR
.IX Subsection "is_debarred"
.PP
my \f(CW$debarment_expiration\fR = \f(CW$patron\fR\->is_debarred;
.PP
Returns the date a patron debarment will expire, or undef if the patron is not
debarred
.PP
\fIis_expired\fR
.IX Subsection "is_expired"
.PP
my \f(CW$is_expired\fR = \f(CW$patron\fR\->is_expired;
.PP
Returns 1 if the patron is expired or 0;
.PP
\fIpassword_expired\fR
.IX Subsection "password_expired"
.PP
my \f(CW$password_expired\fR = \f(CW$patron\fR\->password_expired;
.PP
Returns 1 if the patron's password is expired or 0;
.PP
\fIis_going_to_expire\fR
.IX Subsection "is_going_to_expire"
.PP
my \f(CW$is_going_to_expire\fR = \f(CW$patron\fR\->is_going_to_expire;
.PP
Returns 1 if the patron is going to expired, depending on the NotifyBorrowerDeparture pref or 0
.PP
\fIset_password\fR
.IX Subsection "set_password"
.PP
.Vb 1
\&    $patron\->set_password({ password => $plain_text_password [, skip_validation => 1 ] });
.Ve
.PP
Set the patron's password.
.PP
Exceptions
.IX Subsection "Exceptions"
.PP
The passed string is validated against the current password enforcement policy.
Validation can be skipped by passing the \fIskip_validation\fR parameter.
.PP
Exceptions are thrown if the password is not good enough.
.IP "Koha::Exceptions::Password::TooShort" 4
.IX Item "Koha::Exceptions::Password::TooShort"
.PD 0
.IP "Koha::Exceptions::Password::WhitespaceCharacters" 4
.IX Item "Koha::Exceptions::Password::WhitespaceCharacters"
.IP "Koha::Exceptions::Password::TooWeak" 4
.IX Item "Koha::Exceptions::Password::TooWeak"
.ie n .IP "Koha::Exceptions::Password::Plugin (if a ""check password"" plugin is enabled)" 4
.el .IP "Koha::Exceptions::Password::Plugin (if a ``check password'' plugin is enabled)" 4
.IX Item "Koha::Exceptions::Password::Plugin (if a check password plugin is enabled)"
.PD
.PP
\fIrenew_account\fR
.IX Subsection "renew_account"
.PP
my \f(CW$new_expiry_date\fR = \f(CW$patron\fR\->renew_account
.PP
Extending the subscription to the expiry date.
.PP
\fIhas_overdues\fR
.IX Subsection "has_overdues"
.PP
my \f(CW$has_overdues\fR = \f(CW$patron\fR\->has_overdues;
.PP
Returns the number of patron's overdues
.PP
\fItrack_login\fR
.IX Subsection "track_login"
.PP
.Vb 2
\&    $patron\->track_login;
\&    $patron\->track_login({ force => 1 });
\&
\&    Tracks a (successful) login attempt.
\&    The preference TrackLastPatronActivity must be enabled. Or you
\&    should pass the force parameter.
.Ve
.PP
\fImove_to_deleted\fR
.IX Subsection "move_to_deleted"
.PP
my \f(CW$is_moved\fR = \f(CW$patron\fR\->move_to_deleted;
.PP
Move a patron to the deletedborrowers table.
This can be done before deleting a patron, to make sure the data are not completely deleted.
.PP
\fIcan_request_article\fR
.IX Subsection "can_request_article"
.PP
.Vb 1
\&    if ( $patron\->can_request_article( $library\->id ) ) { ... }
.Ve
.PP
Returns true if the patron can request articles. As limits apply for the patron
on the same day, those completed the same day are considered as current.
.PP
A \fIlibrary_id\fR can be passed as parameter, falling back to userenv if absent.
.PP
\fIarticle_request_fee\fR
.IX Subsection "article_request_fee"
.PP
.Vb 5
\&    my $fee = $patron\->article_request_fee(
\&        {
\&          [ library_id => $library\->id, ]
\&        }
\&    );
.Ve
.PP
Returns the fee to be charged to the patron when it places an article request.
.PP
A \fIlibrary_id\fR can be passed as parameter, falling back to userenv if absent.
.PP
\fIadd_article_request_fee_if_needed\fR
.IX Subsection "add_article_request_fee_if_needed"
.PP
.Vb 6
\&    my $fee = $patron\->add_article_request_fee_if_needed(
\&        {
\&          [ item_id    => $item\->id,
\&            library_id => $library\->id, ]
\&        }
\&    );
.Ve
.PP
If an article request fee needs to be charged, it adds a debit to the patron's
account.
.PP
Returns the fee line.
.PP
A \fIlibrary_id\fR can be passed as parameter, falling back to userenv if absent.
.PP
\fIarticle_requests\fR
.IX Subsection "article_requests"
.PP
.Vb 1
\&    my $article_requests = $patron\->article_requests;
.Ve
.PP
Returns the patron article requests.
.PP
\fIadd_enrolment_fee_if_needed\fR
.IX Subsection "add_enrolment_fee_if_needed"
.PP
my \f(CW$enrolment_fee\fR = \f(CW$patron\fR\->add_enrolment_fee_if_needed($renewal);
.PP
Add enrolment fee for a patron if needed.
.PP
\&\f(CW$renewal\fR \- boolean denoting whether this is an account renewal or not
.PP
\fIcheckouts\fR
.IX Subsection "checkouts"
.PP
my \f(CW$checkouts\fR = \f(CW$patron\fR\->checkouts
.PP
\fIpending_checkouts\fR
.IX Subsection "pending_checkouts"
.PP
my \f(CW$pending_checkouts\fR = \f(CW$patron\fR\->pending_checkouts
.PP
This method will return the same as \f(CW$self\fR\->checkouts, but with a prefetch on
items, biblio and biblioitems.
.PP
It has been introduced to replaced the C4::Members::GetPendingIssues subroutine
.PP
It should not be used directly, prefer to access fields you need instead of
retrieving all these fields in one go.
.PP
\fIold_checkouts\fR
.IX Subsection "old_checkouts"
.PP
my \f(CW$old_checkouts\fR = \f(CW$patron\fR\->old_checkouts
.PP
\fIoverdues\fR
.IX Subsection "overdues"
.PP
my \f(CW$overdue_items\fR = \f(CW$patron\fR\->overdues
.PP
Return the overdue items
.PP
\fIrestrictions\fR
.IX Subsection "restrictions"
.PP
.Vb 1
\&  my $restrictions = $patron\->restrictions;
.Ve
.PP
Returns the patron restrictions.
.PP
\fIget_routing_lists\fR
.IX Subsection "get_routing_lists"
.PP
my \f(CW$routinglists\fR = \f(CW$patron\fR\->get_routing_lists
.PP
Returns the routing lists a patron is subscribed to.
.PP
\fIget_age\fR
.IX Subsection "get_age"
.PP
.Vb 1
\&    my $age = $patron\->get_age
.Ve
.PP
Return the age of the patron
.PP
\fIis_valid_age\fR
.IX Subsection "is_valid_age"
.PP
my \f(CW$is_valid\fR = \f(CW$patron\fR\->is_valid_age
.PP
Return 1 if patron's age is between allowed limits, returns 0 if it's not.
.PP
\fIaccount\fR
.IX Subsection "account"
.PP
my \f(CW$account\fR = \f(CW$patron\fR\->account
.PP
\fIholds\fR
.IX Subsection "holds"
.PP
my \f(CW$holds\fR = \f(CW$patron\fR\->holds
.PP
Return all the holds placed by this patron
.PP
\fIold_holds\fR
.IX Subsection "old_holds"
.PP
my \f(CW$old_holds\fR = \f(CW$patron\fR\->old_holds
.PP
Return all the historical holds for this patron
.PP
\fIcurbside_pickups\fR
.IX Subsection "curbside_pickups"
.PP
my \f(CW$curbside_pickups\fR = \f(CW$patron\fR\->curbside_pickups;
.PP
Return all the curbside pickups for this patron
.PP
\fIreturn_claims\fR
.IX Subsection "return_claims"
.PP
my \f(CW$return_claims\fR = \f(CW$patron\fR\->return_claims
.PP
\fInotice_email_address\fR
.IX Subsection "notice_email_address"
.PP
.Vb 1
\&  my $email = $patron\->notice_email_address;
.Ve
.PP
Return the email address of patron used for notices.
Returns the empty string if no email address.
.PP
\fIfirst_valid_email_address\fR
.IX Subsection "first_valid_email_address"
.PP
my \f(CW$first_valid_email_address\fR = \f(CW$patron\fR\->first_valid_email_address
.PP
Return the first valid email address for a patron.
For now, the order  is defined as email, emailpro, B_email.
Returns the empty string if the borrower has no email addresses.
.PP
\fIget_club_enrollments\fR
.IX Subsection "get_club_enrollments"
.PP
\fIget_enrollable_clubs\fR
.IX Subsection "get_enrollable_clubs"
.PP
\fIaccount_locked\fR
.IX Subsection "account_locked"
.PP
my \f(CW$is_locked\fR = \f(CW$patron\fR\->account_locked
.PP
Return true if the patron has reached the maximum number of login attempts
(see pref FailedLoginAttempts). If login_attempts is < 0, this is interpreted
as an administrative lockout (independent of FailedLoginAttempts; see also
Koha::Patron\->lock).
Otherwise return false.
If the pref is not set (empty string, null or 0), the feature is considered as
disabled.
.PP
\fIcan_see_patron_infos\fR
.IX Subsection "can_see_patron_infos"
.PP
my \f(CW$can_see\fR = \f(CW$patron\fR\->can_see_patron_infos( \f(CW$patron\fR );
.PP
Return true if the patron (usually the logged in user) can see the patron's infos for a given patron
.PP
\fIcan_see_patrons_from\fR
.IX Subsection "can_see_patrons_from"
.PP
my \f(CW$can_see\fR = \f(CW$patron\fR\->can_see_patrons_from( \f(CW$branchcode\fR );
.PP
Return true if the patron (usually the logged in user) can see the patron's infos from a given library
.PP
\fIcan_edit_items_from\fR
.IX Subsection "can_edit_items_from"
.PP
.Vb 1
\&    my $can_edit = $patron\->can_edit_items_from( $branchcode );
.Ve
.PP
Return true if the \fIKoha::Patron\fR can edit items from the given branchcode
.PP
\fIlibraries_where_can_edit_items\fR
.IX Subsection "libraries_where_can_edit_items"
.PP
.Vb 1
\&    my $libraries = $patron\->libraries_where_can_edit_items;
.Ve
.PP
Return the list of branchcodes(!) of libraries the patron is allowed to items for.
The branchcodes are arbitrarily returned sorted.
We are supposing here that the object is related to the logged in patron (use of C4::Context::only_my_library)
.PP
An empty array means no restriction, the user can edit any item.
.PP
\fIlibraries_where_can_see_patrons\fR
.IX Subsection "libraries_where_can_see_patrons"
.PP
my \f(CW$libraries\fR = \f(CW$patron\fR\->libraries_where_can_see_patrons;
.PP
Return the list of branchcodes(!) of libraries the patron is allowed to see other patron's infos.
The branchcodes are arbitrarily returned sorted.
We are supposing here that the object is related to the logged in patron (use of C4::Context::only_my_library)
.PP
An empty array means no restriction, the patron can see patron's infos from any libraries.
.PP
\fIcan_see_things_from\fR
.IX Subsection "can_see_things_from"
.PP
my \f(CW$can_see\fR = \f(CW$patron\fR\->can_see_things_from( \f(CW$branchcode\fR );
.PP
Return true if the \fIKoha::Patron\fR can perform some action on the given thing
.PP
\fIcan_log_into\fR
.IX Subsection "can_log_into"
.PP
my \f(CW$can_log_into\fR = \f(CW$patron\fR\->can_log_into( \f(CW$library\fR );
.PP
Given a \fIKoha::Library\fR object, it returns a boolean representing
the fact the patron can log into a the library.
.PP
\fIlibraries_where_can_see_things\fR
.IX Subsection "libraries_where_can_see_things"
.PP
.Vb 1
\&    my $libraries = $patron\->libraries_where_can_see_things;
.Ve
.PP
Returns a list of libraries where an aribitarary action is allowed to be taken by the logged in librarian
against an object based on some branchcode related to the object ( patron branchcode, item homebranch, etc ).
.PP
We are supposing here that the object is related to the logged in librarian (use of C4::Context::only_my_library)
.PP
An empty array means no restriction, the thing can see thing's infos from any libraries.
.PP
\fIhas_permission\fR
.IX Subsection "has_permission"
.PP
my \f(CW$permission\fR = \f(CW$patron\fR\->has_permission($required);
.PP
See C4::Auth::haspermission for details of syntax for \f(CW$required\fR
.PP
\fIis_superlibrarian\fR
.IX Subsection "is_superlibrarian"
.PP
.Vb 1
\&  my $is_superlibrarian = $patron\->is_superlibrarian;
.Ve
.PP
Return true if the patron is a superlibrarian.
.PP
\fIis_adult\fR
.IX Subsection "is_adult"
.PP
my \f(CW$is_adult\fR = \f(CW$patron\fR\->is_adult
.PP
Return true if the patron has a category with a type Adult (A) or Organization (I)
.PP
\fIis_child\fR
.IX Subsection "is_child"
.PP
my \f(CW$is_child\fR = \f(CW$patron\fR\->is_child
.PP
Return true if the patron has a category with a type Child (C)
.PP
\fIhas_valid_userid\fR
.IX Subsection "has_valid_userid"
.PP
my \f(CW$patron\fR = Koha::Patrons\->find(42);
\&\f(CW$patron\fR\->userid( \f(CW$new_userid\fR );
my \f(CW$has_a_valid_userid\fR = \f(CW$patron\fR\->has_valid_userid
.PP
my \f(CW$patron\fR = Koha::Patron\->new( \f(CW$params\fR );
my \f(CW$has_a_valid_userid\fR = \f(CW$patron\fR\->has_valid_userid
.PP
Return true if the current userid of this patron is valid/unique, otherwise false.
.PP
Note that this should be done in \f(CW$self\fR\->store instead and raise an exception if needed.
.PP
\fIgenerate_userid\fR
.IX Subsection "generate_userid"
.PP
.Vb 1
\&    $patron\->generate_userid;
\&
\&    If you do not have a plugin for generating a userid, we will call
\&    the internal method here that returns firstname.surname[.number],
\&    where number is an optional suffix to make the userid unique.
\&    (Its behavior has not been changed on bug 32426.)
\&
\&    If you have plugin(s), the first valid response will be used.
\&    A plugin is assumed to return a valid userid as suggestion, but not
\&    assumed to save it already.
\&    Does not fallback to internal (you could arrange for that in your plugin).
\&    Clears userid when there are no valid plugin responses.
.Ve
.PP
\fIadd_extended_attribute\fR
.IX Subsection "add_extended_attribute"
.PP
\fIextended_attributes\fR
.IX Subsection "extended_attributes"
.PP
Return object of Koha::Patron::Attributes type with all attributes set for this patron
.PP
Or setter \s-1FIXME\s0
.PP
\fImessages\fR
.IX Subsection "messages"
.PP
.Vb 1
\&    my $messages = $patron\->messages;
.Ve
.PP
Return the message attached to the patron.
.PP
\fIlock\fR
.IX Subsection "lock"
.PP
.Vb 1
\&    Koha::Patrons\->find($id)\->lock({ expire => 1, remove => 1 });
\&
\&    Lock and optionally expire a patron account.
\&    Remove holds and article requests if remove flag set.
\&    In order to distinguish from locking by entering a wrong password, let\*(Aqs
\&    call this an administrative lockout.
.Ve
.PP
\fIanonymize\fR
.IX Subsection "anonymize"
.PP
.Vb 1
\&    Koha::Patrons\->find($id)\->anonymize;
\&
\&    Anonymize or clear borrower fields. Fields in BorrowerMandatoryField
\&    are randomized, other personal data is cleared too.
\&    Patrons with issues are skipped.
.Ve
.PP
\fIadd_guarantor\fR
.IX Subsection "add_guarantor"
.PP
.Vb 6
\&    my $relationship = $patron\->add_guarantor(
\&        {
\&            borrowernumber => $borrowernumber,
\&            relationships  => $relationship,
\&        }
\&    );
\&
\&    Adds a new guarantor to a patron.
.Ve
.PP
\fIget_extended_attribute\fR
.IX Subsection "get_extended_attribute"
.PP
my \f(CW$attribute_value\fR = \f(CW$patron\fR\->get_extended_attribute( \f(CW$code\fR );
.PP
Return the attribute for the code passed in parameter.
.PP
It not exist it returns undef
.PP
Note that this will not work for repeatable attribute types.
.PP
Maybe you certainly not want to use this method, it is actually only used for \s-1SHOW_BARCODE\s0
(which should be a real patron's attribute (not extended)
.PP
\fIto_api\fR
.IX Subsection "to_api"
.PP
.Vb 1
\&    my $json = $patron\->to_api;
.Ve
.PP
Overloaded method that returns a \s-1JSON\s0 representation of the Koha::Patron object,
suitable for \s-1API\s0 output.
.PP
\fIto_api_mapping\fR
.IX Subsection "to_api_mapping"
.PP
This method returns the mapping for representing a Koha::Patron object
on the \s-1API.\s0
.PP
\fIqueue_notice\fR
.IX Subsection "queue_notice"
.PP
.Vb 3
\&    Koha::Patrons\->queue_notice({ letter_params => $letter_params, message_name => \*(AqDUE\*(Aq});
\&    Koha::Patrons\->queue_notice({ letter_params => $letter_params, message_transports => \e@message_transports });
\&    Koha::Patrons\->queue_notice({ letter_params => $letter_params, message_transports => \e@message_transports, test_mode => 1 });
\&
\&    Queue messages to a patron. Can pass a message that is part of the message_attributes
\&    table or supply the transport to use.
\&
\&    If passed a message name we retrieve the patrons preferences for transports
\&    Otherwise we use the supplied transport. In the case of email or sms we fall back to print if
\&    we have no address/number for sending
\&
\&    $letter_params is a hashref of the values to be passed to GetPreparedLetter
\&
\&    test_mode will only report which notices would be sent, but nothing will be queued
.Ve
.PP
\fIsafe_to_delete\fR
.IX Subsection "safe_to_delete"
.PP
.Vb 4
\&    my $result = $patron\->safe_to_delete;
\&    if ( $result eq \*(Aqhas_guarantees\*(Aq ) { ... }
\&    elsif ( $result ) { ... }
\&    else { # cannot delete }
.Ve
.PP
This method tells if the Koha:Patron object can be deleted. Possible return values
.IP "'ok'" 4
.IX Item "'ok'"
.PD 0
.IP "'has_checkouts'" 4
.IX Item "'has_checkouts'"
.IP "'has_debt'" 4
.IX Item "'has_debt'"
.IP "'has_guarantees'" 4
.IX Item "'has_guarantees'"
.IP "'is_anonymous_patron'" 4
.IX Item "'is_anonymous_patron'"
.PD
.PP
\fIrecalls\fR
.IX Subsection "recalls"
.PP
.Vb 1
\&    my $recalls = $patron\->recalls;
.Ve
.PP
Return the patron's recalls.
.PP
\fIaccount_balance\fR
.IX Subsection "account_balance"
.PP
.Vb 1
\&    my $balance = $patron\->account_balance
.Ve
.PP
Return the patron's account balance
.PP
\fInotify_library_of_registration\fR
.IX Subsection "notify_library_of_registration"
.PP
\&\f(CW$patron\fR\->notify_library_of_registration( \f(CW$email_patron_registrations\fR );
.PP
Send patron registration email to library if EmailPatronRegistrations system preference is enabled.
.PP
\fIhas_messaging_preference\fR
.IX Subsection "has_messaging_preference"
.PP
my \f(CW$bool\fR = \f(CW$patron\fR\->has_messaging_preference({
    message_name => \f(CW$message_name\fR, # A value from message_attributes.message_name
    message_transport_type => \f(CW$message_transport_type\fR, # email, sms, phone, itiva, etc...
    wants_digest => \f(CW$wants_digest\fR, # 1 if you are looking for the digest version, don't pass if you just want either
});
.PP
\fIcan_patron_change_staff_only_lists\fR
.IX Subsection "can_patron_change_staff_only_lists"
.PP
\&\f(CW$patron\fR\->can_patron_change_staff_only_lists;
.PP
Return 1 if a patron has 'Superlibrarian' or 'Catalogue' permission.
Otherwise, return 0.
.PP
\fIcan_patron_change_permitted_staff_lists\fR
.IX Subsection "can_patron_change_permitted_staff_lists"
.PP
\&\f(CW$patron\fR\->can_patron_change_permitted_staff_lists;
.PP
Return 1 if a patron has 'Superlibrarian' or 'Catalogue' and 'edit_public_list_contents' permissions.
Otherwise, return 0.
.PP
\fIencode_secret\fR
.IX Subsection "encode_secret"
.PP
.Vb 1
\&  $patron\->encode_secret($secret32);
.Ve
.PP
Secret (TwoFactorAuth expects it in base32 format) is encrypted.
You still need to call \->store.
.PP
\fIdecoded_secret\fR
.IX Subsection "decoded_secret"
.PP
.Vb 1
\&  my $secret32 = $patron\->decoded_secret;
.Ve
.PP
Decode the patron secret. We expect to get back a base32 string, but this
is not checked here. Caller of encode_secret is responsible for that.
.PP
\fIvirtualshelves\fR
.IX Subsection "virtualshelves"
.PP
.Vb 1
\&    my $shelves = $patron\->virtualshelves;
.Ve
.PP
\fIget_savings\fR
.IX Subsection "get_savings"
.PP
.Vb 1
\&    my $savings = $patron\->get_savings;
.Ve
.PP
Use the replacement price of patron's old and current issues to calculate how much they have 'saved' by using the library.
.SS "Internal methods"
.IX Subsection "Internal methods"
\fI_type\fR
.IX Subsection "_type"
.SH "AUTHORS"
.IX Header "AUTHORS"
Kyle M Hall <kyle@bywatersolutions.com>
Alex Sassmannshausen <alex.sassmannshausen@ptfs\-europe.com>
Martin Renvoize <martin.renvoize@ptfs\-europe.com>
