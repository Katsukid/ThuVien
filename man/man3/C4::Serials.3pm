.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "C4::Serials 3pm"
.TH C4::Serials 3pm "2023-10-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::Serials \- Serials Module Functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use C4::Serials;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Functions for handling subscriptions, claims routing etc.
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.SS "GetSuppliersWithLateIssues"
.IX Subsection "GetSuppliersWithLateIssues"
\&\f(CW$supplierlist\fR = \fBGetSuppliersWithLateIssues()\fR
.PP
this function get all suppliers with late issues.
.PP
return :
an array_ref of suppliers each entry is a hash_ref containing id and name
the array is in name order
.SS "GetSubscriptionHistoryFromSubscriptionId"
.IX Subsection "GetSubscriptionHistoryFromSubscriptionId"
\&\f(CW$history\fR = GetSubscriptionHistoryFromSubscriptionId($subscriptionid);
.PP
This function returns the subscription history as a hashref
.SS "GetSerialInformation"
.IX Subsection "GetSerialInformation"
\&\f(CW$data\fR = GetSerialInformation($serialid);
returns a hash_ref containing :
  items : items marcrecord (can be an array)
  serial table field
  subscription table field
  + information about subscription expiration
.SS "AddItem2Serial"
.IX Subsection "AddItem2Serial"
\&\f(CW$rows\fR = AddItem2Serial($serialid,$itemnumber);
Adds an itemnumber to Serial record
returns the number of rows affected
.SS "GetSubscription"
.IX Subsection "GetSubscription"
\&\f(CW$subs\fR = GetSubscription($subscriptionid)
this function returns the subscription which has \f(CW$subscriptionid\fR as id.
return :
a hashref. This hash contains
subscription, subscriptionhistory, aqbooksellers.name, biblio.title
.SS "GetFullSubscription"
.IX Subsection "GetFullSubscription"
.Vb 2
\&   $array_ref = GetFullSubscription($subscriptionid)
\&   this function reads the serial table.
.Ve
.SS "PrepareSerialsData"
.IX Subsection "PrepareSerialsData"
.Vb 2
\&   $array_ref = PrepareSerialsData($serialinfomation)
\&   where serialinformation is a hashref array
.Ve
.SS "GetSubscriptionsFromBiblionumber"
.IX Subsection "GetSubscriptionsFromBiblionumber"
\&\f(CW$array_ref\fR = GetSubscriptionsFromBiblionumber($biblionumber)
this function get the subscription list. it reads the subscription table.
return :
reference to an array of subscriptions which have the biblionumber given on input arg.
each element of this array is a hashref containing
startdate, histstartdate,opacnote,missinglist,recievedlist,periodicity,status & enddate
.SS "GetFullSubscriptionsFromBiblionumber"
.IX Subsection "GetFullSubscriptionsFromBiblionumber"
.Vb 2
\&   $array_ref = GetFullSubscriptionsFromBiblionumber($biblionumber)
\&   this function reads the serial table.
.Ve
.SS "SearchSubscriptions"
.IX Subsection "SearchSubscriptions"
.Vb 1
\&  @results = SearchSubscriptions($args);
.Ve
.PP
This function returns a list of hashrefs, one for each subscription
that meets the conditions specified by the \f(CW$args\fR hashref.
.PP
The valid search fields are:
.PP
.Vb 11
\&  biblionumber
\&  title
\&  issn
\&  ean
\&  callnumber
\&  location
\&  publisher
\&  bookseller
\&  branch
\&  expiration_date
\&  closed
.Ve
.PP
The expiration_date search field is special; it specifies the maximum
subscription expiration date.
.SS "GetSerials"
.IX Subsection "GetSerials"
($totalissues,@serials) = GetSerials($subscriptionid);
this function gets every serial not arrived for a given subscription
as well as the number of issues registered in the database (all types)
this number is used to see if a subscription can be deleted (=it must have only 1 issue)
.PP
\&\s-1FIXME:\s0 We should return \e@serials.
.SS "GetSerials2"
.IX Subsection "GetSerials2"
\&\f(CW@serials\fR = GetSerials2($subscriptionid,$statuses);
this function returns every serial waited for a given subscription
as well as the number of issues registered in the database (all types)
this number is used to see if a subscription can be deleted (=it must have only 1 issue)
.PP
\&\f(CW$statuses\fR is an arrayref of statuses and is mandatory.
.SS "GetLatestSerials"
.IX Subsection "GetLatestSerials"
\&\e@serials = GetLatestSerials($subscriptionid,$limit)
get the \f(CW$limit\fR's latest serials arrived or missing for a given subscription
return :
a ref to an array which contains all of the latest serials stored into a hash.
.SS "GetPreviousSerialid"
.IX Subsection "GetPreviousSerialid"
\&\f(CW$serialid\fR = GetPreviousSerialid($subscriptionid, \f(CW$nth\fR)
get the \f(CW$nth\fR's previous serial for the given subscriptionid
return :
the serialid
.SS "GetNextSeq"
.IX Subsection "GetNextSeq"
.Vb 4
\&    my (
\&        $nextseq,       $newlastvalue1, $newlastvalue2, $newlastvalue3,
\&        $newinnerloop1, $newinnerloop2, $newinnerloop3
\&    ) = GetNextSeq( $subscription, $pattern, $frequency, $planneddate );
.Ve
.PP
\&\f(CW$subscription\fR is a hashref containing all the attributes of the table
\&'subscription'.
\&\f(CW$pattern\fR is a hashref containing all the attributes of the table
\&'subscription_numberpatterns'.
\&\f(CW$frequency\fR is a hashref containing all the attributes of the table 'subscription_frequencies'
\&\f(CW$planneddate\fR is a date string in iso format.
This function get the next issue for the subscription given on input arg
.SS "GetSeq"
.IX Subsection "GetSeq"
\&\f(CW$calculated\fR = GetSeq($subscription, \f(CW$pattern\fR)
\&\f(CW$subscription\fR is a hashref containing all the attributes of the table 'subscription'
\&\f(CW$pattern\fR is a hashref containing all the attributes of the table 'subscription_numberpatterns'
this function transforms {X},{Y},{Z} to 150,0,0 for example.
return:
the sequence in string format
.SS "GetExpirationDate"
.IX Subsection "GetExpirationDate"
\&\f(CW$enddate\fR = GetExpirationDate($subscriptionid, [$startdate])
.PP
this function return the next expiration date for a subscription given on input args.
.PP
return
the enddate or undef
.SS "CountSubscriptionFromBiblionumber"
.IX Subsection "CountSubscriptionFromBiblionumber"
\&\f(CW$subscriptionsnumber\fR = CountSubscriptionFromBiblionumber($biblionumber)
this returns a count of the subscriptions for a given biblionumber
return :
the number of subscriptions
.SS "ModSubscriptionHistory"
.IX Subsection "ModSubscriptionHistory"
ModSubscriptionHistory($subscriptionid,$histstartdate,$enddate,$recievedlist,$missinglist,$opacnote,$librariannote);
.PP
this function modifies the history of a subscription. Put your new values on input arg.
returns the number of rows affected
.SS "ModSerialStatus"
.IX Subsection "ModSerialStatus"
.Vb 2
\&    ModSerialStatus($serialid, $serialseq, $planneddate, $publisheddate,
\&        $publisheddatetext, $status, $notes);
.Ve
.PP
This function modify the serial status. Serial status is a number.(eg 2 is \*(L"arrived\*(R")
Note : if we change from \*(L"waited\*(R" to something else,then we will have to create a new \*(L"waited\*(R" entry
.SS "GetNextExpected"
.IX Subsection "GetNextExpected"
\&\f(CW$nextexpected\fR = GetNextExpected($subscriptionid)
.PP
Get the planneddate for the current expected issue of the subscription.
.PP
returns a hashref:
.PP
\&\f(CW$nextexepected\fR = {
    serialid => int
    planneddate => \s-1ISO\s0 date
    }
.SS "ModNextExpected"
.IX Subsection "ModNextExpected"
ModNextExpected($subscriptionid,$date)
.PP
Update the planneddate for the current expected issue of the subscription.
This will modify all future prediction results.
.PP
\&\f(CW$date\fR is an \s-1ISO\s0 date.
.PP
returns 0
.SS "GetSubscriptionIrregularities"
.IX Subsection "GetSubscriptionIrregularities"
.ie n .IP "@irreg = &GetSubscriptionIrregularities($subscriptionid); get the list of irregularities for a subscription" 4
.el .IP "\f(CW@irreg\fR = &GetSubscriptionIrregularities($subscriptionid); get the list of irregularities for a subscription" 4
.IX Item "@irreg = &GetSubscriptionIrregularities($subscriptionid); get the list of irregularities for a subscription"
.SS "ModSubscription"
.IX Subsection "ModSubscription"
this function modifies a subscription. Put all new values on input args.
returns the number of rows affected
.SS "NewSubscription"
.IX Subsection "NewSubscription"
\&\f(CW$subscriptionid\fR = &NewSubscription($auser,branchcode,$aqbooksellerid,$cost,$aqbudgetid,$biblionumber,
    \f(CW$startdate\fR,$periodicity,$numberlength,$weeklength,$monthlength,
    \f(CW$lastvalue1\fR,$innerloop1,$lastvalue2,$innerloop2,$lastvalue3,$innerloop3,
    \f(CW$status\fR, \f(CW$notes\fR, \f(CW$letter\fR, \f(CW$firstacquidate\fR, \f(CW$irregularity\fR, \f(CW$numberpattern\fR,
    \f(CW$locale\fR, \f(CW$callnumber\fR, \f(CW$manualhistory\fR, \f(CW$internalnotes\fR, \f(CW$serialsadditems\fR,
    \f(CW$staffdisplaycount\fR, \f(CW$opacdisplaycount\fR, \f(CW$graceperiod\fR, \f(CW$location\fR, \f(CW$enddate\fR,
    \f(CW$skip_serialseq\fR, \f(CW$itemtype\fR, \f(CW$previousitemtype\fR);
.PP
Create a new subscription with value given on input args.
.PP
return :
the id of this new subscription
.SS "GetSubscriptionLength"
.IX Subsection "GetSubscriptionLength"
my ($numberlength, \f(CW$weeklength\fR, \f(CW$monthlength\fR) = GetSubscriptionLength( \f(CW$subtype\fR, \f(CW$sublength\fR );
.PP
This function calculates the subscription length.
.SS "ReNewSubscription"
.IX Subsection "ReNewSubscription"
ReNewSubscription($params);
.PP
\&\f(CW$params\fR is a hashref with the following keys: subscriptionid, user, startdate, numberlength, weeklength, monthlength, note, branchcode
.PP
this function renew a subscription with values given on input args.
.SS "NewIssue"
.IX Subsection "NewIssue"
NewIssue($serialseq,$subscriptionid,$biblionumber,$status, \f(CW$planneddate\fR, \f(CW$publisheddate\fR, \f(CW$notes\fR, \f(CW$routingnotes\fR)
.PP
Create a new issue stored on the database.
Note : we have to update the recievedlist and missinglist on subscriptionhistory for this subscription.
returns the serial id
.SS "HasSubscriptionStrictlyExpired"
.IX Subsection "HasSubscriptionStrictlyExpired"
1 or 0 = HasSubscriptionStrictlyExpired($subscriptionid)
.PP
the subscription has stricly expired when today > the end subscription date
.PP
return :
1 if true, 0 if false, \-1 if the expiration date is not set.
.SS "HasSubscriptionExpired"
.IX Subsection "HasSubscriptionExpired"
\&\f(CW$has_expired\fR = HasSubscriptionExpired($subscriptionid)
.PP
the subscription has expired when the next issue to arrive is out of subscription limit.
.PP
return :
0 if the subscription has not expired
1 if the subscription has expired
2 if has subscription does not have a valid expiration date set
.SS "DelSubscription"
.IX Subsection "DelSubscription"
DelSubscription($subscriptionid)
this function deletes subscription which has \f(CW$subscriptionid\fR as id.
.SS "DelIssue"
.IX Subsection "DelIssue"
DelIssue($serialseq,$subscriptionid)
this function deletes an issue which has \f(CW$serialseq\fR and \f(CW$subscriptionid\fR given on input arg.
.PP
returns the number of rows affected
.SS "GetLateOrMissingIssues"
.IX Subsection "GetLateOrMissingIssues"
\&\f(CW@issuelist\fR = GetLateMissingIssues($supplierid,$serialid)
.PP
this function selects missing issues on database \- where serial.status = MISSING* or serial.status = \s-1LATE\s0 or planneddate<now
.PP
return :
the issuelist as an array of hash refs. Each element of this array contains 
name,title,planneddate,serialseq,serial.subscriptionid from tables : subscription, serial & biblio
.SS "updateClaim"
.IX Subsection "updateClaim"
&updateClaim($serialid)
.PP
this function updates the time when a claim is issued for late/missing items
.PP
called from claims.pl file
.SS "check_routing"
.IX Subsection "check_routing"
\&\f(CW$result\fR = &check_routing($subscriptionid)
.PP
this function checks to see if a serial has a routing list and returns the count of routingid
used to show either an 'add' or 'edit' link
.SS "addroutingmember"
.IX Subsection "addroutingmember"
addroutingmember($borrowernumber,$subscriptionid)
.PP
this function takes a borrowernumber and subscriptionid and adds the member to the
routing list for that serial subscription and gives them a rank on the list
of either 1 or highest current rank + 1
.SS "reorder_members"
.IX Subsection "reorder_members"
reorder_members($subscriptionid,$routingid,$rank)
.PP
this function is used to reorder the routing list
.PP
it takes the routingid of the member one wants to re-rank and the rank it is to move to
\&\- it gets all members on list puts their routingid's into an array
\&\- removes the one in the array that is \f(CW$routingid\fR
\&\- then reinjects \f(CW$routingid\fR at point indicated by \f(CW$rank\fR
\&\- then update the database with the routingids in the new order
.SS "delroutingmember"
.IX Subsection "delroutingmember"
delroutingmember($routingid,$subscriptionid)
.PP
this function either deletes one member from routing list if \f(CW$routingid\fR exists otherwise
deletes all members from the routing list
.SS "getroutinglist"
.IX Subsection "getroutinglist"
\&\f(CW@routinglist\fR = getroutinglist($subscriptionid)
.PP
this gets the info from the subscriptionroutinglist for \f(CW$subscriptionid\fR
.PP
return :
the routinglist as an array. Each element of the array contains a hash_ref containing
routingid \- a unique id, borrowernumber, ranking, and biblionumber of subscription
.SS "countissuesfrom"
.IX Subsection "countissuesfrom"
\&\f(CW$result\fR = countissuesfrom($subscriptionid,$startdate)
.PP
Returns a count of serial rows matching the given subsctiptionid
with published date greater than startdate
.SS "CountIssues"
.IX Subsection "CountIssues"
\&\f(CW$result\fR = CountIssues($subscriptionid)
.PP
Returns a count of serial rows matching the given subsctiptionid
.SS "HasItems"
.IX Subsection "HasItems"
\&\f(CW$result\fR = HasItems($subscriptionid)
.PP
returns a count of items from serial matching the subscriptionid
.SS "abouttoexpire"
.IX Subsection "abouttoexpire"
\&\f(CW$result\fR = abouttoexpire($subscriptionid)
.PP
this function alerts you to the penultimate issue for a serial subscription
.PP
returns 1 \- if this is the penultimate issue
returns 0 \- if not
.SS "GetFictiveIssueNumber"
.IX Subsection "GetFictiveIssueNumber"
\&\f(CW$issueno\fR = GetFictiveIssueNumber($subscription, \f(CW$publishedate\fR, \f(CW$frequency\fR);
.PP
Get the position of the issue published at \f(CW$publisheddate\fR, considering the
first issue (at firstacquidate) is at position 1, the next is at position 2, etc...
This issuenumber doesn't take into account irregularities, so, for instance, if the 3rd
issue is declared as 'irregular' (will be skipped at receipt), the next issue number
will be 4, not 3. It's why it is called 'fictive'. It is \s-1NOT\s0 a serial seq, and is not
depending on how many rows are in serial table.
The issue number calculation is based on subscription frequency, first acquisition
date, and \f(CW$publisheddate\fR.
.PP
Returns undef when called for irregular frequencies.
.PP
The routine is used to skip irregularities when calculating the next issue
date (in GetNextDate) or the next issue number (in GetNextSeq).
.SS "GetNextDate"
.IX Subsection "GetNextDate"
\&\f(CW$resultdate\fR = GetNextDate($publisheddate,$subscription,$freqdata,$updatecount)
.PP
this function it takes the publisheddate and will return the next issue's date
and will skip dates if there exists an irregularity.
\&\f(CW$publisheddate\fR has to be an \s-1ISO\s0 date
\&\f(CW$subscription\fR is a hashref containing at least 'firstacquidate', 'irregularity', and 'countissuesperunit'
\&\f(CW$frequency\fR is a hashref containing frequency informations
\&\f(CW$updatecount\fR is a boolean value which, when set to true, update the 'countissuesperunit' in database
\&\- eg if periodicity is monthly and \f(CW$publisheddate\fR is 2007\-02\-10 but if March and April is to be
skipped then the returned date will be 2007\-05\-10
.PP
return :
\&\f(CW$resultdate\fR \- then next date in the sequence (\s-1ISO\s0 date)
.PP
Return undef if subscription is irregular
.SS "_numeration"
.IX Subsection "_numeration"
.Vb 1
\&  $string = &_numeration($value,$num_type,$locale);
.Ve
.PP
_numeration returns the string corresponding to \f(CW$value\fR in the num_type
num_type can take :
    \-dayname
    \-dayabrv
    \-monthname
    \-monthabrv
    \-season
    \-seasonabrv
.SS "CloseSubscription"
.IX Subsection "CloseSubscription"
Close a subscription given a subscriptionid
.SS "ReopenSubscription"
.IX Subsection "ReopenSubscription"
Reopen a subscription given a subscriptionid
.SS "subscriptionCurrentlyOnOrder"
.IX Subsection "subscriptionCurrentlyOnOrder"
.Vb 1
\&    $bool = subscriptionCurrentlyOnOrder( $subscriptionid );
.Ve
.PP
Return 1 if subscription is currently on order else 0.
.SS "can_claim_subscription"
.IX Subsection "can_claim_subscription"
.Vb 1
\&    $can = can_claim_subscription( $subscriptionid[, $userid] );
.Ve
.PP
Return 1 if the subscription can be claimed by the current logged user (or a given \f(CW$userid\fR), else 0.
.SS "can_edit_subscription"
.IX Subsection "can_edit_subscription"
.Vb 1
\&    $can = can_edit_subscription( $subscriptionid[, $userid] );
.Ve
.PP
Return 1 if the subscription can be edited by the current logged user (or a given \f(CW$userid\fR), else 0.
.SS "can_show_subscription"
.IX Subsection "can_show_subscription"
.Vb 1
\&    $can = can_show_subscription( $subscriptionid[, $userid] );
.Ve
.PP
Return 1 if the subscription can be shown by the current logged user (or a given \f(CW$userid\fR), else 0.
.SS "findSerialsByStatus"
.IX Subsection "findSerialsByStatus"
.Vb 1
\&    @serials = findSerialsByStatus($status, $subscriptionid);
\&
\&    Returns an array of serials matching a given status and subscription id.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Koha Development Team <http://koha\-community.org/>
